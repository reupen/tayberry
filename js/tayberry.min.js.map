{"version":3,"sources":["tayberry.min.js","/source/helpers/utils.js","/source/base.js","/source/axis.js","/source/helpers/colour.js","/source/constants.js","/source/renderer.base.js","/source/helpers/rect.js","/source/renderer.bar.js","/source/renderer.line.js","/source/legend.js","/source/core.js","/source/drawing.js","/source/events.js","/source/defaults.js","/source/sizing.js","/source/animation.js","/source/tayberry.js"],"names":["global","factory","exports","module","define","amd","Tayberry","this","identity","obj","isMissingValue","n","isNaN","coalesce","_len","arguments","length","vals","Array","_key","i","reduce","array","func","getter","ret","ignoreMissing","undefined","retInitialised","value","a","b","none","every","elem","assign","targetObject","sourceObjects","innerAssign","deepAssign","formatString","formatValues","escapeAsHtml","replace","match","placeholder","stringToHtml","locateDecimalPoint","number","Math","floor","log","formatNumberThousands","decimalPlaces","parts","toFixed","split","join","createAutoNumberFormatter","scale","prefix","suffix","precision","x","createFixedNumberFormatter","createPercentageFormatter","str","div","document","createElement","appendChild","createTextNode","innerHTML","throttle","fn","threshold","last","deferTimer","context","now","Date","args","clearTimeout","setTimeout","apply","babelHelpers","Symbol","iterator","constructor","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","call","inherits","subClass","superClass","create","setPrototypeOf","__proto__","possibleConstructorReturn","self","ReferenceError","slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","next","done","push","err","isArray","selectedItem","containerElement","labelsCanvas","labelsCtx","options","scaleFactor","titleFont","plotArea","categories","labelFont","renderers","onClickReal","onMouseLeaveReal","onMouseMoveReal","onWindowResizeReal","pendingAnimations","legend","callbacks","onResize","onInit","series","data","concat","to","currentSourceObject","keysArray","keys","nextIndex","len","nextKey","nextValue","Axis","tayberry","index","axisType","isHorizontal","tickStep","min","max","tickStart","tickEnd","calculatedSize","topAdjustment","rightAdjustment","numLabelLines","setPlacement","xYSwapped","type","LinearAxis","CategorialAxis","createFontString","font","title","validAndSpecificPlacements","indexOf","placement","isVertical","_this","tb","ticks","getTicks","Utils.reduce","getTextWidth","labelFormatter","mapLogicalXUnit","mapLogicalYUnit","fixedOnly","reset","size","titleFontHeight","getFontHeight","fontHeight","mapLogicalXOrYUnit","elementSmallPadding","text","lastTick","lastTickYStart","y","top","adjustment","maxLabelSize","lastXEnd","tick","textWidth","xStart","xEnd","lastTickXEnd","right","isPlacedAtStart","left","bottom","offsetRect","drawTicksAndLabels","drawTitle","_this2","labelPadding","labelPaddingX","labelPaddingY","xOffset","startProperty","yOffset","save","fillStyle","colour","textAlign","textBaseline","lastXEnds","tickIndex","maxWidth","enumerateTicks","formattedValue","row","rowOffset","width","fillText","gridLines","drawLine","x1","y1","x2","y2","adjustOffsetRect","restore","displacement","labelPaddingSize","yMidpoint","translate","rotate","PI","xMidpoint","visibleOnly","_Axis","callback","categoryCount","clone","swapXY","categoryWidth","factor","labelPosition","_ref","Utils.identity","getOrigin","plotDisplacement","ceil","height","_Axis2","labelFormat","Utils.createPercentageFormatter","labelPrefix","labelSuffix","Utils.createFixedNumberFormatter","currencySymbol","Utils.createAutoNumberFormatter","start","end","endProperty","yValue","getValueDisplacement","round","targetTicks","approxStep","targetStart","targetEnd","overriddenStart","Utils.isMissingValue","overriddenEnd","_ref2","isYAxis","getDataMinMax","getDataXMinMax","_ref3","dataMin","dataMax","dataRange","tickStepValue","targetRange","plotLength","mapLogicalYOrXUnit","pow","scaledStep","snapScaledValue","totalCategories","isRange","axisRange","Utils.formatString","abs","Colour","arg1","parseString","r","g","regExHex","regExInt","groupsHex","exec","groupsInt","parseHex","parseInt","RangeError","parseFloat","component","clipComponent","clip","multiplier","colour1","colour2","blendPosition","blender","c1","c2","Utils.coalesce","visibilityState","visible","hidden","transitioning","Renderer","ctx","setSeries","seriesIndex","_series","renderer","excludeSeries","constants.visibilityState","onToggleSeriesAnimationFrame","rect","highlighted","highlightColour","multiplyAlpha","hiddenAlphaMultiplier","toString","fillRect","sign","swapAxes","labels","verticalAlignment","baseline","align","verticalPosition","mapVerticalPosition","containsPoint","Enumerator","startCategoryIndex","categoryIndex","seriesCount","ByCategoryEnumerator","_Enumerator","getDataValue","BySeriesEnumerator","_Enumerator2","Rect","val","containsX","containsY","clipRect","minX","maxX","minY","maxY","BarRenderer","_renderer$Renderer","barPositions","registerCallback","updateBarWidths","bind","isStacked","barPlot","mode","isOverlaid","isNormal","animatingSeriesCount","totalMultiplier","rState","animationState","subtype","visibleSeriesCount","getVisibleSeriesCount","isShow","stage","yMultiplier","transColour","createFromBlend","totalBarsPerCategory","yOrigin","yAxis","yBottomPositive","yBottomNegative","yRunningTotalPositive","yRunningTotalNegative","categoryXStart","categoryXEnd","barXStart","categorySpacing","barXEnd","categoryPositions","barIndex","runningBarWidth","barWidth","xAxis","barPadding","yTop","yBottom","barEnumerator","BarEnumerator","bar","selected","enabled","drawLabel","found","plotType","isXRange","matches","sortDistance","priority","realDistance","xDist","yDist","sqrt","distance","sort","normalisedDistance","area","Utils.assign","renderer.Renderer","_renderer$ByCategoryE","_renderer$barPosition","tooltips","shared","renderer.ByCategoryEnumerator","autoMarkerIndex","markers","LineRenderer","pointPositions","updatPointPositions","xMultiplier","valueCount","valueOrigin","seriesPositions","valueIndex","xValue","getDataXValue","rValue","totalPoints","markerType","showMarkers","linePlot","noMarkersThreshold","beginPath","arc","fill","moveTo","lineTo","closePath","pointEnumerator","PointEnumerator","pt","firstPoint","lineWidth","seriesSelected","highlightedLineWidth","strokeStyle","lastPoint","stroke","glowColour","drawMarker","highlightedMarkerSize","markerSize","inflate","horizontalDistance","e1","e2","_renderer$BySeriesEnu","_renderer$pointPositi","renderer.BySeriesEnumerator","Legend","xPos","yPos","rowIndices","canvas","smallPadding","largePadding","elementLargePadding","indicatorSize","textWidths","getItemTextWidths","maxLegendItemWidth","numItems","plotWidth","cumWidth","numRows","legendMetrics","getMeasurements","items","item","drawLegendIndicator","indicatorRect","name","textX","textY","newLineIndices","lineWidths","lineStart","lineIndex","lineEnd","currentAutoColourIndex","getAutoColour","defaultColours","dataPoint","setDataValue","newValue","createCanvas","style","clientWidth","clientHeight","position","getElementById","getContext","plotCanvas","plotCtx","yAxes","xAxes","initialise","destroy","parentNode","removeChild","tooltipElement","removeEventListener","window","devicePixelRatio","scaleFactorX","scaleFactorY","forDom","autoScale","face","updateFonts","map","e","setOptions","optionOverrides","defaultOptions","presets","Utils.deepAssign","allAxes","defaultPrimaryYAxis","defaultSecondaryYAxis","defaultXAxis","defaultSeries","createRenderers","calculatePlotArea","forEach","addEventListener","onClick","onMouseMove","onMouseLeave","Utils.throttle","onWindowResize","calculateHighlightColour","newColour","increaseBy","sum","calculateGlowColour","groupedSeries","line","curSeries","xAxisIndex","yAxisIndex","hasOwnProperty","axis","minNormal","maxNormal","minStacked","maxStacked","seriesPositiveTotals","seriesNegativeTotals","barSeries","filter","seriesMinima","seriesMaxima","createTooltip","className","zIndex","borderRadius","backgroundColor","border","padding","display","body","fontString","measureText","getMultilineTextHeight","splitMultilineText","lines","lineText","spaceWidth","wordStart","wordEnd","word","substring","wordWidth","drawTextMultiline","lineHeight","render","drawLabelLayer","animations","setSeriesVisibility","drawPlotLayer","clear","plot","clearRect","drawBackground","plotBackgroundColour","drawPlot","drawLabels","draw","redraw","plotOnly","eventName","event","currentTarget","relatedTarget","handleMouseMove","clientX","clientY","boundingRect","getBoundingClientRect","tooltipDisplayStyleSet","hitTestResult","hitTest","tooltipHtml","aboveZero","category","getCategoryLabel","headerTemplate","valueTemplate","footerTemplate","tooltipRect","borderColor","pageXOffset","mapScreenUnit","pageYOffset","button","toggleSeriesVisibility","oldSelectedItem","backgroundColour","defaultYAxis","histogram","darkGrid","MAX_AXIS_CALC_SIZE_ATTEMPTS","adjustSize","calculateExtent","updateFormatter","Utils.none","revokeAnimation","splice","startAnimation","animation","initialStage","newAnimation","startTime","performance","animator","requestAnimationFrame","onAnimate","timestamp","elapsed","onFrame","onCompletion","onAnimationFrame","newType","element","chart","TayberryBase"],"mappings":"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","file":"tayberry.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.Tayberry = factory());\n}(this, function () { 'use strict';\n\n    var babelHelpers = {};\n    babelHelpers.typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n    };\n\n    babelHelpers.classCallCheck = function (instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    };\n\n    babelHelpers.createClass = function () {\n      function defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      return function (Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n      };\n    }();\n\n    babelHelpers.get = function get(object, property, receiver) {\n      if (object === null) object = Function.prototype;\n      var desc = Object.getOwnPropertyDescriptor(object, property);\n\n      if (desc === undefined) {\n        var parent = Object.getPrototypeOf(object);\n\n        if (parent === null) {\n          return undefined;\n        } else {\n          return get(parent, property, receiver);\n        }\n      } else if (\"value\" in desc) {\n        return desc.value;\n      } else {\n        var getter = desc.get;\n\n        if (getter === undefined) {\n          return undefined;\n        }\n\n        return getter.call(receiver);\n      }\n    };\n\n    babelHelpers.inherits = function (subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n      }\n\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n          value: subClass,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    };\n\n    babelHelpers.possibleConstructorReturn = function (self, call) {\n      if (!self) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n\n      return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    };\n\n    babelHelpers.slicedToArray = function () {\n      function sliceIterator(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"]) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      return function (arr, i) {\n        if (Array.isArray(arr)) {\n          return arr;\n        } else if (Symbol.iterator in Object(arr)) {\n          return sliceIterator(arr, i);\n        } else {\n          throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n        }\n      };\n    }();\n\n    babelHelpers;\n\n    var Tayberry$1 = function () {\n        function Tayberry() {\n            babelHelpers.classCallCheck(this, Tayberry);\n\n            this.selectedItem = {};\n            this.containerElement = null;\n            this.labelsCanvas = null;\n            this.labelsCtx = null;\n            this.options = null;\n            this.scaleFactor = null;\n            this.titleFont = null;\n            this.plotArea = null;\n            this.categories = [];\n            this.titleFont = null;\n            this.labelFont = null;\n            this.renderers = [];\n            this.onClickReal = null;\n            this.onMouseLeaveReal = null;\n            this.onMouseMoveReal = null;\n            this.onWindowResizeReal = null;\n            this.pendingAnimations = [];\n            this.legend = null;\n            this.callbacks = {\n                onResize: [],\n                onInit: []\n            };\n        }\n\n        babelHelpers.createClass(Tayberry, [{\n            key: \"seriesCount\",\n            get: function get() {\n                return this.options.series.length;\n            }\n        }, {\n            key: \"categoryCount\",\n            get: function get() {\n                return this.options.series.length ? this.options.series[0].data.length : 0;\n            }\n        }]);\n        return Tayberry;\n    }();\n\n    function identity(obj) {\n        return obj;\n    }\n\n    function isMissingValue(n) {\n        return n === null || typeof n === 'undefined' || isNaN(n) && typeof n === 'number';\n    }\n\n    function coalesce() {\n        for (var _len = arguments.length, vals = Array(_len), _key = 0; _key < _len; _key++) {\n            vals[_key] = arguments[_key];\n        }\n\n        for (var i = 0; i < vals.length; i++) {\n            if (!isMissingValue(vals[i])) {\n                return vals[i];\n            }\n        }\n    }\n\n    function reduce(array, func, getter) {\n        var ignoreMissing = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\n        var ret, i;\n        if (array.reduce && !getter && !ignoreMissing) {\n            ret = array.reduce(function (a, b) {\n                return func(a, b);\n            });\n        } else {\n            var retInitialised = false;\n            getter = getter || identity;\n            for (i = 0; i < array.length; i++) {\n                var value = getter(array[i], i);\n                if (!ignoreMissing || !isMissingValue(value)) {\n                    ret = retInitialised ? func(ret, value) : value;\n                    retInitialised = true;\n                }\n            }\n        }\n        return ret;\n    }\n\n    var innerAssign = function innerAssign(deepAssign, targetObject, sourceObjects) {\n        if (!Array.isArray(sourceObjects)) sourceObjects = [sourceObjects];\n        if (!deepAssign && Object.assign) {\n            return Object.assign.apply(Object, [targetObject].concat(sourceObjects));\n        } else {\n            if (targetObject === undefined || targetObject === null) {\n                throw new TypeError('Cannot convert first argument to object');\n            }\n\n            var to = Object(targetObject);\n            for (var i = 0; i < sourceObjects.length; i++) {\n                var currentSourceObject = sourceObjects[i];\n                if (currentSourceObject === undefined || currentSourceObject === null) {\n                    continue;\n                }\n                currentSourceObject = Object(currentSourceObject);\n\n                var keysArray = Object.keys(currentSourceObject);\n                for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n                    var nextKey = keysArray[nextIndex];\n                    var nextValue = currentSourceObject[nextKey];\n                    var desc = Object.getOwnPropertyDescriptor(currentSourceObject, nextKey);\n                    if (desc !== undefined && desc.enumerable) {\n                        if (deepAssign && !Array.isArray(nextValue) && (typeof nextValue === 'undefined' ? 'undefined' : babelHelpers.typeof(nextValue)) === 'object' && nextValue !== null) to[nextKey] = innerAssign(true, {}, [to[nextKey], nextValue]);else to[nextKey] = nextValue;\n                    }\n                }\n            }\n            return to;\n        }\n    };\n\n    function none(array) {\n        return array.every(function (elem) {\n            return !elem;\n        });\n    }\n\n    function assign(targetObject, sourceObjects) {\n        return innerAssign(false, targetObject, sourceObjects);\n    }\n\n    function deepAssign(targetObject, sourceObjects) {\n        return innerAssign(true, targetObject, sourceObjects);\n    }\n\n    function formatString(formatString, formatValues, escapeAsHtml) {\n        return formatString.replace(/{(\\w+)}/g, function (match, placeholder) {\n            var value = formatValues[placeholder];\n            return typeof value !== 'undefined' ? escapeAsHtml ? stringToHtml(value) : value : match;\n        });\n    }\n\n    function locateDecimalPoint(number) {\n        return Math.floor(Math.log(number) / Math.log(10));\n    }\n\n    function formatNumberThousands(number) {\n        var decimalPlaces = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n        var parts = number.toFixed(decimalPlaces).split(\".\");\n        parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n        return parts.join(\".\");\n    }\n\n    function createAutoNumberFormatter(scale) {\n        var prefix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n        var suffix = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];\n        var precision = arguments.length <= 3 || arguments[3] === undefined ? 2 : arguments[3];\n\n        var decimalPlaces = locateDecimalPoint(scale);\n        decimalPlaces = decimalPlaces < 0 ? -decimalPlaces + precision - 1 : 0;\n        return function (x) {\n            return prefix + formatNumberThousands(x, decimalPlaces) + suffix;\n        };\n    }\n\n    function createFixedNumberFormatter(scale) {\n        var prefix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n        var suffix = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];\n        var decimalPlaces = arguments.length <= 3 || arguments[3] === undefined ? 2 : arguments[3];\n\n        return function (x) {\n            return prefix + formatNumberThousands(x, decimalPlaces) + suffix;\n        };\n    }\n\n    function createPercentageFormatter(scale) {\n        var prefix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n        var suffix = arguments.length <= 2 || arguments[2] === undefined ? '%' : arguments[2];\n        var precision = arguments.length <= 3 || arguments[3] === undefined ? 2 : arguments[3];\n\n        var decimalPlaces = locateDecimalPoint(scale * 100);\n        decimalPlaces = decimalPlaces < precision ? -decimalPlaces + precision - 1 : 0;\n        return function (x) {\n            return prefix + formatNumberThousands(x * 100, decimalPlaces) + suffix;\n        };\n    }\n\n    function stringToHtml(str) {\n        var div = document.createElement('div');\n        div.appendChild(document.createTextNode(str));\n        return div.innerHTML;\n    }\n\n    function throttle(fn, threshold) {\n        var last, deferTimer;\n        return function () {\n            var context = this;\n\n            var now = Date.now(),\n                args = arguments;\n            if (last && now < last + threshold) {\n                clearTimeout(deferTimer);\n                deferTimer = setTimeout(function () {\n                    last = now;\n                    fn.apply(context, args);\n                }, threshold);\n            } else {\n                last = now;\n                fn.apply(context, args);\n            }\n        };\n    }\n\n    var Axis = function () {\n        babelHelpers.createClass(Axis, null, [{\n            key: 'create',\n            value: function create(tayberry, options, index, axisType, xYSwapped) {\n                var isHorizontal = axisType === 'x' && !xYSwapped || axisType === 'y' && xYSwapped;\n                if (options.type === 'linear') return new LinearAxis(tayberry, index, options, axisType, isHorizontal);else return new CategorialAxis(tayberry, index, options, axisType, isHorizontal);\n            }\n        }]);\n\n        function Axis(tayberry, index, options, axisType, isHorizontal) {\n            babelHelpers.classCallCheck(this, Axis);\n\n            this.tayberry = tayberry;\n            this.options = options;\n            this.axisType = axisType;\n            this.isHorizontal = isHorizontal;\n            this.index = index;\n            this.tickStep = null;\n            this.min = null;\n            this.max = null;\n            this.tickStart = null;\n            this.tickEnd = null;\n            this.calculatedSize = 0;\n            this.topAdjustment = 0;\n            this.rightAdjustment = 0;\n            this.titleFont = null;\n            this.labelFont = null;\n            this.numLabelLines = 1;\n\n            this.setPlacement();\n        }\n\n        babelHelpers.createClass(Axis, [{\n            key: 'updateFonts',\n            value: function updateFonts() {\n                this.labelFont = this.tayberry.createFontString(this.options.font);\n                this.titleFont = this.tayberry.createFontString(this.options.title.font);\n            }\n        }, {\n            key: 'setPlacement',\n            value: function setPlacement() {\n                var validAndSpecificPlacements = ['left', 'right', 'top', 'bottom', 'start', 'end'];\n                if (validAndSpecificPlacements.indexOf(this.options.placement) === -1) {\n                    this.options.placement = this.isVertical ^ this.index > 0 ? 'start' : 'end';\n                }\n            }\n        }, {\n            key: 'maxLabelSize',\n            value: function maxLabelSize() {\n                var _this = this;\n\n                var tb = this.tayberry;\n                var ticks = this.getTicks();\n                return reduce(ticks, Math.max, function (x) {\n                    return tb.getTextWidth(_this.options.labelFormatter(x.value), _this.labelFont);\n                });\n            }\n        }, {\n            key: 'mapLogicalXOrYUnit',\n            value: function mapLogicalXOrYUnit(x) {\n                return this.isVertical ? this.tayberry.mapLogicalXUnit(x) : this.tayberry.mapLogicalYUnit(x);\n            }\n        }, {\n            key: 'mapLogicalYOrXUnit',\n            value: function mapLogicalYOrXUnit(x) {\n                return !this.isVertical ? this.tayberry.mapLogicalXUnit(x) : this.tayberry.mapLogicalYUnit(x);\n            }\n        }, {\n            key: 'adjustSize',\n            value: function adjustSize(plotArea, fixedOnly, reset) {\n                var size = 0,\n                    tb = this.tayberry,\n                    ret = undefined;\n\n                var titleFontHeight = tb.getFontHeight(this.options.title.font);\n                var fontHeight = tb.getFontHeight(this.options.font);\n\n                if (reset) {\n                    this.calculatedSize = 0;\n                    this.topAdjustment = 0;\n                    this.rightAdjustment = 0;\n                    this.numLabelLines = 1;\n                }\n\n                size += this.mapLogicalXOrYUnit(tb.options.elementSmallPadding);\n                if (this.options.title.text) {\n                    size += this.mapLogicalXOrYUnit(tb.options.elementSmallPadding) + titleFontHeight;\n                }\n\n                if (!fixedOnly) {\n                    var ticks = this.getTicks(false);\n                    if (this.isVertical) {\n                        if (ticks.length) {\n                            var lastTick = ticks[ticks.length - 1];\n                            var lastTickYStart = lastTick.y - fontHeight / 2;\n                            if (lastTickYStart < plotArea.top - this.topAdjustment) {\n                                var adjustment = plotArea.top - lastTickYStart - this.topAdjustment + 1;\n                                plotArea.top += adjustment;\n                                this.topAdjustment += adjustment;\n                            }\n                        }\n                        size += this.maxLabelSize();\n                    } else {\n                        {\n                            var lastXEnd = undefined;\n                            for (var i = 0; i < ticks.length; i++) {\n                                var tick = ticks[i];\n                                var textWidth = tb.getTextWidth(this.options.labelFormatter(tick.value), this.labelFont);\n                                var xStart = tick.x - textWidth / 2;\n                                var xEnd = tick.x + textWidth / 2;\n                                if (typeof lastXEnd !== 'undefined' && xStart <= lastXEnd + 1) {\n                                    this.numLabelLines = 2;\n                                    break;\n                                }\n                                lastXEnd = xEnd;\n                            }\n                        }\n                        if (ticks.length) {\n                            var lastTick = ticks[ticks.length - 1];\n                            var textWidth = tb.getTextWidth(this.options.labelFormatter(lastTick.value), this.labelFont);\n                            var lastTickXEnd = lastTick.x + textWidth / 2;\n                            if (lastTickXEnd >= plotArea.right + this.rightAdjustment) {\n                                var adjustment = lastTickXEnd - plotArea.right - this.rightAdjustment + 1;\n                                plotArea.right -= adjustment;\n                                this.rightAdjustment += adjustment;\n                            }\n                        }\n                        size += fontHeight * this.numLabelLines;\n                    }\n                }\n\n                if (this.isPlacedAtStart) {\n                    if (this.isVertical) {\n                        plotArea.left += size - this.calculatedSize;\n                    } else {\n                        plotArea.top += size - this.calculatedSize;\n                    }\n                } else {\n                    size *= -1;\n                    if (this.isVertical) {\n                        plotArea.right += size - this.calculatedSize;\n                    } else {\n                        plotArea.bottom += size - this.calculatedSize;\n                    }\n                }\n\n                ret = this.calculatedSize !== size;\n                this.calculatedSize = size;\n\n                return ret;\n            }\n        }, {\n            key: 'calculateExtent',\n            value: function calculateExtent() {}\n        }, {\n            key: 'getCategoryLabel',\n            value: function getCategoryLabel() {}\n        }, {\n            key: 'draw',\n            value: function draw(offsetRect) {\n                this.drawTicksAndLabels(offsetRect);\n                this.drawTitle(offsetRect);\n            }\n        }, {\n            key: 'drawTicksAndLabels',\n            value: function drawTicksAndLabels(offsetRect) {\n                var _this2 = this;\n\n                var tb = this.tayberry;\n                var labelPadding = this.mapLogicalXOrYUnit(tb.options.elementSmallPadding);\n                var labelPaddingX = this.isVertical ? labelPadding * (this.isPlacedAtStart ? -1 : 1) : 0;\n                var labelPaddingY = !this.isVertical ? labelPadding * (this.isPlacedAtStart ? -1 : 1) : 0;\n                var fontHeight = tb.getFontHeight(this.options.font);\n                var xOffset = this.isVertical ? offsetRect[this.startProperty] : 0;\n                var yOffset = !this.isVertical ? offsetRect[this.startProperty] : 0;\n\n                tb.labelsCtx.save();\n                tb.labelsCtx.font = this.labelFont;\n                tb.labelsCtx.fillStyle = this.options.font.colour;\n                tb.labelsCtx.textAlign = this.isVertical ? this.isPlacedAtStart ? 'right' : 'left' : 'center';\n                tb.labelsCtx.textBaseline = this.isVertical ? 'middle' : this.isPlacedAtStart ? 'bottom' : 'top';\n\n                var lastXEnds = [],\n                    tickIndex = 0,\n                    maxWidth = 0;\n\n                this.enumerateTicks(function (tick) {\n                    var xStart = undefined,\n                        xEnd = undefined;\n                    var formattedValue = _this2.options.labelFormatter(tick.value);\n                    var row = tickIndex % _this2.numLabelLines;\n                    var rowOffset = _this2.isVertical ? 0 : fontHeight * row;\n                    var textWidth = tb.getTextWidth(formattedValue, _this2.labelFont);\n                    if (!_this2.isVertical) {\n                        xStart = tick.x - textWidth / 2;\n                        xEnd = tick.x + textWidth / 2;\n                    }\n\n                    if (_this2.isVertical || (typeof lastXEnds[row] === 'undefined' || xStart > lastXEnds[row] + 1) && xStart >= 0 && xEnd < tb.labelsCanvas.width) {\n                        maxWidth = Math.max(maxWidth, textWidth);\n                        tb.labelsCtx.fillText(formattedValue, tick.x + labelPaddingX + xOffset, tick.y + labelPaddingY + rowOffset + yOffset);\n                        lastXEnds[row] = xEnd;\n                    }\n                    if (_this2.options.gridLines.colour) tb.drawLine(tick.x1, tick.y1, tick.x2, tick.y2, _this2.options.gridLines.colour);\n                    tickIndex++;\n                });\n\n                this.adjustOffsetRect(offsetRect, this.isVertical ? maxWidth + labelPadding : fontHeight + labelPadding);\n\n                tb.labelsCtx.restore();\n            }\n        }, {\n            key: 'adjustOffsetRect',\n            value: function adjustOffsetRect(offsetRect, displacement) {\n                offsetRect[this.startProperty] += this.isPlacedAtStart ? -displacement : displacement;\n            }\n        }, {\n            key: 'drawTitle',\n            value: function drawTitle(offsetRect) {\n                if (this.options.title.text) {\n                    var tb = this.tayberry;\n                    tb.labelsCtx.save();\n                    tb.labelsCtx.font = this.titleFont;\n                    tb.labelsCtx.fillStyle = this.options.title.font.colour;\n                    tb.labelsCtx.textAlign = 'center';\n\n                    var labelPaddingSize = this.mapLogicalXOrYUnit(tb.options.elementSmallPadding);\n                    var labelPadding = labelPaddingSize * (this.isPlacedAtStart ? -1 : 1);\n                    var xOffset = this.isVertical ? offsetRect[this.startProperty] : 0;\n                    var yOffset = !this.isVertical ? offsetRect[this.startProperty] : 0;\n                    var fontHeight = tb.getFontHeight(this.options.title.font);\n\n                    if (this.isVertical) {\n                        tb.labelsCtx.textBaseline = 'bottom';\n                        var x = tb.plotArea[this.startProperty] + xOffset + labelPadding;\n                        var y = tb.plotArea.yMidpoint + yOffset;\n                        tb.labelsCtx.translate(x, y);\n                        tb.labelsCtx.rotate((this.isPlacedAtStart ? -1 : 1) * Math.PI / 2);\n                        tb.labelsCtx.fillText(this.options.title.text, 0, 0);\n                    } else {\n                        tb.labelsCtx.textBaseline = this.isPlacedAtStart ? 'bottom' : 'top';\n                        var x = tb.plotArea.xMidpoint + xOffset;\n                        var y = tb.plotArea[this.startProperty] + labelPadding + yOffset;\n                        //tb.mapLogicalYOrXUnit(tb.options.font.size * 2 + tb.options.elementSmallPadding + tb.options.elementLargePadding)\n                        tb.labelsCtx.fillText(this.options.title.text, x, y);\n                    }\n                    this.adjustOffsetRect(offsetRect, fontHeight + labelPaddingSize);\n                    tb.labelsCtx.restore();\n                }\n            }\n        }, {\n            key: 'getTicks',\n            value: function getTicks() {\n                var visibleOnly = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n                var ret = [];\n                this.enumerateTicks(function (tick) {\n                    ret.push(tick);\n                }, visibleOnly);\n                return ret;\n            }\n        }, {\n            key: 'getOrigin',\n            value: function getOrigin() {}\n        }, {\n            key: 'updateFormatter',\n            value: function updateFormatter() {}\n        }, {\n            key: 'isPlacedAtStart',\n            get: function get() {\n                return this.options.placement === \"left\" || this.options.placement === \"bottom\" || this.options.placement === \"start\";\n            }\n        }, {\n            key: 'isYAxis',\n            get: function get() {\n                return this.axisType === 'y';\n            }\n        }, {\n            key: 'isVertical',\n            get: function get() {\n                return !this.isHorizontal;\n            }\n        }, {\n            key: 'startProperty',\n            get: function get() {\n                if (this.isVertical) return this.isPlacedAtStart ? 'left' : 'right';else return this.isPlacedAtStart ? 'top' : 'bottom';\n            }\n        }, {\n            key: 'endProperty',\n            get: function get() {\n                if (this.isVertical) return !this.isPlacedAtStart ? 'left' : 'right';else return !this.isPlacedAtStart ? 'top' : 'bottom';\n            }\n        }, {\n            key: 'valueOrigin',\n            get: function get() {\n                return this.min <= 0 && 0 <= this.max ? 0 : this.min > 0 ? this.min : this.max;\n            }\n        }]);\n        return Axis;\n    }();\n\n    var CategorialAxis = function (_Axis) {\n        babelHelpers.inherits(CategorialAxis, _Axis);\n\n        function CategorialAxis() {\n            babelHelpers.classCallCheck(this, CategorialAxis);\n            return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(CategorialAxis).apply(this, arguments));\n        }\n\n        babelHelpers.createClass(CategorialAxis, [{\n            key: 'enumerateTicks',\n            value: function enumerateTicks(callback) {\n                var tb = this.tayberry;\n\n                var categoryCount = this.options.categories.length;\n                var plotArea = tb.plotArea.clone();\n                if (this.isVertical) plotArea.swapXY();\n                var categoryWidth = plotArea.width / tb.categoryCount;\n                var factor = 0.5;\n\n                if (!this.isVertical) {\n                    switch (this.options.labelPosition) {\n                        case 'left':\n                            factor = 0;\n                            break;\n                        case 'right':\n                            factor = 1;\n                            break;\n                    }\n                }\n\n                for (var i = 0; i < categoryCount; i++) {\n                    var value = this.options.categories[i];\n                    var y1 = this.isPlacedAtStart ? plotArea.top : plotArea.bottom;\n                    var y2 = !this.isPlacedAtStart ? plotArea.top : plotArea.bottom;\n                    var x1 = plotArea.left + Math.floor(i * categoryWidth);\n                    var x2 = x1;\n                    var x = plotArea.left + Math.floor(i * categoryWidth + categoryWidth * factor);\n                    var y = y1;\n                    if (this.isVertical) {\n                        ;\n\n                        var _ref = [y1, x1, y2, x2, y, x];\n                        x1 = _ref[0];\n                        y1 = _ref[1];\n                        x2 = _ref[2];\n                        y2 = _ref[3];\n                        x = _ref[4];\n                        y = _ref[5];\n                    }callback({\n                        value: value,\n                        x1: x1,\n                        y1: y1,\n                        x2: x2,\n                        y2: y2,\n                        x: x,\n                        y: y\n                    });\n                }\n            }\n        }, {\n            key: 'updateFormatter',\n            value: function updateFormatter() {\n                if (!this.options.labelFormatter) {\n                    this.options.labelFormatter = identity;\n                }\n            }\n        }, {\n            key: 'getCategoryLabel',\n            value: function getCategoryLabel(index) {\n                return this.options.labelFormatter(this.options.categories[index]);\n            }\n        }, {\n            key: 'getOrigin',\n            value: function getOrigin() {\n                return this.tayberry.plotArea[this.isVertical ? 'bottom' : 'left'];\n            }\n        }, {\n            key: 'getValueDisplacement',\n            value: function getValueDisplacement(value) {\n                var ret = this.getOrigin() + this.plotDisplacement * (value + 0.5) / this.options.categories.length;\n                ret = this.isVertical ? Math.floor(ret) : Math.ceil(ret);\n                return ret;\n            }\n        }, {\n            key: 'plotDisplacement',\n            get: function get() {\n                return this.isVertical ? -this.tayberry.plotArea.height : this.tayberry.plotArea.width;\n            }\n        }]);\n        return CategorialAxis;\n    }(Axis);\n\n    var LinearAxis = function (_Axis2) {\n        babelHelpers.inherits(LinearAxis, _Axis2);\n\n        function LinearAxis() {\n            babelHelpers.classCallCheck(this, LinearAxis);\n            return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(LinearAxis).apply(this, arguments));\n        }\n\n        babelHelpers.createClass(LinearAxis, [{\n            key: 'updateFormatter',\n            value: function updateFormatter() {\n                if (!this.options.labelFormatter) {\n                    if (this.options.labelFormat === 'percentage') {\n                        this.options.labelFormatter = createPercentageFormatter(this.max - this.min, this.options.labelPrefix, this.options.labelSuffix);\n                    } else if (this.options.labelFormat === 'currency') {\n                        this.options.labelFormatter = createFixedNumberFormatter(this.max - this.min, this.options.labelPrefix || this.options.currencySymbol, this.options.labelSuffix);\n                    } else {\n                        this.options.labelFormatter = createAutoNumberFormatter(this.max - this.min, this.options.labelPrefix, this.options.labelSuffix);\n                    }\n                }\n            }\n        }, {\n            key: 'enumerateTicks',\n            value: function enumerateTicks(callback) {\n                var tb = this.tayberry;\n\n                var start = this.startProperty,\n                    end = this.endProperty;\n\n                for (var yValue = this.tickStart; yValue <= this.tickEnd && this.tickStep;) {\n                    var y = this.getValueDisplacement(yValue);\n                    if (this.isVertical) {\n                        if (callback({\n                            value: yValue,\n                            x1: tb.plotArea[start],\n                            y1: y,\n                            x2: tb.plotArea[end],\n                            y2: y,\n                            x: tb.plotArea[start],\n                            y: y\n\n                        })) break;\n                    } else {\n                        if (callback({\n                            value: yValue,\n                            y1: tb.plotArea[start],\n                            x1: y,\n                            y2: tb.plotArea[end],\n                            x2: y,\n                            y: tb.plotArea[start],\n                            x: y\n                        })) break;\n                    }\n                    yValue = this.tickStart + Math.round((yValue + this.tickStep - this.tickStart) / this.tickStep) * this.tickStep;\n                }\n            }\n        }, {\n            key: 'calculateExtent',\n            value: function calculateExtent() {\n                var targetTicks = undefined,\n                    approxStep = undefined,\n                    scale = undefined;\n\n                var targetStart = this.options.min;\n                var targetEnd = this.options.max;\n                var overriddenStart = !isMissingValue(targetStart);\n                var overriddenEnd = !isMissingValue(targetEnd);\n\n                if (!overriddenStart || !overriddenEnd) {\n                    var _ref2 = this.isYAxis ? this.tayberry.getDataMinMax(this) : this.tayberry.getDataXMinMax(this);\n\n                    var _ref3 = babelHelpers.slicedToArray(_ref2, 2);\n\n                    var dataMin = _ref3[0];\n                    var dataMax = _ref3[1];\n\n                    var dataRange = dataMax - dataMin;\n                    if (!overriddenStart) {\n                        targetStart = dataMin;\n                        if (this.isYAxis) {\n                            targetStart = targetStart - dataRange * 0.1;\n                            if (dataMin >= 0 && targetStart < 0) targetStart = 0;\n                        }\n                    }\n                    if (!overriddenEnd) {\n                        targetEnd = dataMax;\n                        if (this.isYAxis) {\n                            targetEnd = dataMax + dataRange * 0.1;\n                            if (dataMax <= 0 && targetStart > 0) targetEnd = 0;\n                        }\n                    }\n                }\n\n                if (this.options.tickStepValue) {\n                    this.tickStep = this.options.tickStepValue;\n                    this.min = targetStart;\n                    this.max = targetEnd;\n                } else {\n                    var targetRange = targetEnd - targetStart;\n                    targetTicks = this.plotLength / this.mapLogicalYOrXUnit(this.options.tickStep);\n                    approxStep = targetRange / targetTicks;\n                    scale = Math.pow(10, Math.floor(Math.log(approxStep) / Math.log(10)));\n                    var scaledStep = LinearAxis.snapScaledValue(Math.ceil(approxStep / scale));\n                    this.tickStep = scaledStep * scale;\n                    this.min = targetStart;\n                    this.max = targetEnd;\n                }\n                this.tickStart = this.options.tickStepValue && overriddenStart ? this.min : Math.floor(this.min / this.tickStep) * this.tickStep;\n                this.tickEnd = this.options.tickStepValue && overriddenEnd ? this.max : Math.ceil(this.max / this.tickStep) * this.tickStep;\n                if (!overriddenStart && this.isYAxis) this.min = this.tickStart;\n                if (!overriddenEnd && this.isYAxis) this.max = this.tickEnd;\n            }\n        }, {\n            key: 'getOrigin',\n            value: function getOrigin() {\n                var ret = this.tayberry.plotArea[this.isVertical ? 'bottom' : 'left'] - (0 - this.min) * this.plotDisplacement / (this.max - this.min);\n                if (this.isVertical) ret--;\n                ret = this.isVertical ? Math.floor(ret) : Math.ceil(ret);\n                return ret;\n            }\n        }, {\n            key: 'getValueDisplacement',\n            value: function getValueDisplacement(value) {\n                var ret = this.getOrigin() - value * this.plotDisplacement / (this.max - this.min);\n                ret = this.isVertical ? Math.floor(ret) : Math.ceil(ret);\n                return ret;\n            }\n        }, {\n            key: 'getCategoryLabel',\n            value: function getCategoryLabel(index, totalCategories, isRange) {\n                if (isRange) {\n                    var start = index / totalCategories;\n                    var end = (index + 1) / totalCategories;\n                    var axisRange = this.max - this.min;\n                    return formatString('{0} ≤ x < {1}', [this.options.labelFormatter(this.min + start * axisRange), this.options.labelFormatter(this.min + end * axisRange)]);\n                } else {\n                    return this.options.labelFormatter(index);\n                }\n            }\n        }, {\n            key: 'plotDisplacement',\n            get: function get() {\n                return this.isVertical ? this.tayberry.plotArea.height - 1 : -(this.tayberry.plotArea.width - 1);\n            }\n        }, {\n            key: 'plotLength',\n            get: function get() {\n                return Math.abs(this.plotDisplacement);\n            }\n        }], [{\n            key: 'snapScaledValue',\n            value: function snapScaledValue(scaledStep) {\n                if (scaledStep < 1) scaledStep = 1;else if (scaledStep < 2) scaledStep = 2;else if (scaledStep < 2.5) scaledStep = 2.5;else if (scaledStep < 5) scaledStep = 5;else scaledStep = 10;\n                return scaledStep;\n            }\n        }]);\n        return LinearAxis;\n    }(Axis);\n\n    var Colour = function () {\n        /**\r\n         * Constructs a Colour object.\r\n         *\r\n         * @param colourCode    an HTML colour code in hex or integer (rgb) form\r\n         */\n\n        function Colour() {\n            babelHelpers.classCallCheck(this, Colour);\n\n            if (arguments.length === 1) {\n                var arg1 = arguments[0];\n                if (typeof arg1 === 'string') this.parseString(arg1);else {\n                    this.r = arg1.r;\n                    this.g = arg1.g;\n                    this.b = arg1.b;\n                    this.a = arg1.a;\n                }\n            }\n        }\n\n        /**\r\n         * Parses an HTML colour code\r\n         * @param str\r\n         * @returns {Colour}\r\n         */\n\n        babelHelpers.createClass(Colour, [{\n            key: 'parseString',\n            value: function parseString(str) {\n                var regExHex = /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})|^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i;\n                var regExInt = /^rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})(\\s*,\\s*([0-9]*\\.?[0-9]+)\\s*)?\\)$/i;\n                var groupsHex = regExHex.exec(str);\n                var groupsInt = regExInt.exec(str);\n                if (groupsHex) {\n                    var parseHex = function parseHex(value) {\n                        var ret = parseInt(value, 16);\n                        ret = ret * 0x10 + ret;\n                        return ret;\n                    };\n                    this.r = groupsHex[1] ? parseInt(groupsHex[1], 16) : parseHex(groupsHex[4]);\n                    this.g = groupsHex[2] ? parseInt(groupsHex[2], 16) : parseHex(groupsHex[5]);\n                    this.b = groupsHex[3] ? parseInt(groupsHex[3], 16) : parseHex(groupsHex[6]);\n                    this.a = 1.0;\n                } else if (groupsInt) {\n                    this.r = parseInt(groupsInt[1]);\n                    this.g = parseInt(groupsInt[2]);\n                    this.b = parseInt(groupsInt[3]);\n                    this.a = groupsInt[5] ? parseFloat(groupsInt[5]) : 1.0;\n                } else {\n                    throw new RangeError(str + \" is not a valid HTML colour\");\n                }\n                return this;\n            }\n\n            /**\r\n             * Clips a colour component to be in the range [0, 255], and round it them to\r\n             * the nearest integer\r\n             * @param component\r\n             * @returns {Colour}\r\n             */\n\n        }, {\n            key: 'clipComponent',\n            value: function clipComponent(component) {\n                this[component] = Math.round(this[component]);\n                this[component] = Math.min(this[component], 255);\n                this[component] = Math.max(this[component], 0);\n                return this;\n            }\n\n            /**\r\n             * Clips r,g,b colour components to be in the range [0, 255], and rounds them to\r\n             * the nearest integer\r\n             * @returns {Colour}\r\n             */\n\n        }, {\n            key: 'clip',\n            value: function clip() {\n                this.clipComponent('r');\n                this.clipComponent('g');\n                this.clipComponent('b');\n                return this;\n            }\n\n            /**\r\n             * Adds a number to each colour component\r\n             * @param number\r\n             * @returns {Colour}\r\n             */\n\n        }, {\n            key: 'increaseBy',\n            value: function increaseBy(number) {\n                this.r += number;\n                this.g += number;\n                this.b += number;\n                this.clip();\n                return this;\n            }\n        }, {\n            key: 'multiplyAlpha',\n            value: function multiplyAlpha(multiplier) {\n                this.a *= multiplier;\n                return this;\n            }\n        }, {\n            key: 'toString',\n\n            /**\r\n             * Formats this colour as a string\r\n             * @returns {String}\r\n             */\n            value: function toString() {\n                var ret;\n                if (!isMissingValue(this.a) && this.a !== 1.0) {\n                    ret = formatString('rgba({r},{g},{b},{a})', this);\n                } else {\n                    ret = formatString('rgb({r},{g},{b})', this);\n                }\n                return ret;\n            }\n        }, {\n            key: 'sum',\n            get: function get() {\n                return this.r + this.g + this.b;\n            }\n        }], [{\n            key: 'createFromBlend',\n            value: function createFromBlend(colour1, colour2, blendPosition) {\n                var blender = function blender(c1, c2) {\n                    return c1 + blendPosition * (c2 - c1);\n                };\n                return new Colour({\n                    r: blender(colour1.r, colour2.r),\n                    g: blender(colour1.g, colour2.g),\n                    b: blender(colour1.b, colour2.b),\n                    a: blender(coalesce(colour1.a, 1), coalesce(colour2.a, 1))\n                }).clip();\n            }\n        }]);\n        return Colour;\n    }();\n\n    var visibilityState = {\n        visible: 1 << 0,\n        hidden: 1 << 1,\n        transitioning: 1 << 2\n    };\n\n    var Renderer = function () {\n        function Renderer(ctx, tayberry, series) {\n            babelHelpers.classCallCheck(this, Renderer);\n\n            this.ctx = ctx;\n            this.tb = tayberry;\n            this.series = null;\n            this.setSeries(series);\n        }\n\n        babelHelpers.createClass(Renderer, [{\n            key: 'setSeries',\n            value: function setSeries(series) {\n                var seriesIndex;\n                this.series = series;\n\n                for (seriesIndex = 0; seriesIndex < this.series.length; seriesIndex++) {\n                    var _series = this.series[seriesIndex];\n                    _series.renderer = this;\n                }\n            }\n        }, {\n            key: 'getVisibleSeriesCount',\n            value: function getVisibleSeriesCount(excludeSeries) {\n                var ret = 0;\n                for (var index = 0; index < this.series.length; index++) {\n                    if (index !== excludeSeries) {\n                        var series = this.series[index];\n                        if (series.visible & visibilityState.visible) ret++;\n                    }\n                }\n                return ret;\n            }\n        }, {\n            key: 'onToggleSeriesAnimationFrame',\n            value: function onToggleSeriesAnimationFrame() {}\n        }, {\n            key: 'onAnimationFrame',\n            value: function onAnimationFrame() {\n                this.onToggleSeriesAnimationFrame();\n            }\n        }, {\n            key: 'drawLegendIndicator',\n            value: function drawLegendIndicator(ctx, series, rect, highlighted) {\n                ctx.fillStyle = highlighted ? series.highlightColour : series.colour;\n                if (!(series.visible & visibilityState.visible)) ctx.fillStyle = new Colour(ctx.fillStyle).multiplyAlpha(this.tb.options.legend.hiddenAlphaMultiplier).toString();\n                ctx.fillRect(rect.left, rect.top, rect.width, rect.height);\n            }\n        }, {\n            key: 'drawLabel',\n            value: function drawLabel(sign, text, rect) {\n                if (this.tb.options.swapAxes) rect = rect.clone().swapXY();\n                var x = (rect.left + rect.right) / 2;\n                var y = undefined;\n                if (this.tb.options.labels.verticalAlignment === 'top') y = rect.top;else if (this.tb.options.labels.verticalAlignment === 'bottom') y = rect.bottom;else y = (rect.top + rect.bottom) / 2;\n                var baseline = 'middle';\n                var align = 'center';\n                if (this.tb.options.swapAxes) {\n                    var _ref = [y, x];\n                    x = _ref[0];\n                    y = _ref[1];\n\n                    if (this.tb.options.labels.verticalPosition === 'outside') align = 'left';else if (this.tb.options.labels.verticalPosition === 'inside') align = 'right';\n                } else {\n                    baseline = Tayberry$1.mapVerticalPosition(sign, this.tb.options.labels.verticalPosition);\n                }\n                if (this.tb.plotArea.containsPoint(x, y)) {\n                    this.ctx.save();\n                    this.ctx.textAlign = align;\n                    this.ctx.textBaseline = baseline;\n                    this.ctx.fillText(text, x, y);\n                    this.ctx.restore();\n                }\n            }\n        }, {\n            key: 'drawPlot',\n            value: function drawPlot() {}\n        }, {\n            key: 'drawLabels',\n            value: function drawLabels() {}\n        }, {\n            key: 'hitTest',\n            value: function hitTest() {}\n        }]);\n        return Renderer;\n    }();\n\n    var Enumerator = function () {\n        function Enumerator(renderer) {\n            var startCategoryIndex = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n            babelHelpers.classCallCheck(this, Enumerator);\n\n            this.renderer = renderer;\n            this.tb = renderer.tb;\n\n            this.categoryCount = this.renderer.series[0].data.length;\n            this.categoryIndex = 0;\n            this.seriesIndex = 0;\n            this.seriesCount = this.renderer.series.length;\n            if (this.categoryCount) {\n                this.isHorizontal = this.tb.options.swapAxes;\n                this.plotArea = this.tb.plotArea.clone();\n                if (this.isHorizontal) this.plotArea.swapXY();\n                this.startCategoryIndex = Math.max(startCategoryIndex, 0);\n                this.startCategoryIndex = Math.min(this.startCategoryIndex, this.categoryCount - 1);\n                this.categoryIndex = this.startCategoryIndex;\n            }\n        }\n\n        babelHelpers.createClass(Enumerator, [{\n            key: 'nextValue',\n            value: function nextValue() {}\n        }]);\n        return Enumerator;\n    }();\n\n    var ByCategoryEnumerator = function (_Enumerator) {\n        babelHelpers.inherits(ByCategoryEnumerator, _Enumerator);\n\n        function ByCategoryEnumerator() {\n            babelHelpers.classCallCheck(this, ByCategoryEnumerator);\n            return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ByCategoryEnumerator).apply(this, arguments));\n        }\n\n        babelHelpers.createClass(ByCategoryEnumerator, [{\n            key: 'nextValue',\n            value: function nextValue() {\n\n                var value = undefined;\n                do {\n                    if (this.seriesIndex + 1 === this.seriesCount) {\n                        this.seriesIndex = 0;\n                        this.categoryIndex++;\n                        if (this.categoryIndex >= this.categoryCount) break;\n                    } else {\n                        this.seriesIndex++;\n                    }\n                    value = Tayberry$1.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]);\n                } while (isMissingValue(value));\n            }\n        }]);\n        return ByCategoryEnumerator;\n    }(Enumerator);\n\n    var BySeriesEnumerator = function (_Enumerator2) {\n        babelHelpers.inherits(BySeriesEnumerator, _Enumerator2);\n\n        function BySeriesEnumerator() {\n            babelHelpers.classCallCheck(this, BySeriesEnumerator);\n            return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BySeriesEnumerator).apply(this, arguments));\n        }\n\n        babelHelpers.createClass(BySeriesEnumerator, [{\n            key: 'nextValue',\n            value: function nextValue() {\n\n                var value = undefined;\n                do {\n                    if (this.categoryIndex + 1 === this.categoryCount) {\n                        this.categoryIndex = this.startCategoryIndex;\n                        this.seriesIndex++;\n                        if (this.seriesIndex >= this.seriesCount) break;\n                    } else {\n                        this.categoryIndex++;\n                    }\n                    value = Tayberry$1.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]);\n                } while (isMissingValue(value));\n            }\n        }]);\n        return BySeriesEnumerator;\n    }(Enumerator);\n\n    var Rect = function () {\n        function Rect() {\n            babelHelpers.classCallCheck(this, Rect);\n\n            if (arguments.length === 1) {\n                if (babelHelpers.typeof(arguments[0]) === 'object') {\n                    var rect = arguments[0];\n                    this.left = rect.left;\n                    this.top = rect.top;\n                    this.right = rect.right;\n                    this.bottom = rect.bottom;\n                } else {\n                    var val = arguments[0];\n                    this.left = val;\n                    this.top = val;\n                    this.right = val;\n                    this.bottom = val;\n                }\n            } else if (arguments.length === 4) {\n                this.left = arguments[0];\n                this.top = arguments[1];\n                this.right = arguments[2];\n                this.bottom = arguments[3];\n            }\n        }\n\n        babelHelpers.createClass(Rect, [{\n            key: 'containsPoint',\n            value: function containsPoint(x, y) {\n                return this.containsX(x) && this.containsY(y);\n            }\n        }, {\n            key: 'containsY',\n            value: function containsY(y) {\n                return y >= this.top && y < this.bottom || y >= this.bottom && y < this.top;\n            }\n        }, {\n            key: 'containsX',\n            value: function containsX(x) {\n                return x >= this.left && x < this.right || x >= this.right && x < this.left;\n            }\n        }, {\n            key: 'inflate',\n            value: function inflate(val) {\n                this.left -= val;\n                this.top -= val;\n                this.right += val;\n                this.bottom += val;\n                return this;\n            }\n        }, {\n            key: 'clip',\n            value: function clip(clipRect) {\n                //FIXME: In theory, we should be more careful about how we handle rects where right < left or bottom < top\n                if (this.left < clipRect.minX) this.left = clipRect.minX;else if (this.left > clipRect.maxX) this.left = clipRect.maxX;\n\n                if (this.right < clipRect.minX) this.right = clipRect.minX;else if (this.right > clipRect.maxX) this.right = clipRect.maxX;\n\n                if (this.top < clipRect.minY) this.top = clipRect.minY;else if (this.top > clipRect.maxY) this.top = clipRect.maxY;\n\n                if (this.bottom > clipRect.maxY) this.bottom = clipRect.maxY;else if (this.bottom < clipRect.minY) this.bottom = clipRect.minY;\n\n                return this;\n            }\n        }, {\n            key: 'clone',\n            value: function clone() {\n                return new Rect(this);\n            }\n        }, {\n            key: 'swapXY',\n            value: function swapXY() {\n                var _ref = [this.top, this.left];\n                this.left = _ref[0];\n                this.top = _ref[1];\n                var _ref2 = [this.right, this.bottom];\n                this.bottom = _ref2[0];\n                this.right = _ref2[1];\n\n                return this;\n            }\n        }, {\n            key: 'width',\n            get: function get() {\n                return this.right - this.left;\n            }\n        }, {\n            key: 'height',\n            get: function get() {\n                return this.bottom - this.top;\n            }\n        }, {\n            key: 'maxY',\n            get: function get() {\n                return Math.max(this.bottom, this.top);\n            }\n        }, {\n            key: 'minY',\n            get: function get() {\n                return Math.min(this.bottom, this.top);\n            }\n        }, {\n            key: 'minX',\n            get: function get() {\n                return Math.min(this.left, this.right);\n            }\n        }, {\n            key: 'maxX',\n            get: function get() {\n                return Math.max(this.left, this.right);\n            }\n        }, {\n            key: 'xMidpoint',\n            get: function get() {\n                return (this.left + this.right) / 2;\n            }\n        }, {\n            key: 'yMidpoint',\n            get: function get() {\n                return (this.top + this.bottom) / 2;\n            }\n        }, {\n            key: 'area',\n            get: function get() {\n                return Math.abs(this.width) * Math.abs(this.height);\n            }\n        }]);\n        return Rect;\n    }();\n\n    var BarRenderer = function (_renderer$Renderer) {\n        babelHelpers.inherits(BarRenderer, _renderer$Renderer);\n\n        function BarRenderer(ctx, tayberry, series) {\n            babelHelpers.classCallCheck(this, BarRenderer);\n\n            var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BarRenderer).call(this, ctx, tayberry, series));\n\n            _this.barPositions = null;\n\n            _this.tb.registerCallback('onResize', _this.updateBarWidths.bind(_this));\n            _this.tb.registerCallback('onInit', _this.updateBarWidths.bind(_this));\n            return _this;\n        }\n\n        babelHelpers.createClass(BarRenderer, [{\n            key: 'updateBarWidths',\n            value: function updateBarWidths() {\n                var categoryCount = this.series[0].data.length;\n                var isStacked = this.tb.options.barPlot.mode === 'stacked';\n                var isOverlaid = this.tb.options.barPlot.mode === 'overlaid';\n                var isNormal = !isStacked && !isOverlaid;\n                var seriesCount = this.series.length;\n                var plotArea = this.tb.options.swapAxes ? this.tb.plotArea.clone().swapXY() : this.tb.plotArea;\n                var categoryWidth = plotArea.width / categoryCount;\n                var animatingSeriesCount = 0;\n                var totalMultiplier = 0;\n\n                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\n                    var series = this.series[seriesIndex];\n                    var rState = series.rState;\n                    if (series.animationState) {\n                        if (!series.animationState.subtype) {\n                            var visibleSeriesCount = this.getVisibleSeriesCount(seriesIndex);\n                            if (isNormal && visibleSeriesCount > 0) {\n                                series.animationState.subtype = 'width';\n                            } else if (isStacked && visibleSeriesCount > 0) {\n                                series.animationState.subtype = 'height';\n                            } else {\n                                series.animationState.subtype = 'fade';\n                            }\n\n                            rState.colour = series.colour;\n                        }\n\n                        var isShow = series.animationState.type === 'show';\n                        if (series.animationState.subtype === 'width') {\n                            rState.multiplier = isShow ? series.animationState.stage : 1 - series.animationState.stage;\n                            rState.yMultiplier = 1;\n                        } else if (series.animationState.subtype === 'height') {\n                            rState.yMultiplier = isShow ? series.animationState.stage : 1 - series.animationState.stage;\n                            rState.multiplier = 1;\n                        } else {\n                            var transColour = new Colour(series.colour);\n                            transColour.a = 0;\n                            if (isShow) rState.colour = Colour.createFromBlend(transColour, new Colour(series.colour), series.animationState.stage).toString();else rState.colour = Colour.createFromBlend(new Colour(series.colour), transColour, series.animationState.stage).toString();\n\n                            rState.yMultiplier = 1;\n                            rState.multiplier = 1;\n                        }\n                        ++animatingSeriesCount;\n                    } else if (series.visible & visibilityState.visible) {\n                        rState.multiplier = 1;\n                        rState.yMultiplier = 1;\n                    } else {\n                        rState.multiplier = 0;\n                        rState.yMultiplier = 0;\n                    }\n                    totalMultiplier += rState.multiplier;\n                }\n\n                var totalBarsPerCategory = isStacked || isOverlaid ? 1 : totalMultiplier;\n                var yOrigin = this.series[0].yAxis.getOrigin();\n\n                this.barPositions = [];\n\n                for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {\n                    var yBottomPositive = yOrigin;\n                    var yBottomNegative = yOrigin;\n                    var yRunningTotalPositive = 0;\n                    var yRunningTotalNegative = 0;\n\n                    var categoryXStart = plotArea.left + Math.floor(categoryIndex * categoryWidth);\n                    var categoryXEnd = plotArea.left + Math.floor((categoryIndex + 1) * categoryWidth);\n                    // FIXME: Need to map this.tb.options.barPlot.categorySpacing\n                    var barXStart = categoryXStart + Math.ceil(categoryWidth * this.tb.options.barPlot.categorySpacing / 2);\n                    var barXEnd = categoryXEnd - Math.floor(categoryWidth * this.tb.options.barPlot.categorySpacing / 2);\n\n                    var categoryPositions = [];\n                    var barIndex = 0;\n\n                    var runningBarWidth = 0;\n\n                    for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\n                        var series = this.series[seriesIndex];\n                        var rState = series.rState;\n                        var value = Tayberry$1.getDataValue(series.data[categoryIndex]) * rState.yMultiplier;\n\n                        var barWidth = Math.floor(rState.multiplier * Math.floor((barXEnd - barXStart) / totalBarsPerCategory));\n\n                        var xStart = Math.floor(barXStart + runningBarWidth) + Math.ceil(series.xAxis.mapLogicalXOrYUnit(this.tb.options.barPlot.barPadding) / 2);\n                        var xEnd = Math.ceil(barXStart + runningBarWidth + barWidth) - Math.floor(series.xAxis.mapLogicalXOrYUnit(this.tb.options.barPlot.barPadding) / 2);\n                        var yTop = series.yAxis.getValueDisplacement(value + (value > 0 ? yRunningTotalPositive : yRunningTotalNegative));\n                        var yBottom = isStacked ? value > 0 ? yBottomPositive : yBottomNegative : yOrigin;\n\n                        categoryPositions.push([xStart, yTop, xEnd, yBottom]);\n\n                        if (isStacked) {\n                            if (value > 0) {\n                                yRunningTotalPositive += value;\n                                yBottomPositive = yTop;\n                            } else {\n                                yRunningTotalNegative += value;\n                                yBottomNegative = yTop;\n                            }\n                        } else if (isNormal) {\n                            barIndex++;\n                            runningBarWidth += barWidth;\n                        }\n                    }\n\n                    this.barPositions.push(categoryPositions);\n                }\n            }\n        }, {\n            key: 'onToggleSeriesAnimationFrame',\n            value: function onToggleSeriesAnimationFrame() {\n                this.updateBarWidths();\n            }\n        }, {\n            key: 'drawPlot',\n            value: function drawPlot() {\n                this.ctx.save();\n                var barEnumerator = new BarEnumerator(this);\n                var bar = undefined;\n                while (bar = barEnumerator.next()) {\n                    if (bar.series.visible & (visibilityState.visible | visibilityState.transitioning)) {\n                        this.ctx.fillStyle = bar.selected ? bar.series.rState.highlightColour : bar.series.rState.colour;\n                        this.ctx.fillRect(bar.rect.left, bar.rect.top, bar.rect.width, bar.rect.height);\n                    }\n                }\n                this.ctx.restore();\n            }\n        }, {\n            key: 'drawLabels',\n            value: function drawLabels() {\n                if (this.tb.options.labels.enabled) {\n                    this.ctx.save();\n                    var barEnumerator = new BarEnumerator(this);\n                    var bar = undefined;\n                    while (bar = barEnumerator.next()) {\n                        if ((bar.series.visible & (visibilityState.visible | visibilityState.transitioning)) === visibilityState.visible) {\n                            this.ctx.font = this.tb.labelFont;\n                            this.ctx.fillStyle = this.tb.options.labels.font.colour;\n                            this.drawLabel(bar.value, bar.series.yAxis.options.labelFormatter(bar.value), bar.rect);\n                        }\n                    }\n                    this.ctx.restore();\n                }\n            }\n        }, {\n            key: 'hitTest',\n            value: function hitTest(x, y) {\n                // TODO: Optimise\n                var ret = {\n                    found: false,\n                    plotType: 'bar',\n                    type: 'plotItem',\n                    isXRange: true\n                };\n\n                var categoryCount = this.series[0].data.length;\n                var isHorizontal = this.tb.options.swapAxes;\n                var plotArea = this.tb.plotArea.clone();\n                if (isHorizontal) plotArea.swapXY();\n                var categoryIndex = Math.floor(categoryCount * ((isHorizontal ? y : x) - plotArea.left) / plotArea.width);\n\n                var matches = [];\n\n                var barEnumerator = new BarEnumerator(this, categoryIndex);\n                var bar = undefined;\n                while (bar = barEnumerator.next()) {\n                    if (bar.categoryIndex > categoryIndex) break;\n                    if (!(bar.series.visible & (visibilityState.visible | visibilityState.transitioning))) continue;\n\n                    var sortDistance = undefined,\n                        priority = undefined,\n                        realDistance = undefined;\n                    if (bar.rect.containsPoint(x, y)) {\n                        sortDistance = 0;\n                        priority = 0;\n                    } else if (bar.rect.containsX(x)) {\n                        sortDistance = y < bar.rect.top ? bar.rect.top - y : y - bar.rect.bottom;\n                        priority = isHorizontal ? 2 : 1;\n                    } else if (bar.rect.containsY(y)) {\n                        sortDistance = x < bar.rect.left ? bar.rect.left - x : x - bar.rect.right;\n                        priority = isHorizontal ? 1 : 2;\n                    } else {\n                        var xDist = Math.min(Math.abs(x - bar.rect.left), Math.abs(x - bar.rect.right));\n                        var yDist = Math.min(Math.abs(y - bar.rect.top), Math.abs(y - bar.rect.bottom));\n                        realDistance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n                        sortDistance = isHorizontal ? yDist : xDist;\n                        priority = 3;\n                    }\n\n                    if (typeof realDistance === 'undefined') realDistance = sortDistance;\n\n                    if (!isMissingValue(realDistance)) {\n                        matches.push({\n                            sortDistance: sortDistance,\n                            distance: realDistance,\n                            priority: priority,\n                            data: {\n                                categoryIndex: bar.categoryIndex,\n                                seriesIndex: bar.seriesIndex,\n                                rect: bar.rect,\n                                series: bar.series,\n                                value: Tayberry$1.getDataValue(this.series[bar.seriesIndex].data[bar.categoryIndex])\n                            }\n                        });\n                    }\n                }\n\n                if (matches.length) {\n                    matches.sort(function (a, b) {\n                        var ret = a.priority - b.priority;\n                        if (!ret) ret = a.sortDistance - b.sortDistance;\n                        if (!ret) ret = a.distance - b.distance;\n                        if (!ret) ret = a.data.rect.height - b.data.rect.height;\n                        return ret;\n                    });\n                    ret.found = true;\n                    ret.normalisedDistance = matches[0].distance + Math.sqrt(matches[0].data.rect.area);\n                    if (ret.normalisedDistance < 0) {\n                        ret.normalisedDistance = 0;\n                    }\n                    ret = assign(ret, matches[0].data);\n                }\n                return ret;\n            }\n        }]);\n        return BarRenderer;\n    }(Renderer);\n\n    var BarEnumerator = function (_renderer$ByCategoryE) {\n        babelHelpers.inherits(BarEnumerator, _renderer$ByCategoryE);\n\n        function BarEnumerator() {\n            babelHelpers.classCallCheck(this, BarEnumerator);\n            return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BarEnumerator).apply(this, arguments));\n        }\n\n        babelHelpers.createClass(BarEnumerator, [{\n            key: 'next',\n            value: function next() {\n                var ret = undefined;\n\n                if (this.categoryIndex < this.categoryCount) {\n                    var _renderer$barPosition = babelHelpers.slicedToArray(this.renderer.barPositions[this.categoryIndex][this.seriesIndex], 4);\n\n                    var xStart = _renderer$barPosition[0];\n                    var yTop = _renderer$barPosition[1];\n                    var xEnd = _renderer$barPosition[2];\n                    var yBottom = _renderer$barPosition[3];\n\n                    var rect = new Rect(xStart, yTop, xEnd, yBottom);\n\n                    if (rect.right < rect.left) rect.right = rect.left;\n                    if (this.isHorizontal) rect.swapXY();\n                    rect.clip(this.tb.plotArea);\n\n                    ret = {\n                        seriesIndex: this.seriesIndex,\n                        categoryIndex: this.categoryIndex,\n                        series: this.renderer.series[this.seriesIndex],\n                        value: Tayberry$1.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]),\n                        rect: rect,\n                        selected: this.tb.selectedItem.type === 'plotItem' && this.tb.selectedItem.categoryIndex === this.categoryIndex && (this.tb.options.tooltips.shared || this.tb.selectedItem.series === this.renderer.series[this.seriesIndex])\n                    };\n\n                    this.nextValue();\n                }\n                return ret;\n            }\n        }]);\n        return BarEnumerator;\n    }(ByCategoryEnumerator);\n\n    var autoMarkerIndex = 0;\n    var markers = ['square', 'diamond', 'circle', 'triangle', 'triangle-inversed'];\n\n    var LineRenderer = function (_renderer$Renderer) {\n        babelHelpers.inherits(LineRenderer, _renderer$Renderer);\n\n        function LineRenderer(ctx, tayberry, series) {\n            babelHelpers.classCallCheck(this, LineRenderer);\n\n            var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(LineRenderer).call(this, ctx, tayberry, series));\n\n            _this.pointPositions = null;\n\n            _this.tb.registerCallback('onResize', _this.updatPointPositions.bind(_this));\n            _this.tb.registerCallback('onInit', _this.updatPointPositions.bind(_this));\n            return _this;\n        }\n\n        babelHelpers.createClass(LineRenderer, [{\n            key: 'updatPointPositions',\n            value: function updatPointPositions() {\n                var seriesCount = this.series.length;\n\n                this.pointPositions = [];\n\n                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\n                    var series = this.series[seriesIndex];\n                    var rState = series.rState;\n                    if (series.animationState) {\n                        if (!series.animationState.subtype) {\n                            series.animationState.subtype = 'height';\n                        }\n\n                        var isShow = series.animationState.type === 'show';\n                        if (series.animationState.subtype === 'height') {\n                            rState.yMultiplier = isShow ? series.animationState.stage : 1 - series.animationState.stage;\n                            rState.xMultiplier = 1;\n                        }\n                    } else if (series.visible & visibilityState.visible) {\n                        rState.xMultiplier = 1;\n                        rState.yMultiplier = 1;\n                    } else {\n                        rState.xMultiplier = 1;\n                        rState.yMultiplier = 0;\n                    }\n                }\n\n                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\n                    var series = this.series[seriesIndex];\n                    var rState = series.rState;\n                    var valueCount = series.data.length;\n                    var yOrigin = series.yAxis.valueOrigin;\n                    var seriesPositions = [];\n\n                    for (var valueIndex = 0; valueIndex < valueCount; valueIndex++) {\n                        var value = Tayberry$1.getDataValue(series.data[valueIndex]);\n                        var xValue = Tayberry$1.getDataXValue(series.data, valueIndex);\n\n                        var rValue = yOrigin + rState.yMultiplier * (value - yOrigin);\n                        var x = series.xAxis.getValueDisplacement(xValue) * rState.xMultiplier;\n                        var y = series.yAxis.getValueDisplacement(rValue);\n\n                        seriesPositions.push([x, y]);\n                    }\n\n                    this.pointPositions.push(seriesPositions);\n                }\n            }\n        }, {\n            key: 'setSeries',\n            value: function setSeries(series) {\n                var totalPoints = 0;\n                for (var i = 0; i < series.length; i++) {\n                    if (!series[i].markerType) {\n                        series[i].markerType = markers[autoMarkerIndex % markers.length];\n                        autoMarkerIndex++;\n                    }\n                    totalPoints += series[i].data.length;\n                }\n                var showMarkers = this.tb.options.linePlot.showMarkers;\n                this.showMarkers = showMarkers === 'auto' ? totalPoints < this.tb.options.linePlot.noMarkersThreshold : showMarkers;\n                babelHelpers.get(Object.getPrototypeOf(LineRenderer.prototype), 'setSeries', this).call(this, series);\n            }\n        }, {\n            key: 'drawMarker',\n            value: function drawMarker(type, x, y, size) {\n                var ctx = arguments.length <= 4 || arguments[4] === undefined ? this.ctx : arguments[4];\n\n                if (type === 'square') {\n                    ctx.fillRect(x - size / 2, y - size / 2, size, size);\n                } else if (type === 'diamond') {\n                    ctx.save();\n                    ctx.translate(x, y);\n                    ctx.rotate(-Math.PI / 4);\n                    ctx.fillRect(0 - size / 2, 0 - size / 2, size, size);\n                    ctx.restore();\n                } else if (type === 'circle') {\n                    size = Math.round(size * 1.2);\n                    ctx.beginPath();\n                    ctx.arc(x, y, size / 2, 0, 2 * Math.PI);\n                    ctx.fill();\n                } else if (type === 'triangle' || type === 'triangle-inversed' && (size = -size)) {\n                    size = Math.round(size * 1.2);\n                    ctx.beginPath();\n                    ctx.moveTo(x - size / 2, y + size / 2);\n                    ctx.lineTo(x, y - size / 2);\n                    ctx.lineTo(x + size / 2, y + size / 2);\n                    ctx.closePath();\n                    ctx.fill();\n                }\n            }\n        }, {\n            key: 'onToggleSeriesAnimationFrame',\n            value: function onToggleSeriesAnimationFrame() {\n                this.updatPointPositions();\n            }\n        }, {\n            key: 'drawPlot',\n            value: function drawPlot() {\n                this.ctx.save();\n                var pointEnumerator = new PointEnumerator(this);\n                var pt = undefined;\n                while (pt = pointEnumerator.next()) {\n                    if (!(pt.series.visible & (visibilityState.visible | visibilityState.transitioning))) continue;\n\n                    if (pt.firstPoint) {\n                        this.ctx.lineWidth = pt.seriesSelected ? this.tb.options.linePlot.highlightedLineWidth : this.tb.options.linePlot.lineWidth;\n                        this.ctx.strokeStyle = pt.seriesSelected ? pt.series.rState.highlightColour : pt.series.rState.colour;\n                        this.ctx.beginPath();\n                        this.ctx.moveTo(pt.x, pt.y);\n                    } else {\n                        this.ctx.lineTo(pt.x, pt.y);\n                    }\n                    if (pt.lastPoint) {\n                        this.ctx.stroke();\n                    }\n                }\n                if (this.showMarkers) {\n                    pointEnumerator = new PointEnumerator(this);\n                    while (pt = pointEnumerator.next()) {\n                        if (!(pt.series.visible & (visibilityState.visible | visibilityState.transitioning))) continue;\n\n                        if (pt.selected) {\n                            this.ctx.fillStyle = pt.series.rState.glowColour;\n                            this.drawMarker(pt.series.markerType, pt.x, pt.y, this.tb.options.linePlot.highlightedMarkerSize);\n                        }\n                        this.ctx.fillStyle = pt.series.rState.colour;\n                        this.drawMarker(pt.series.markerType, pt.x, pt.y, this.tb.options.linePlot.markerSize);\n                    }\n                }\n                this.ctx.restore();\n            }\n        }, {\n            key: 'drawLegendIndicator',\n            value: function drawLegendIndicator(ctx, series, rect, highlighted) {\n                var colour = highlighted ? series.highlightColour : series.colour;\n                ctx.save();\n                ctx.lineWidth = 2;\n                ctx.strokeStyle = colour;\n                this.tb.drawLine(rect.left, rect.yMidpoint, rect.right, rect.yMidpoint);\n                ctx.fillStyle = colour;\n                this.drawMarker(series.markerType, rect.xMidpoint, rect.yMidpoint, this.tb.options.linePlot.markerSize, ctx);\n                ctx.restore();\n            }\n        }, {\n            key: 'drawLabels',\n            value: function drawLabels() {\n                if (this.tb.options.labels.enabled) {\n                    this.ctx.save();\n                    this.ctx.font = this.tb.labelFont;\n                    this.ctx.fillStyle = this.tb.options.labels.font.colour;\n                    var pointEnumerator = new PointEnumerator(this);\n                    var pt = undefined;\n                    while (pt = pointEnumerator.next()) {\n                        if (!(pt.series.visible & (visibilityState.visible | visibilityState.transitioning))) continue;\n\n                        var rect = new Rect(pt.x, pt.y, pt.x, pt.y).inflate(this.tb.options.linePlot.markerSize / 2);\n                        this.drawLabel(pt.value, pt.series.yAxis.options.labelFormatter(pt.value), rect);\n                    }\n                    this.ctx.restore();\n                }\n            }\n        }, {\n            key: 'hitTest',\n            value: function hitTest(x, y) {\n                // TODO: Optimise\n                var ret = {\n                    found: false,\n                    plotType: 'line',\n                    type: 'plotItem',\n                    isXRange: false\n                };\n\n                var matches = [];\n\n                var pointEnumerator = new PointEnumerator(this);\n                var pt = undefined;\n                while (pt = pointEnumerator.next()) {\n                    if (!(pt.series.visible & (visibilityState.visible | visibilityState.transitioning))) continue;\n\n                    var distance = Math.sqrt(Math.pow(pt.x - x, 2) + Math.pow(pt.y - y, 2));\n                    var horizontalDistance = Math.abs(this.tb.options.swapAxes ? pt.y - y : pt.x - x);\n                    matches.push({\n                        distance: distance,\n                        horizontalDistance: horizontalDistance,\n                        priority: 0,\n                        data: pt\n                    });\n                    //if (!pt.firstPoint) {\n                    //    if (x >= lastPt.x && x < pt.x) {\n                    //const alpha = Math.arctan((pt.y - lastPt.y) / (pt.x - lastPt.x));\n                    //const yAtX = (x - lastPt.x) * Math.tan(alpha) + lastPt.y;\n                    //if (yAtX - 2 <= y < yAtX + 2) {\n                    //    matches.push({\n                    //        categoryIndex: pt.categoryIndex,\n                    //        seriesIndex: pt.seriesIndex,\n                    //        x: bar.rect,\n                    //        series: this.series[bar.seriesIndex],\n                    //        dataPoint: this.series[bar.seriesIndex].data[bar.categoryIndex]\n                    //\n                    //    })\n                    //}\n                    //}\n                    //}\n                    //lastPt = pt;\n                }\n                if (matches.length) {\n                    matches.sort(function (e1, e2) {\n                        return e1.horizontalDistance - e2.horizontalDistance || e1.distance - e2.distance;\n                    });\n                    if (true || matches[0].distance <= 5) {\n                        pt = matches[0].data;\n                        var rect = new Rect(pt.x, pt.y, pt.x, pt.y).inflate(this.tb.options.linePlot.markerSize / 2);\n                        assign(ret, [{\n                            found: true,\n                            rect: rect,\n                            normalisedDistance: matches[0].distance + Math.sqrt(rect.area)\n                        }, pt]);\n                    }\n                }\n\n                return ret;\n            }\n        }]);\n        return LineRenderer;\n    }(Renderer);\n\n    var PointEnumerator = function (_renderer$BySeriesEnu) {\n        babelHelpers.inherits(PointEnumerator, _renderer$BySeriesEnu);\n\n        function PointEnumerator() {\n            babelHelpers.classCallCheck(this, PointEnumerator);\n            return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PointEnumerator).apply(this, arguments));\n        }\n\n        babelHelpers.createClass(PointEnumerator, [{\n            key: 'next',\n            value: function next() {\n                var ret = undefined;\n\n                if (this.seriesIndex < this.seriesCount) {\n                    var _renderer$pointPositi = babelHelpers.slicedToArray(this.renderer.pointPositions[this.seriesIndex][this.categoryIndex], 2);\n\n                    var x = _renderer$pointPositi[0];\n                    var y = _renderer$pointPositi[1];\n\n                    if (this.isHorizontal) {\n                        ;\n\n                        var _ref = [y, x];\n                        x = _ref[0];\n                        y = _ref[1];\n                    }ret = {\n                        firstPoint: this.categoryIndex === 0,\n                        lastPoint: this.categoryIndex + 1 === this.categoryCount,\n                        seriesIndex: this.seriesIndex,\n                        categoryIndex: this.categoryIndex,\n                        series: this.renderer.series[this.seriesIndex],\n                        value: Tayberry$1.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]),\n                        x: x,\n                        y: y,\n                        seriesSelected: this.tb.selectedItem.type === 'plotItem' && !this.tb.options.tooltips.shared && this.tb.selectedItem.series === this.renderer.series[this.seriesIndex],\n                        selected: this.tb.selectedItem.type === 'plotItem' && this.tb.selectedItem.categoryIndex === this.categoryIndex && (this.tb.options.tooltips.shared || this.tb.selectedItem.series === this.renderer.series[this.seriesIndex])\n                    };\n\n                    this.nextValue();\n                }\n                return ret;\n            }\n        }]);\n        return PointEnumerator;\n    }(BySeriesEnumerator);\n\n    var Legend = function () {\n        /**\r\n         *\r\n         * @param tayberry {Tayberry}\r\n         */\n\n        function Legend(tayberry) {\n            babelHelpers.classCallCheck(this, Legend);\n\n            this.tb = tayberry;\n            this.xPos = null;\n            this.yPos = null;\n            this.rowIndices = null;\n            this.calculatedSize = null;\n            this.canvas = tayberry.labelsCanvas;\n            this.ctx = tayberry.labelsCtx;\n            this.font = null;\n        }\n\n        babelHelpers.createClass(Legend, [{\n            key: 'adjustSize',\n            value: function adjustSize(plotArea, reset) {\n                var ret = false;\n                if (reset) {\n                    this.calculatedSize = 0;\n                }\n                if (this.tb.options.legend.enabled) {\n                    var smallPadding = this.tb.mapLogicalXUnit(this.tb.options.elementSmallPadding);\n                    var largePadding = this.tb.mapLogicalXUnit(this.tb.options.elementLargePadding);\n                    var indicatorSize = this.tb.mapLogicalXUnit(this.tb.options.legend.indicatorSize);\n                    var textWidths = this.getItemTextWidths();\n                    var maxLegendItemWidth = reduce(textWidths, Math.max) + indicatorSize + smallPadding;\n                    var isVertical = this.tb.options.legend.placement === 'left' || this.tb.options.legend.placement === 'right';\n                    var isHorizontal = !isVertical;\n\n                    var rowIndices = [];\n                    var numItems = textWidths.length;\n                    var plotWidth = plotArea.width;\n\n                    if (isHorizontal) {\n                        var cumWidth = 0;\n                        for (var i = 0; i < numItems; i++) {\n                            cumWidth += textWidths[i] + indicatorSize + smallPadding;\n                            if (i + 1 == numItems) {\n                                rowIndices.push(i + 1);\n                            } else if (cumWidth > plotWidth) {\n                                rowIndices.push(i);\n                                cumWidth = 0;\n                            } else {\n                                cumWidth += largePadding;\n                            }\n                        }\n                    } else {\n                        for (var i = 0; i < numItems; i++) {\n                            rowIndices.push(i + 1);\n                        }\n                    }\n\n                    this.rowIndices = rowIndices;\n                    var numRows = rowIndices.length;\n                    var height = indicatorSize * numRows + (numRows - 1) * smallPadding;\n\n                    var calculatedSize = 0;\n\n                    switch (this.tb.options.legend.placement) {\n                        case 'bottom':\n                            calculatedSize = largePadding + indicatorSize * numRows;\n                            plotArea.bottom -= calculatedSize - this.calculatedSize;\n                            this.yPos = this.canvas.height - indicatorSize * numRows;\n                            break;\n                        case 'top':\n                            calculatedSize = largePadding + indicatorSize * numRows;\n                            this.yPos = plotArea.top;\n                            plotArea.top += calculatedSize - this.calculatedSize;\n                            break;\n                        case 'left':\n                            calculatedSize = maxLegendItemWidth + largePadding;\n                            this.xPos = 0;\n                            this.yPos = plotArea.bottom - plotArea.height / 2 - height / 2;\n                            plotArea.left += calculatedSize - this.calculatedSize;\n                            break;\n                        case 'right':\n                            calculatedSize = maxLegendItemWidth + largePadding;\n                            plotArea.right -= calculatedSize - this.calculatedSize;\n                            this.xPos = plotArea.right + largePadding;\n                            this.yPos = plotArea.bottom - plotArea.height / 2 - height / 2;\n                            break;\n                    }\n\n                    ret = this.calculatedSize !== calculatedSize;\n                    this.calculatedSize = calculatedSize;\n                }\n                return ret;\n            }\n        }, {\n            key: 'updateFonts',\n            value: function updateFonts() {\n                this.font = this.tb.createFontString(this.tb.options.legend.font);\n            }\n        }, {\n            key: 'draw',\n            value: function draw() {\n                if (this.tb.options.legend.enabled) {\n                    var legendMetrics = this.getMeasurements();\n                    this.ctx.save();\n                    this.ctx.font = this.font;\n\n                    for (var index = 0; index < legendMetrics.items.length; index++) {\n                        var item = legendMetrics.items[index];\n                        var series = item.series;\n                        var highlighted = this.tb.selectedItem.type === 'legend' && this.tb.selectedItem.data.series === series;\n                        series.renderer.drawLegendIndicator(this.ctx, series, item.indicatorRect, highlighted);\n                        this.ctx.textBaseline = 'middle';\n                        this.ctx.fillStyle = this.tb.options.legend.font.colour;\n                        if (!(series.visible & visibilityState.visible)) this.ctx.fillStyle = new Colour(this.ctx.fillStyle).multiplyAlpha(this.tb.options.legend.hiddenAlphaMultiplier).toString();\n                        this.ctx.fillText(series.name, item.textX, item.textY);\n                    }\n                    this.ctx.restore();\n                }\n            }\n        }, {\n            key: 'hitTest',\n            value: function hitTest(x, y) {\n                var ret = {\n                    found: false,\n                    type: 'legend'\n                };\n                var legendMetrics = this.getMeasurements();\n                if (legendMetrics.rect.containsPoint(x, y)) {\n                    for (var index = 0; index < legendMetrics.items.length; index++) {\n                        var item = legendMetrics.items[index];\n                        if (item.rect.containsPoint(x, y)) {\n                            assign(ret, [{ found: true, normalisedDistance: -5, data: item }]);\n                            break;\n                        }\n                    }\n                }\n                return ret;\n            }\n        }, {\n            key: 'getItemTextWidths',\n            value: function getItemTextWidths() {\n                var ret = [];\n                for (var index = 0; index < this.tb.options.series.length; index++) {\n                    var series = this.tb.options.series[index];\n                    var width = 0;\n                    if (series.name) {\n                        width = Math.max(this.tb.getTextWidth(series.name, this.font));\n                    }\n                    ret.push(width);\n                }\n                return ret;\n            }\n        }, {\n            key: 'getMeasurements',\n            value: function getMeasurements() {\n                var ret = {\n                    rect: new Rect(0),\n                    items: []\n                };\n                if (this.tb.options.legend.enabled) {\n                    var smallPadding = this.tb.mapLogicalXUnit(this.tb.options.elementSmallPadding);\n                    var largePadding = this.tb.mapLogicalXUnit(this.tb.options.elementLargePadding);\n                    var indicatorSize = this.tb.mapLogicalXUnit(this.tb.options.legend.indicatorSize);\n                    var isVertical = this.tb.options.legend.placement === 'left' || this.tb.options.legend.placement === 'right';\n                    var isHorizontal = !isVertical;\n                    var newLineIndices = this.rowIndices;\n\n                    var lineWidths = [];\n\n                    var lineStart = 0;\n                    for (var lineIndex = 0; lineIndex < newLineIndices.length; lineIndex++) {\n                        var lineEnd = newLineIndices[lineIndex];\n                        var lineWidth = 0;\n\n                        for (var index = lineStart; index < lineEnd; index++) {\n                            var series = this.tb.options.series[index];\n                            if (index > newLineIndices[lineIndex]) {\n                                ++lineIndex;\n                            }\n                            var textWidth = 0;\n\n                            if (series.name) {\n                                textWidth = this.tb.getTextWidth(series.name, this.font);\n                                lineWidth += textWidth + indicatorSize + smallPadding;\n                                if (index + 1 < lineEnd) lineWidth += largePadding;\n                                ret.items.push({ textWidth: textWidth, series: series });\n                            } else {\n                                ret.items.push({ textWidth: 0, series: series });\n                            }\n                        }\n                        lineStart = lineEnd;\n                        lineWidths.push(lineWidth);\n                    }\n\n                    lineStart = 0;\n                    for (var lineIndex = 0; lineIndex < newLineIndices.length; lineIndex++) {\n                        var lineEnd = newLineIndices[lineIndex];\n                        var lineWidth = lineWidths[lineIndex];\n                        var x = isHorizontal ? this.tb.plotArea.left + this.tb.plotArea.width / 2 - lineWidth / 2 : this.xPos;\n                        var y = this.yPos + (indicatorSize + smallPadding) * lineIndex;\n\n                        if (lineIndex === 0) {\n                            ret.rect.left = x;\n                            ret.rect.right = x;\n                            ret.rect.top = y;\n                        }\n\n                        for (var index = lineStart; index < lineEnd; index++) {\n                            var item = ret.items[index];\n\n                            if (item.textWidth > 0) {\n                                item.rect = new Rect(x, y, x + indicatorSize + smallPadding + item.textWidth, y + indicatorSize);\n                                item.indicatorRect = new Rect(x, y, x + indicatorSize, y + indicatorSize);\n                                item.textX = x + indicatorSize + smallPadding;\n                                item.textY = y + indicatorSize / 2;\n\n                                ret.rect.right = Math.max(ret.rect.right, item.rect.right);\n\n                                if (isHorizontal) {\n                                    x += ret.items[index].textWidth + largePadding;\n                                    x += indicatorSize + smallPadding;\n                                }\n                            } else {\n                                item.rect = new Rect(0);\n                                item.indicatorRect = new Rect(0);\n                                item.textX = 0;\n                                item.textY = 0;\n                            }\n                        }\n                        lineStart = lineEnd;\n                        if (lineIndex + 1 === newLineIndices.length) {\n                            ret.rect.bottom = y + indicatorSize;\n                        }\n                    }\n                }\n                return ret;\n            }\n        }]);\n        return Legend;\n    }();\n\n    var currentAutoColourIndex = 0;\n\n    Tayberry$1.getAutoColour = function () {\n        var ret = Tayberry$1.defaultColours[currentAutoColourIndex % Tayberry$1.defaultColours.length];\n        currentAutoColourIndex++;\n        return ret;\n    };\n\n    Tayberry$1.getDataValue = function (dataPoint) {\n        var ret = undefined;\n        if (Array.isArray(dataPoint)) {\n            ret = dataPoint[1];\n        } else {\n            ret = dataPoint;\n        }\n        return ret;\n    };\n\n    Tayberry$1.getDataXValue = function (data, index) {\n        var ret = undefined;\n        if (Array.isArray(data[index])) {\n            ret = data[index][0];\n        } else {\n            ret = index;\n        }\n        return ret;\n    };\n\n    Tayberry$1.setDataValue = function (data, index, newValue) {\n        if (Array.isArray(data[index])) {\n            data[index][1] = newValue;\n        } else {\n            data[index] = newValue;\n        }\n    };\n\n    Tayberry$1.prototype.createCanvas = function () {\n        var ret = document.createElement('canvas');\n        // IE11 hack-fix - clientWidth sometimes incorrect on first access\n        ret.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\n        ret.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\n        ret.style.height = Math.floor(this.containerElement.clientHeight) + 'px';\n        ret.style.position = 'absolute';\n        this.containerElement.appendChild(ret);\n        return ret;\n    };\n\n    Tayberry$1.prototype.create = function (containerElement) {\n        if (typeof containerElement == 'string') {\n            this.containerElement = document.getElementById(containerElement);\n        } else {\n            this.containerElement = containerElement;\n        }\n        this.labelsCanvas = this.createCanvas();\n        this.labelsCtx = this.labelsCanvas.getContext('2d');\n        this.plotCanvas = this.createCanvas();\n        this.plotCtx = this.plotCanvas.getContext('2d');\n        this.options = {};\n        this.yAxes = null;\n        this.xAxes = null;\n        this.initialise();\n    };\n\n    Tayberry$1.prototype.destroy = function () {\n        this.labelsCanvas.parentNode.removeChild(this.labelsCanvas);\n        this.tooltipElement.parentNode.removeChild(this.tooltipElement);\n        this.options = {};\n        this.plotCanvas.removeEventListener('click', this.onClickReal);\n        this.plotCanvas.removeEventListener('mousemove', this.onMouseMoveReal);\n        this.plotCanvas.removeEventListener('mouseleave', this.onMouseLeaveReal);\n        // this.plotCanvas.removeEventListener('touchstart', this.onTouchStartReal);\n        window.removeEventListener('resize', this.onWindowResizeReal);\n    };\n\n    Tayberry$1.prototype.initialise = function () {\n        this.scaleFactor = window.devicePixelRatio || 1.0;\n        this.labelsCanvas.width = Math.round(this.labelsCanvas.clientWidth * this.scaleFactor);\n        this.labelsCanvas.height = Math.round(this.labelsCanvas.clientHeight * this.scaleFactor);\n        this.plotCanvas.width = this.labelsCanvas.width;\n        this.plotCanvas.height = this.labelsCanvas.height;\n        this.scaleFactorX = this.labelsCanvas.width / this.labelsCanvas.clientWidth;\n        this.scaleFactorY = this.labelsCanvas.height / this.labelsCanvas.clientHeight;\n        this.selectedItem = {};\n        this.plotArea = null;\n    };\n\n    Tayberry$1.prototype.getFontHeight = function (font, forDom) {\n        var ret = font.size;\n        if (font.autoScale) ret *= Math.pow(this.labelsCanvas.width / 800, 0.25);\n        if (!forDom) ret = this.mapLogicalYUnit(ret);\n        return ret;\n    };\n\n    Tayberry$1.prototype.createFontString = function (font, forDom) {\n        return (font.style ? font.style + ' ' : '') + this.getFontHeight(font, forDom).toFixed(1) + 'px ' + font.face;\n    };\n\n    Tayberry$1.prototype.updateFonts = function () {\n        //this.labelsCtx.font = this.createFontString(this.options.font);\n        this.titleFont = this.createFontString(this.options.title.font);\n        this.labelFont = this.createFontString(this.options.labels.font);\n        this.legend.updateFonts();\n        this.yAxes.map(function (e) {\n            return e.updateFonts();\n        });\n        this.xAxes.map(function (e) {\n            return e.updateFonts();\n        });\n    };\n\n    Tayberry$1.prototype.setOptions = function (options) {\n        var optionOverrides = [this.defaultOptions()];\n        if (!options.presets) {\n            options.presets = ['default'];\n        }\n        if (options.presets) {\n            for (var index = 0; index < options.presets.length; index++) {\n                optionOverrides.push(Tayberry$1.presets[options.presets[index]]);\n            }\n        }\n        optionOverrides.push(options);\n        this.options = deepAssign({}, optionOverrides);\n        this.options.title.font = deepAssign({}, [this.options.font, this.options.title.font]);\n        this.options.tooltips.font = deepAssign({}, [this.options.font, this.options.tooltips.font]);\n        this.options.labels.font = deepAssign({}, [this.options.font, this.options.labels.font]);\n        this.options.legend.font = deepAssign({}, [this.options.font, this.options.legend.font]);\n        this.options.allAxes.font = deepAssign({}, [this.options.font, this.options.allAxes.font]);\n        this.options.allAxes.title.font = deepAssign({}, [this.options.font, this.options.allAxes.title.font]);\n        if (!Array.isArray(this.options.yAxis)) this.options.yAxis = [this.options.yAxis || {}];\n        if (!Array.isArray(this.options.xAxis)) this.options.xAxis = [this.options.xAxis || {}];\n        for (var i = 0; i < this.options.yAxis.length; i++) {\n            this.options.yAxis[i] = deepAssign({}, [i === 0 ? Tayberry$1.defaultPrimaryYAxis : Tayberry$1.defaultSecondaryYAxis, this.options.allAxes, this.options.yAxis[i]]);\n        }\n        for (var i = 0; i < this.options.xAxis.length; i++) {\n            this.options.xAxis[i] = deepAssign({}, [Tayberry$1.defaultXAxis, this.options.allAxes, this.options.xAxis[i]]);\n        }\n        for (var i = 0; i < this.options.series.length; i++) {\n            this.options.series[i] = deepAssign({}, [Tayberry$1.defaultSeries, this.options.series[i]]);\n        }\n\n        this.yAxes = [];\n        this.xAxes = [];\n        for (var i = 0; i < this.options.xAxis.length; i++) {\n            this.xAxes.push(Axis.create(this, this.options.xAxis[i], i, 'x', this.options.swapAxes));\n        }\n        for (var i = 0; i < this.options.yAxis.length; i++) {\n            this.yAxes.push(Axis.create(this, this.options.yAxis[i], i, 'y', this.options.swapAxes));\n        }\n        this.legend = new Legend(this);\n        this.updateFonts();\n        this.createRenderers();\n        this.calculatePlotArea();\n        this.callbacks['onInit'].forEach(function (func) {\n            return func();\n        });\n        this.plotCanvas.addEventListener('click', this.onClickReal = this.onClick.bind(this));\n        this.plotCanvas.addEventListener('mousemove', this.onMouseMoveReal = this.onMouseMove.bind(this));\n        this.plotCanvas.addEventListener('mouseleave', this.onMouseLeaveReal = this.onMouseLeave.bind(this));\n        //this.plotCanvas.addEventListener('touchstart', this.onTouchStartReal = this.onTouchStart.bind(this));\n        window.addEventListener('resize', this.onWindowResizeReal = throttle(this.onWindowResize, 50).bind(this));\n    };\n\n    Tayberry$1.calculateHighlightColour = function (colour) {\n        var newColour = new Colour(colour);\n        return newColour.increaseBy(30 * (newColour.sum >= 180 * 3 ? -1 : 1)).toString();\n    };\n\n    Tayberry$1.calculateGlowColour = function (highlightColour) {\n        var newColour = new Colour(highlightColour);\n        newColour.a = 0.4;\n        return newColour.toString();\n    };\n\n    Tayberry$1.prototype.createRenderers = function () {\n        var series = undefined,\n            groupedSeries = { 'bar': [], 'line': [] };\n        if (!Array.isArray(this.options.series)) {\n            series = [this.options.series];\n        } else {\n            series = this.options.series;\n        }\n\n        for (var i = 0; i < series.length; i++) {\n            var curSeries = series[i];\n            curSeries.index = i;\n            curSeries.colour = curSeries.colour || Tayberry$1.getAutoColour();\n            curSeries.highlightColour = curSeries.highlightColour || Tayberry$1.calculateHighlightColour(curSeries.colour);\n            curSeries.glowColour = curSeries.glowColour || Tayberry$1.calculateGlowColour(curSeries.highlightColour);\n            curSeries.rState = {\n                colour: curSeries.colour,\n                highlightColour: curSeries.highlightColour,\n                glowColour: curSeries.glowColour\n            };\n            curSeries.xAxis = this.xAxes[curSeries.xAxisIndex || 0];\n            curSeries.yAxis = this.yAxes[curSeries.yAxisIndex || 0];\n            curSeries.plotType = curSeries.plotType || this.options.plotType;\n            if (groupedSeries.hasOwnProperty(curSeries.plotType)) {\n                groupedSeries[curSeries.plotType].push(curSeries);\n            }\n        }\n        if (groupedSeries['bar'].length) {\n            this.renderers.push(new BarRenderer(this.plotCtx, this, groupedSeries['bar']));\n        }\n        if (groupedSeries['line'].length) {\n            this.renderers.push(new LineRenderer(this.plotCtx, this, groupedSeries['line']));\n        }\n    };\n\n    Tayberry$1.prototype.getDataMinMax = function (axis) {\n        var minNormal, maxNormal, minStacked, maxStacked;\n        if (this.options.barPlot.mode === 'stacked') {\n            var seriesPositiveTotals = [];\n            var seriesNegativeTotals = [];\n            var barSeries = this.options.series.filter(function (series) {\n                return series.plotType === 'bar' && series.yAxis === axis;\n            });\n            if (barSeries.length) {\n                for (var categoryIndex = 0; categoryIndex < barSeries[0].data.length; categoryIndex++) {\n                    seriesPositiveTotals[categoryIndex] = 0;\n                    seriesNegativeTotals[categoryIndex] = 0;\n                    for (var seriesIndex = 0; seriesIndex < barSeries.length; seriesIndex++) {\n                        var value = Tayberry$1.getDataValue(barSeries[seriesIndex].data[categoryIndex]);\n                        if (!isMissingValue(value)) {\n                            if (value < 0) {\n                                seriesNegativeTotals[categoryIndex] += value;\n                            } else {\n                                seriesPositiveTotals[categoryIndex] += value;\n                            }\n                        }\n                    }\n                }\n            }\n            minStacked = Math.min(0, reduce(seriesNegativeTotals, Math.min, undefined, true));\n            maxStacked = Math.max(reduce(seriesPositiveTotals, Math.max, undefined, true), 0);\n        }\n        {\n            var seriesMinima = [];\n            var seriesMaxima = [];\n            for (var index = 0; index < this.options.series.length; index++) {\n                var series = this.options.series[index];\n                if (series.yAxis === axis && (series.plotType !== 'bar' || this.options.barPlot.mode !== 'stacked')) {\n                    seriesMinima.push(reduce(series.data, Math.min, Tayberry$1.getDataValue, true));\n                    seriesMaxima.push(reduce(series.data, Math.max, Tayberry$1.getDataValue, true));\n                }\n            }\n            minNormal = reduce(seriesMinima, Math.min, undefined, true);\n            maxNormal = reduce(seriesMaxima, Math.max, undefined, true);\n        }\n        var min = reduce([minNormal, minStacked], Math.min, undefined, true);\n        var max = reduce([maxNormal, maxStacked], Math.max, undefined, true);\n        return [min, max];\n    };\n\n    Tayberry$1.prototype.getDataXMinMax = function (axis) {\n        var min, max;\n        var seriesMinima = [];\n        var seriesMaxima = [];\n        for (var index = 0; index < this.options.series.length; index++) {\n            var series = this.options.series[index];\n            if (series.xAxis === axis) {\n                seriesMinima.push(reduce(series.data, Math.min, Tayberry$1.getDataXValue, true));\n                seriesMaxima.push(reduce(series.data, Math.max, Tayberry$1.getDataXValue, true));\n            }\n        }\n        min = reduce(seriesMinima, Math.min, undefined, true);\n        max = reduce(seriesMaxima, Math.max, undefined, true);\n        return [min, max];\n    };\n\n    Tayberry$1.prototype.createTooltip = function () {\n        if (this.tooltipElement) {\n            this.tooltipElement.parentNode.removeChild(this.tooltipElement);\n            this.tooltipElement = null;\n        }\n        this.tooltipElement = document.createElement('div');\n        this.tooltipElement.className = 'tayberry-tooltip';\n        this.tooltipElement.style.position = 'absolute';\n        this.tooltipElement.style.left = '0px';\n        this.tooltipElement.style.top = '0px';\n        this.tooltipElement.style.zIndex = '99999';\n        this.tooltipElement.style.font = this.createFontString(this.options.tooltips.font, true);\n        this.tooltipElement.style.borderRadius = '3px';\n        this.tooltipElement.style.backgroundColor = 'white';\n        this.tooltipElement.style.border = '2px solid #bbb';\n        this.tooltipElement.style.padding = '0.15em 0.4em';\n        this.tooltipElement.style.display = 'none';\n        this.tooltipElement.innerHTML = '';\n        document.body.appendChild(this.tooltipElement);\n        this.tooltipElement.addEventListener('mousemove', this.onMouseMove.bind(this));\n        this.tooltipElement.addEventListener('mouseleave', this.onMouseLeave.bind(this));\n    };\n\n    Tayberry$1.prototype.getTextWidth = function (text, fontString) {\n        var ret = undefined;\n        if (fontString) {\n            this.labelsCtx.save();\n            this.labelsCtx.font = fontString;\n        }\n        ret = this.labelsCtx.measureText(text).width;\n        if (fontString) {\n            this.labelsCtx.restore();\n        }\n        return ret;\n    };\n\n    Tayberry$1.prototype.getMultilineTextHeight = function (fontString, maxWidth, text) {\n        var ret = undefined;\n        if (fontString) {\n            this.labelsCtx.save();\n            this.labelsCtx.font = fontString;\n        }\n        ret = this.splitMultilineText(maxWidth, text).length;\n        if (fontString) {\n            this.labelsCtx.restore();\n        }\n        return ret;\n    };\n\n    Tayberry$1.prototype.splitMultilineText = function (maxWidth, text) {\n        var lines = [];\n        var lineWidth = 0;\n        var lineText = '';\n        var spaceWidth = this.labelsCtx.measureText(' ').width;\n        for (var i = 0; i < text.length;) {\n            var wordStart = i;\n            while (i < text.length && text[i] !== ' ' && text[i] !== '\\r' && text[i] !== '\\n') {\n                i++;\n            }var wordEnd = i;\n            while (i < text.length && (text[i] === ' ' || text[i] === '\\r' || text[i] === '\\n')) {\n                i++;\n            }if (wordEnd > wordStart) {\n                var word = text.substring(wordStart, wordEnd);\n                var wordWidth = this.labelsCtx.measureText(word).width;\n                if (lineWidth + wordWidth > maxWidth) {\n                    if (!lineWidth) {\n                        lineText = word;\n                    }\n                    lines.push(lineText);\n                    if (lineWidth) {\n                        lineWidth = 0;\n                        lineText = word;\n                    }\n                } else {\n                    lineText += (lineText ? ' ' : '') + word;\n                    lineWidth += wordWidth + spaceWidth;\n                }\n            }\n        }\n        if (lineText) {\n            lines.push(lineText);\n        }\n        return lines;\n    };\n\n    Tayberry$1.prototype.drawTextMultiline = function (lineHeight, x, y, maxWidth, text) {\n        var lines = this.splitMultilineText(maxWidth, text);\n\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i];\n            this.labelsCtx.fillText(line, x, y + lineHeight * i);\n        }\n    };\n\n    Tayberry$1.prototype.render = function () {\n        this.drawLabelLayer();\n        this.createTooltip();\n        if (this.options.animations.enabled) {\n            for (var index = 0; index < this.options.series.length; index++) {\n                var series = this.options.series[index];\n                this.setSeriesVisibility(series, true, 'height');\n            }\n        } else {\n            this.drawPlotLayer();\n        }\n    };\n\n    Tayberry$1.prototype.clear = function () {\n        var plot = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n        var labels = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n        if (plot) this.plotCtx.clearRect(0, 0, this.plotCanvas.width, this.plotCanvas.height);\n        if (labels) this.labelsCtx.clearRect(0, 0, this.labelsCanvas.width, this.labelsCanvas.height);\n    };\n\n    Tayberry$1.prototype.drawBackground = function () {\n        if (this.options.plotBackgroundColour) {\n            this.labelsCtx.save();\n            this.labelsCtx.fillStyle = this.options.plotBackgroundColour;\n            this.labelsCtx.fillRect(this.plotArea.left, this.plotArea.top, this.plotArea.width, this.plotArea.height);\n            this.labelsCtx.restore();\n        }\n    };\n\n    Tayberry$1.prototype.drawTitle = function () {\n        if (this.options.title.text) {\n            var x = this.labelsCanvas.width / 2,\n                y = 0;\n            this.labelsCtx.save();\n            this.labelsCtx.textAlign = 'center';\n            this.labelsCtx.textBaseline = 'top';\n            this.labelsCtx.font = this.titleFont;\n            this.labelsCtx.fillStyle = this.options.title.font.colour;\n            this.drawTextMultiline(this.getFontHeight(this.options.title.font), x, y, this.labelsCanvas.width, this.options.title.text);\n            // this.labelsCtx.fillText(this.options.title.text, x, y);\n            this.labelsCtx.restore();\n        }\n    };\n\n    Tayberry$1.prototype.drawPlotLayer = function () {\n        for (var i = 0; i < this.renderers.length; i++) {\n            this.renderers[i].drawPlot();\n        }\n        for (var i = 0; i < this.renderers.length; i++) {\n            this.renderers[i].drawLabels();\n        }\n    };\n\n    Tayberry$1.prototype.drawLine = function (x1, y1, x2, y2, colour) {\n        var ctx = arguments.length <= 5 || arguments[5] === undefined ? this.labelsCtx : arguments[5];\n\n        ctx.save();\n        if (colour) {\n            ctx.strokeStyle = colour;\n        }\n        ctx.beginPath();\n        ctx.moveTo(x1 + 0.5, y1 + 0.5);\n        ctx.lineTo(x2 + 0.5, y2 + 0.5);\n        ctx.stroke();\n        ctx.restore();\n    };\n\n    Tayberry$1.prototype.drawLabelLayer = function () {\n        this.drawBackground();\n        this.drawTitle();\n        var offsetRect = new Rect(0);\n        this.xAxes.map(function (e) {\n            return e.draw(offsetRect);\n        });\n        this.yAxes.map(function (e) {\n            return e.draw(offsetRect);\n        });\n        this.legend.draw();\n    };\n\n    Tayberry$1.prototype.redraw = function (plotOnly) {\n        this.clear(true, !plotOnly);\n        if (!plotOnly) {\n            this.drawLabelLayer();\n        }\n        this.drawPlotLayer();\n    };\n\n    Tayberry$1.prototype.registerCallback = function (eventName, func) {\n        this.callbacks[eventName].push(func);\n    };\n\n    Tayberry$1.prototype.onMouseLeave = function (event) {\n        if (event.currentTarget == this.plotCanvas && event.relatedTarget !== this.tooltipElement || event.currentTarget == this.tooltipElement && event.relatedTarget !== this.plotCanvas) {\n            this.selectedItem = {};\n            this.tooltipElement.style.display = 'none';\n            this.redraw();\n        }\n    };\n\n    Tayberry$1.prototype.handleMouseMove = function (clientX, clientY) {\n        var boundingRect = new Rect(this.plotCanvas.getBoundingClientRect());\n        var ret = false;\n        var tooltipDisplayStyleSet = false;\n        if (boundingRect.containsPoint(clientX, clientY)) {\n            var x = clientX - boundingRect.left;\n            var y = clientY - boundingRect.top;\n\n            var hitTestResult = this.hitTest(this.mapLogicalXUnit(x), this.mapLogicalYUnit(y));\n            if (hitTestResult.found) {\n                if (hitTestResult.type === 'legend') {\n                    this.selectedItem = hitTestResult;\n                    ret = true;\n                } else if (hitTestResult.type === 'plotItem') {\n                    var tooltipHtml = '';\n                    var aboveZero = hitTestResult.rect.top < hitTestResult.rect.bottom;\n                    this.tooltipElement.style.display = 'block';\n                    tooltipDisplayStyleSet = true;\n                    if (this.options.tooltips.shared) {\n                        var category = this.xAxes[0].getCategoryLabel(hitTestResult.categoryIndex, this.categoryCount, hitTestResult.isXRange);\n                        tooltipHtml += formatString(this.options.tooltips.headerTemplate, { category: category }, true);\n                        for (var index = 0; index < this.seriesCount; index++) {\n                            var series = this.options.series[index];\n                            var value = Tayberry$1.getDataValue(series.data[hitTestResult.categoryIndex]);\n                            tooltipHtml += formatString(this.options.tooltips.valueTemplate, {\n                                value: series.yAxis.options.labelFormatter(value),\n                                name: series.name,\n                                colour: series.colour\n                            }, true);\n                        }\n                    } else {\n                        var series = hitTestResult.series;\n                        var value = hitTestResult.value;\n                        var category = series.xAxis.getCategoryLabel(hitTestResult.categoryIndex, this.categoryCount, hitTestResult.isXRange);\n                        tooltipHtml += formatString(this.options.tooltips.headerTemplate, { category: category }, true);\n                        tooltipHtml += formatString(this.options.tooltips.valueTemplate, {\n                            value: series.yAxis.options.labelFormatter(value),\n                            name: series.name,\n                            colour: series.colour\n                        }, true);\n                    }\n                    tooltipHtml += this.options.tooltips.footerTemplate;\n                    this.tooltipElement.innerHTML = tooltipHtml;\n                    var tooltipRect = this.tooltipElement.getBoundingClientRect();\n                    if (!this.options.tooltips.shared) {\n                        this.tooltipElement.style.borderColor = hitTestResult.series.colour;\n                    }\n                    this.tooltipElement.style.left = window.pageXOffset + boundingRect.left + this.mapScreenUnit(hitTestResult.rect.width) / 2 + hitTestResult.rect.left / this.scaleFactor - tooltipRect.width / 2 + 'px';\n                    this.tooltipElement.style.top = window.pageYOffset + boundingRect.top + this.mapScreenUnit(hitTestResult.rect.top) - tooltipRect.height * (aboveZero ? 1 : 0) - this.options.elementSmallPadding * (aboveZero ? 1 : -1) + 'px';\n                    this.selectedItem = hitTestResult;\n                    ret = true;\n                }\n            }\n        }\n        if (!tooltipDisplayStyleSet) this.tooltipElement.style.display = 'none';\n        return ret;\n    };\n\n    //Tayberry.prototype.onTouchStart = function (event) {\n    //    for (let index = 0; index < event.targetTouches.length; index++) {\n    //        let touch = event.targetTouches[index];\n    //        if (this.handleMouseMove(touch.clientX, touch.clientY)) {\n    //            // event.preventDefault();\n    //            this.redraw();\n    //            break;\n    //        }\n    //    }\n    //};\n\n    Tayberry$1.prototype.onClick = function (event) {\n        var boundingRect = new Rect(this.plotCanvas.getBoundingClientRect());\n        // Why is event.buttons always 0?\n        if (event.button === 0 && boundingRect.containsPoint(event.clientX, event.clientY)) {\n            var x = event.clientX - boundingRect.left;\n            var y = event.clientY - boundingRect.top;\n            var hitTestResult = this.hitTest(this.mapLogicalXUnit(x), this.mapLogicalYUnit(y));\n            if (hitTestResult.found) {\n                if (hitTestResult.type === 'legend') {\n                    var series = hitTestResult.data.series;\n\n                    this.toggleSeriesVisibility(series);\n                    this.clear(false, true);\n                    this.drawLabelLayer();\n                }\n            }\n        }\n    };\n\n    Tayberry$1.prototype.onMouseMove = function (event) {\n        var oldSelectedItem = assign({}, this.selectedItem);\n        if (!this.handleMouseMove(event.clientX, event.clientY)) {\n            this.selectedItem = {};\n        }\n\n        if (oldSelectedItem.type !== this.selectedItem.type || oldSelectedItem.categoryIndex !== this.selectedItem.categoryIndex || oldSelectedItem.series !== this.selectedItem.series) {\n            this.redraw();\n        }\n    };\n\n    Tayberry$1.prototype.onWindowResize = function () {\n        this.tooltipElement.style.display = 'none';\n        this.labelsCanvas.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\n        this.labelsCanvas.style.height = Math.floor(this.containerElement.clientHeight) + 'px';\n        this.plotCanvas.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\n        this.plotCanvas.style.height = Math.floor(this.containerElement.clientHeight) + 'px';\n        this.initialise();\n        this.updateFonts();\n        this.calculatePlotArea();\n        this.createTooltip();\n        this.callbacks['onResize'].forEach(function (func) {\n            return func();\n        });\n        this.redraw();\n    };\n\n    Tayberry$1.prototype.defaultOptions = function () {\n        return {\n            title: {\n                text: '',\n                font: {\n                    size: 20\n                }\n            },\n            font: {\n                colour: '#444',\n                size: 12,\n                face: 'sans-serif',\n                style: '',\n                autoScale: true\n            },\n            allAxes: {\n                font: {},\n                title: {\n                    font: {}\n                }\n            },\n            xAxis: [],\n            yAxis: [],\n            animations: {\n                enabled: true\n            },\n            series: [],\n            backgroundColour: undefined,\n            swapAxes: false,\n            plotType: 'bar',\n            barPlot: {\n                mode: 'normal', //[normal|stacked|overlaid]\n                barPadding: 2,\n                categorySpacing: 0.3\n            },\n            linePlot: {\n                lineWidth: 2,\n                highlightedLineWidth: 4,\n                showMarkers: 'auto',\n                noMarkersThreshold: 100,\n                markerSize: 10,\n                highlightedMarkerSize: 18\n            },\n            elementSmallPadding: 5,\n            elementLargePadding: 10,\n            presets: [],\n            tooltips: {\n                shared: false,\n                headerTemplate: '<strong>{category}</strong><table>',\n                valueTemplate: '<tr><td style=\"padding-right: 0.5em\"><span style=\"color: {colour}\">●</span> {name}</td><td style=\"text-align: right\">{value}</td></tr>',\n                footerTemplate: '</table>',\n                font: {}\n            },\n            legend: {\n                enabled: true,\n                indicatorSize: 15,\n                font: {},\n                hiddenAlphaMultiplier: 0.5,\n                placement: 'bottom'\n            },\n            labels: {\n                enabled: false,\n                verticalAlignment: 'top',\n                verticalPosition: 'outside',\n                font: {}\n            }\n        };\n    };\n\n    Tayberry$1.defaultSeries = {\n        visible: visibilityState.visible\n    };\n\n    Tayberry$1.defaultXAxis = {\n        title: {\n            text: '',\n            font: {}\n        },\n        type: 'categorial',\n        min: null,\n        max: null,\n        tickStep: 40,\n        tickStepValue: null,\n        font: {},\n        categories: [],\n        labelPosition: 'middle', //left|middle|right\n        placement: 'auto',\n        gridLines: {}\n    };\n\n    Tayberry$1.defaultYAxis = {\n        title: {\n            text: '',\n            font: {}\n        },\n        min: undefined,\n        max: undefined,\n        tickStep: 40,\n        tickStepValue: null,\n        font: {},\n        labelFormat: 'number', //[number|percentage|currency],\n        labelFormatter: undefined,\n        labelPrefix: undefined,\n        labelSuffix: undefined,\n        currencySymbol: '£',\n        placement: 'auto',\n        type: 'linear',\n        gridLines: {}\n\n    };\n\n    Tayberry$1.defaultPrimaryYAxis = deepAssign({}, [Tayberry$1.defaultYAxis, {\n        gridLines: {\n            colour: '#ccc'\n        }\n    }]);\n\n    Tayberry$1.defaultSecondaryYAxis = Tayberry$1.defaultYAxis;\n\n    Tayberry$1.presets = {\n        histogram: {\n            barPlot: {\n                mode: 'overlaid',\n                categorySpacing: 0,\n                barPadding: 1\n            }\n        },\n        darkGrid: {\n            allAxes: {\n                gridLines: {\n                    colour: 'rgba(255, 255, 255, 0.6)'\n                }\n            },\n            plotBackgroundColour: '#E5E5E5'\n        }\n    };\n\n    Tayberry$1.defaultColours = ['#6FE87B', //green\n    '#FFAB51', //orange\n    '#51A8FF', //blue\n    '#B651FF', //purple\n    '#FF6051', //red\n    '#636363', //dark grey\n    '#FFE314', //yellow\n    '#A88572', //brown\n    '#B7B7B7' //light grey\n    ];\n\n    Tayberry$1.mapVerticalPosition = function (sign, position) {\n        switch (position) {\n            case \"outside\":\n                return sign > 0 ? \"bottom\" : \"top\";\n            case \"inside\":\n                return sign > 0 ? \"top\" : \"bottom\";\n            default:\n                return \"middle\";\n        }\n    };\n\n    Tayberry$1.prototype.mapLogicalXUnit = function (x) {\n        return this.scaleFactorX * x;\n    };\n\n    Tayberry$1.prototype.mapLogicalYUnit = function (x) {\n        return this.scaleFactorY * x;\n    };\n\n    Tayberry$1.prototype.mapScreenUnit = function (x) {\n        return x / this.scaleFactor;\n    };\n\n    Tayberry$1.prototype.calculatePlotArea = function () {\n        var _this = this;\n\n        var MAX_AXIS_CALC_SIZE_ATTEMPTS = 5;\n\n        this.plotArea = new Rect(0, 0, this.labelsCanvas.width, this.labelsCanvas.height);\n        if (this.options.title.text) {\n            this.plotArea.top += this.mapLogicalYUnit(this.options.elementSmallPadding);\n            this.plotArea.top += this.getFontHeight(this.options.title.font) * this.getMultilineTextHeight(this.titleFont, this.labelsCanvas.width, this.options.title.text);\n        }\n\n        this.legend.adjustSize(this.plotArea, true);\n\n        this.yAxes.map(function (e) {\n            return e.adjustSize(_this.plotArea, true, true);\n        });\n        this.xAxes.map(function (e) {\n            return e.adjustSize(_this.plotArea, true, true);\n        });\n\n        for (var i = 0; i < MAX_AXIS_CALC_SIZE_ATTEMPTS; i++) {\n            this.yAxes.map(function (e) {\n                return e.calculateExtent();\n            });\n            this.xAxes.map(function (e) {\n                return e.calculateExtent();\n            });\n            this.yAxes.map(function (e) {\n                return e.updateFormatter();\n            });\n            this.xAxes.map(function (e) {\n                return e.updateFormatter();\n            });\n            if (none(this.yAxes.map(function (e) {\n                return e.adjustSize(_this.plotArea);\n            })) && none(this.xAxes.map(function (e) {\n                return e.adjustSize(_this.plotArea);\n            })) && !this.legend.adjustSize(this.plotArea)) break;\n        }\n        this.plotArea.left = Math.ceil(this.plotArea.left);\n        this.plotArea.top = Math.ceil(this.plotArea.top);\n        this.plotArea.right = Math.floor(this.plotArea.right);\n        this.plotArea.bottom = Math.floor(this.plotArea.bottom);\n    };\n\n    Tayberry$1.prototype.hitTest = function (x, y) {\n        var ret = {\n            found: false\n        };\n        var matches = [];\n        if (this.plotArea.containsPoint(x, y)) {\n            for (var i = 0; i < this.renderers.length; i++) {\n                var hitTestResult = this.renderers[i].hitTest(x, y);\n                if (hitTestResult.found) {\n                    matches.push(hitTestResult);\n                }\n            }\n        }\n        matches.push(this.legend.hitTest(x, y));\n        if (matches.length) {\n            matches.sort(function (a, b) {\n                return !a.found - !b.found || a.normalisedDistance - b.normalisedDistance;\n            });\n            ret = matches[0];\n        }\n        return ret;\n    };\n\n    Tayberry$1.prototype.revokeAnimation = function (series) {\n        for (var index = this.pendingAnimations.length; index; index--) {\n            if (this.pendingAnimations[index - 1].series === series) {\n                this.pendingAnimations.splice(index - 1, 1);\n            }\n        }\n    };\n\n    Tayberry$1.prototype.startAnimation = function (animation) {\n        animation.initialStage = animation.initialStage || 0;\n        var newAnimation = assign({}, [{\n            length: 500 * (1 - animation.initialStage),\n            startTime: typeof performance !== 'undefined' && typeof performance.now !== 'undefined' ? performance.now() : null\n        }, animation]);\n        this.pendingAnimations.push(newAnimation);\n        if (!this.animator) this.animator = requestAnimationFrame(this.onAnimate.bind(this));\n        return newAnimation;\n    };\n\n    Tayberry$1.prototype.onAnimate = function (timestamp) {\n        var elapsed;\n        for (var index = this.pendingAnimations.length - 1; index >= 0; index--) {\n            var animation = this.pendingAnimations[index];\n            if (animation.startTime === null) {\n                animation.startTime = timestamp;\n            }\n            elapsed = timestamp - animation.startTime;\n            if (animation.onFrame) {\n                animation.onFrame(animation.initialStage + Math.min(elapsed / animation.length, 1) * (1 - animation.initialStage));\n            }\n            if (elapsed >= animation.length) {\n                this.pendingAnimations.splice(index, 1);\n                if (animation.onCompletion) {\n                    animation.onCompletion();\n                }\n            }\n        }\n        for (var i = 0; i < this.renderers.length; i++) {\n            this.renderers[i].onAnimationFrame();\n        }\n        this.redraw(true);\n        if (this.pendingAnimations.length) {\n            this.animator = requestAnimationFrame(this.onAnimate.bind(this));\n        } else {\n            this.animator = null;\n        }\n    };\n\n    Tayberry$1.prototype.setSeriesVisibility = function (series, visible, subtype) {\n        series.visible = visible ? visibilityState.visible : visibilityState.hidden;\n        series.visible |= visibilityState.transitioning;\n\n        if (series.animationState) {\n            var newType = visible ? 'show' : 'hide';\n            if (series.animationState.type !== newType) {\n                series.animationState.type = newType;\n                series.animationState.stage = 1 - series.animationState.stage;\n\n                delete series.animationState.animator;\n                this.revokeAnimation(series);\n            }\n        } else {\n            series.animationState = {\n                type: series.visible & visibilityState.visible ? 'show' : 'hide',\n                subtype: subtype,\n                stage: 0\n            };\n        }\n        if (!series.animationState.animator) {\n            series.animationState.animator = this.startAnimation({\n                type: visible ? 'showSeries' : 'hideSeries',\n                series: series,\n                initialStage: series.animationState.stage,\n                onFrame: function onFrame(stage) {\n                    return series.animationState.stage = stage;\n                },\n                onCompletion: function onCompletion() {\n                    series.visible = series.visible & ~visibilityState.transitioning;\n                    delete series.animationState;\n                }\n            });\n        }\n    };\n\n    Tayberry$1.prototype.toggleSeriesVisibility = function (series) {\n        this.setSeriesVisibility(series, !(series.visible & visibilityState.visible));\n    };\n\n    var Tayberry = {\n        /**\r\n         * Creates a Tayberry chart\r\n         *\r\n         * @param element   ID of container div, or HTMLElement\r\n         * @param options   Options object\r\n         */\n        create: function create(element, options) {\n            var chart = new Tayberry$1();\n            chart.create(element);\n            chart.setOptions(options);\n            chart.render();\n        }\n    };\n\n    return Tayberry;\n\n}));\n//# sourceMappingURL=tayberry.js.map\n","'use strict';\r\n\r\nexport function identity(obj) {\r\n    return obj;\r\n}\r\n\r\nexport function isMissingValue(n) {\r\n    return n === null || typeof n === 'undefined' || (isNaN(n) && typeof n === 'number');\r\n}\r\n\r\nexport function coalesce(...vals) {\r\n    for (let i = 0; i < vals.length; i++) {\r\n        if (!isMissingValue(vals[i])) {\r\n            return vals[i];\r\n        }\r\n    }\r\n}\r\n\r\nexport function reduce(array, func, getter, ignoreMissing = false) {\r\n    var ret, i;\r\n    if (array.reduce && !getter && !ignoreMissing) {\r\n        ret = array.reduce(function (a, b) {\r\n            return func(a, b);\r\n        });\r\n    } else {\r\n        let retInitialised = false;\r\n        getter = getter || identity;\r\n        for (i = 0; i < array.length; i++) {\r\n            const value = getter(array[i], i);\r\n            if (!ignoreMissing || !isMissingValue(value)) {\r\n                ret = retInitialised ? func(ret, value) : value;\r\n                retInitialised = true;\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\nexport function sign(n) {\r\n    return n > 0 ? 1 : (n < 0 ? -1 : 0);\r\n}\r\n\r\nvar innerAssign = function (deepAssign, targetObject, sourceObjects) {\r\n    if (!Array.isArray(sourceObjects))\r\n        sourceObjects = [sourceObjects];\r\n    if (!deepAssign && Object.assign) {\r\n        return Object.assign.apply(Object, [targetObject].concat(sourceObjects));\r\n    } else {\r\n        if (targetObject === undefined || targetObject === null) {\r\n            throw new TypeError('Cannot convert first argument to object');\r\n        }\r\n\r\n        var to = Object(targetObject);\r\n        for (let i = 0; i < sourceObjects.length; i++) {\r\n            let currentSourceObject = sourceObjects[i];\r\n            if (currentSourceObject === undefined || currentSourceObject === null) {\r\n                continue;\r\n            }\r\n            currentSourceObject = Object(currentSourceObject);\r\n\r\n            const keysArray = Object.keys(currentSourceObject);\r\n            for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\r\n                const nextKey = keysArray[nextIndex];\r\n                const nextValue = currentSourceObject[nextKey];\r\n                const desc = Object.getOwnPropertyDescriptor(currentSourceObject, nextKey);\r\n                if (desc !== undefined && desc.enumerable) {\r\n                    if (deepAssign && !Array.isArray(nextValue) && typeof nextValue === 'object' && nextValue !== null)\r\n                        to[nextKey] = innerAssign(true, {}, [to[nextKey], nextValue]);\r\n                    else\r\n                        to[nextKey] = nextValue;\r\n                }\r\n            }\r\n        }\r\n        return to;\r\n    }\r\n};\r\n\r\nexport function none(array) {\r\n    return array.every(elem => !elem);\r\n}\r\n\r\nexport function assign(targetObject, sourceObjects) {\r\n    return innerAssign(false, targetObject, sourceObjects);\r\n}\r\n\r\nexport function deepAssign(targetObject, sourceObjects) {\r\n    return innerAssign(true, targetObject, sourceObjects);\r\n}\r\n\r\nexport function formatString(formatString, formatValues, escapeAsHtml) {\r\n    return formatString.replace(/{(\\w+)}/g, function (match, placeholder) {\r\n        const value = formatValues[placeholder];\r\n        return typeof value !== 'undefined' ? (escapeAsHtml ? stringToHtml(value) : value) : match;\r\n    });\r\n}\r\n\r\nexport function locateDecimalPoint(number) {\r\n    return Math.floor(Math.log(number) / Math.log(10));\r\n}\r\n\r\nexport function formatNumberThousands(number, decimalPlaces = 0) {\r\n    var parts = number.toFixed(decimalPlaces).split(\".\");\r\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\r\n    return parts.join(\".\");\r\n}\r\n\r\nexport function createAutoNumberFormatter(scale, prefix = '', suffix = '', precision = 2) {\r\n    let decimalPlaces = locateDecimalPoint(scale);\r\n    decimalPlaces = decimalPlaces < 0 ? -decimalPlaces + precision - 1 : 0;\r\n    return x => prefix + formatNumberThousands(x, decimalPlaces) + suffix;\r\n}\r\n\r\nexport function createFixedNumberFormatter(scale, prefix = '', suffix = '', decimalPlaces = 2) {\r\n    return x => prefix + formatNumberThousands(x, decimalPlaces) + suffix;\r\n}\r\n\r\nexport function createPercentageFormatter(scale, prefix = '', suffix = '%', precision = 2) {\r\n    let decimalPlaces = locateDecimalPoint(scale * 100);\r\n    decimalPlaces = decimalPlaces < precision ? -decimalPlaces + precision - 1 : 0;\r\n    return x => prefix + formatNumberThousands(x * 100, decimalPlaces) + suffix;\r\n}\r\n\r\nexport function stringToHtml(str) {\r\n    var div = document.createElement('div');\r\n    div.appendChild(document.createTextNode(str));\r\n    return div.innerHTML;\r\n}\r\n\r\nexport function throttle(fn, threshold) {\r\n    var last,\r\n        deferTimer;\r\n    return function () {\r\n        var context = this;\r\n\r\n        var now = Date.now(),\r\n            args = arguments;\r\n        if (last && now < last + threshold) {\r\n            clearTimeout(deferTimer);\r\n            deferTimer = setTimeout(function () {\r\n                last = now;\r\n                fn.apply(context, args);\r\n            }, threshold);\r\n        } else {\r\n            last = now;\r\n            fn.apply(context, args);\r\n        }\r\n    }\r\n}\r\n\r\n","export class Tayberry {\r\n    constructor() {\r\n        this.selectedItem = {};\r\n        this.containerElement = null;\r\n        this.labelsCanvas = null;\r\n        this.labelsCtx = null;\r\n        this.options = null;\r\n        this.scaleFactor = null;\r\n        this.titleFont = null;\r\n        this.plotArea = null;\r\n        this.categories = [];\r\n        this.titleFont = null;\r\n        this.labelFont = null;\r\n        this.renderers = [];\r\n        this.onClickReal = null;\r\n        this.onMouseLeaveReal = null;\r\n        this.onMouseMoveReal = null;\r\n        this.onWindowResizeReal = null;\r\n        this.pendingAnimations = [];\r\n        this.legend = null;\r\n        this.callbacks = {\r\n            onResize: [],\r\n            onInit: []\r\n        }\r\n    }\r\n\r\n    get seriesCount() {\r\n        return this.options.series.length;\r\n    }\r\n\r\n    get categoryCount() {\r\n        return this.options.series.length ? this.options.series[0].data.length : 0;\r\n    }\r\n}\r\n\r\n\r\n","'use strict';\r\nimport * as Utils from './helpers/utils.js';\r\n\r\nexport class Axis {\r\n    static create(tayberry, options, index, axisType, xYSwapped) {\r\n        const isHorizontal = (axisType === 'x' && !xYSwapped) || (axisType === 'y' && xYSwapped);\r\n        if (options.type === 'linear')\r\n            return new LinearAxis(tayberry, index, options, axisType, isHorizontal);\r\n        else\r\n            return new CategorialAxis(tayberry, index, options, axisType, isHorizontal);\r\n    }\r\n\r\n    constructor(tayberry, index, options, axisType, isHorizontal) {\r\n        this.tayberry = tayberry;\r\n        this.options = options;\r\n        this.axisType = axisType;\r\n        this.isHorizontal = isHorizontal;\r\n        this.index = index;\r\n        this.tickStep = null;\r\n        this.min = null;\r\n        this.max = null;\r\n        this.tickStart = null;\r\n        this.tickEnd = null;\r\n        this.calculatedSize = 0;\r\n        this.topAdjustment = 0;\r\n        this.rightAdjustment = 0;\r\n        this.titleFont = null;\r\n        this.labelFont = null;\r\n        this.numLabelLines = 1;\r\n\r\n        this.setPlacement();\r\n    }\r\n\r\n    updateFonts() {\r\n        this.labelFont = this.tayberry.createFontString(this.options.font);\r\n        this.titleFont = this.tayberry.createFontString(this.options.title.font);\r\n    }\r\n\r\n    setPlacement() {\r\n        const validAndSpecificPlacements = ['left', 'right', 'top', 'bottom', 'start', 'end'];\r\n        if (validAndSpecificPlacements.indexOf(this.options.placement) === -1) {\r\n            this.options.placement = this.isVertical ^ (this.index > 0) ? 'start' : 'end';\r\n        }\r\n    }\r\n\r\n    get isPlacedAtStart() {\r\n        return this.options.placement === \"left\" || this.options.placement === \"bottom\" || this.options.placement === \"start\";\r\n    }\r\n\r\n    get isYAxis() {\r\n        return this.axisType === 'y';\r\n    }\r\n\r\n    get isVertical() {\r\n        return !this.isHorizontal;\r\n    }\r\n\r\n    maxLabelSize() {\r\n        let tb = this.tayberry;\r\n        let ticks = this.getTicks();\r\n        return Utils.reduce(ticks, Math.max, x => tb.getTextWidth(this.options.labelFormatter(x.value), this.labelFont));\r\n    }\r\n\r\n    mapLogicalXOrYUnit(x) {\r\n        return this.isVertical ? this.tayberry.mapLogicalXUnit(x) : this.tayberry.mapLogicalYUnit(x);\r\n    }\r\n\r\n    mapLogicalYOrXUnit(x) {\r\n        return !this.isVertical ? this.tayberry.mapLogicalXUnit(x) : this.tayberry.mapLogicalYUnit(x);\r\n    }\r\n\r\n    adjustSize(plotArea, fixedOnly, reset) {\r\n        let size = 0,\r\n            tb = this.tayberry,\r\n            ret;\r\n\r\n        const titleFontHeight = tb.getFontHeight(this.options.title.font);\r\n        const fontHeight = tb.getFontHeight(this.options.font);\r\n\r\n        if (reset) {\r\n            this.calculatedSize = 0;\r\n            this.topAdjustment = 0;\r\n            this.rightAdjustment = 0;\r\n            this.numLabelLines = 1;\r\n        }\r\n\r\n        size += this.mapLogicalXOrYUnit(tb.options.elementSmallPadding);\r\n        if (this.options.title.text) {\r\n            size += this.mapLogicalXOrYUnit(tb.options.elementSmallPadding) + titleFontHeight;\r\n        }\r\n\r\n        if (!fixedOnly) {\r\n            let ticks = this.getTicks(false);\r\n            if (this.isVertical) {\r\n                if (ticks.length) {\r\n                    const lastTick = ticks[ticks.length - 1];\r\n                    const lastTickYStart = lastTick.y - fontHeight / 2;\r\n                    if (lastTickYStart < plotArea.top - this.topAdjustment) {\r\n                        const adjustment = plotArea.top - lastTickYStart - this.topAdjustment + 1;\r\n                        plotArea.top += adjustment;\r\n                        this.topAdjustment += adjustment;\r\n                    }\r\n                }\r\n                size += this.maxLabelSize()\r\n            } else {\r\n                {\r\n                    let lastXEnd;\r\n                    for (let i = 0; i < ticks.length; i++) {\r\n                        let tick = ticks[i];\r\n                        const textWidth = tb.getTextWidth(this.options.labelFormatter(tick.value), this.labelFont);\r\n                        const xStart = tick.x - textWidth / 2;\r\n                        const xEnd = tick.x + textWidth / 2;\r\n                        if (typeof lastXEnd !== 'undefined' && xStart <= lastXEnd + 1) {\r\n                            this.numLabelLines = 2;\r\n                            break;\r\n                        }\r\n                        lastXEnd = xEnd;\r\n                    }\r\n                }\r\n                if (ticks.length) {\r\n                    const lastTick = ticks[ticks.length - 1];\r\n                    const textWidth = tb.getTextWidth(this.options.labelFormatter(lastTick.value), this.labelFont);\r\n                    const lastTickXEnd = lastTick.x + textWidth / 2;\r\n                    if (lastTickXEnd >= plotArea.right + this.rightAdjustment) {\r\n                        const adjustment = lastTickXEnd - plotArea.right - this.rightAdjustment + 1;\r\n                        plotArea.right -= adjustment;\r\n                        this.rightAdjustment += adjustment;\r\n                    }\r\n                }\r\n                size += fontHeight * this.numLabelLines;\r\n            }\r\n        }\r\n\r\n        if (this.isPlacedAtStart) {\r\n            if (this.isVertical) {\r\n                plotArea.left += size - this.calculatedSize;\r\n            } else {\r\n                plotArea.top += size - this.calculatedSize;\r\n            }\r\n        } else {\r\n            size *= -1;\r\n            if (this.isVertical) {\r\n                plotArea.right += size - this.calculatedSize;\r\n            } else {\r\n                plotArea.bottom += size - this.calculatedSize;\r\n            }\r\n        }\r\n\r\n        ret = this.calculatedSize !== size;\r\n        this.calculatedSize = size;\r\n\r\n        return ret;\r\n    }\r\n\r\n    calculateExtent() {\r\n    }\r\n\r\n    getCategoryLabel() {\r\n    }\r\n\r\n    draw(offsetRect) {\r\n        this.drawTicksAndLabels(offsetRect);\r\n        this.drawTitle(offsetRect);\r\n    }\r\n\r\n    drawTicksAndLabels(offsetRect) {\r\n        let tb = this.tayberry;\r\n        const labelPadding = this.mapLogicalXOrYUnit(tb.options.elementSmallPadding);\r\n        const labelPaddingX = this.isVertical ? labelPadding * (this.isPlacedAtStart ? -1 : 1) : 0;\r\n        const labelPaddingY = !this.isVertical ? labelPadding * (this.isPlacedAtStart ? -1 : 1) : 0;\r\n        const fontHeight = tb.getFontHeight(this.options.font);\r\n        const xOffset = this.isVertical ? offsetRect[this.startProperty] : 0;\r\n        const yOffset = !this.isVertical ? offsetRect[this.startProperty] : 0;\r\n\r\n        tb.labelsCtx.save();\r\n        tb.labelsCtx.font = this.labelFont;\r\n        tb.labelsCtx.fillStyle = this.options.font.colour;\r\n        tb.labelsCtx.textAlign = this.isVertical ? (this.isPlacedAtStart ? 'right' : 'left') : 'center';\r\n        tb.labelsCtx.textBaseline = this.isVertical ? 'middle' : this.isPlacedAtStart ? 'bottom' : 'top';\r\n\r\n        let lastXEnds = [],\r\n            tickIndex = 0,\r\n            maxWidth = 0;\r\n\r\n        this.enumerateTicks((tick) => {\r\n            let xStart, xEnd;\r\n            const formattedValue = this.options.labelFormatter(tick.value);\r\n            const row = tickIndex % this.numLabelLines;\r\n            const rowOffset = this.isVertical ? 0 : fontHeight * row;\r\n            const textWidth = tb.getTextWidth(formattedValue, this.labelFont);\r\n            if (!this.isVertical) {\r\n                xStart = tick.x - textWidth / 2;\r\n                xEnd = tick.x + textWidth / 2;\r\n            }\r\n\r\n            if (this.isVertical || (typeof lastXEnds[row] === 'undefined' || xStart > lastXEnds[row] + 1) && xStart >= 0 && xEnd < tb.labelsCanvas.width) {\r\n                maxWidth = Math.max(maxWidth, textWidth);\r\n                tb.labelsCtx.fillText(formattedValue, tick.x + labelPaddingX + xOffset, tick.y + labelPaddingY + rowOffset + yOffset);\r\n                lastXEnds[row] = xEnd;\r\n            }\r\n            if (this.options.gridLines.colour)\r\n                tb.drawLine(tick.x1, tick.y1, tick.x2, tick.y2, this.options.gridLines.colour);\r\n            tickIndex++;\r\n        });\r\n\r\n        this.adjustOffsetRect(offsetRect, this.isVertical ? maxWidth + labelPadding : fontHeight + labelPadding);\r\n\r\n        tb.labelsCtx.restore();\r\n    }\r\n\r\n    adjustOffsetRect(offsetRect, displacement) {\r\n        offsetRect[this.startProperty] += this.isPlacedAtStart ? -displacement : displacement;\r\n    }\r\n\r\n    get startProperty() {\r\n        if (this.isVertical)\r\n            return this.isPlacedAtStart ? 'left' : 'right';\r\n        else\r\n            return this.isPlacedAtStart ? 'top' : 'bottom';\r\n    }\r\n\r\n    get endProperty() {\r\n        if (this.isVertical)\r\n            return !this.isPlacedAtStart ? 'left' : 'right';\r\n        else\r\n            return !this.isPlacedAtStart ? 'top' : 'bottom';\r\n    }\r\n\r\n    drawTitle(offsetRect) {\r\n        if (this.options.title.text) {\r\n            let tb = this.tayberry;\r\n            tb.labelsCtx.save();\r\n            tb.labelsCtx.font = this.titleFont;\r\n            tb.labelsCtx.fillStyle = this.options.title.font.colour;\r\n            tb.labelsCtx.textAlign = 'center';\r\n\r\n            const labelPaddingSize = this.mapLogicalXOrYUnit(tb.options.elementSmallPadding);\r\n            const labelPadding = labelPaddingSize * (this.isPlacedAtStart ? -1 : 1);\r\n            const xOffset = this.isVertical ? offsetRect[this.startProperty] : 0;\r\n            const yOffset = !this.isVertical ? offsetRect[this.startProperty] : 0;\r\n            const fontHeight = tb.getFontHeight(this.options.title.font);\r\n\r\n            if (this.isVertical) {\r\n                tb.labelsCtx.textBaseline = 'bottom';\r\n                const x = tb.plotArea[this.startProperty] + xOffset + labelPadding;\r\n                const y = tb.plotArea.yMidpoint + yOffset;\r\n                tb.labelsCtx.translate(x, y);\r\n                tb.labelsCtx.rotate((this.isPlacedAtStart ? -1 : 1)*Math.PI / 2);\r\n                tb.labelsCtx.fillText(this.options.title.text, 0, 0);\r\n            } else {\r\n                tb.labelsCtx.textBaseline = this.isPlacedAtStart ? 'bottom' : 'top';\r\n                const x = tb.plotArea.xMidpoint + xOffset;\r\n                const y = tb.plotArea[this.startProperty] + labelPadding + yOffset;\r\n                //tb.mapLogicalYOrXUnit(tb.options.font.size * 2 + tb.options.elementSmallPadding + tb.options.elementLargePadding)\r\n                tb.labelsCtx.fillText(this.options.title.text, x, y);\r\n            }\r\n            this.adjustOffsetRect(offsetRect, fontHeight + labelPaddingSize);\r\n            tb.labelsCtx.restore();\r\n        }\r\n    }\r\n\r\n    getTicks(visibleOnly = true) {\r\n        let ret = [];\r\n        this.enumerateTicks(function (tick) {\r\n            ret.push(tick)\r\n        }, visibleOnly);\r\n        return ret;\r\n    }\r\n\r\n    getOrigin() {\r\n    }\r\n\r\n    updateFormatter() {\r\n    }\r\n\r\n    get valueOrigin() {\r\n        return this.min <= 0 && 0 <= this.max ? 0 : (this.min > 0 ? this.min : this.max)\r\n    }\r\n}\r\n\r\nclass CategorialAxis extends Axis {\r\n    enumerateTicks(callback) {\r\n        let tb = this.tayberry;\r\n\r\n        const categoryCount = this.options.categories.length;\r\n        let plotArea = tb.plotArea.clone();\r\n        if (this.isVertical)\r\n            plotArea.swapXY();\r\n        const categoryWidth = (plotArea.width / tb.categoryCount);\r\n        let factor = 0.5;\r\n\r\n        if (!this.isVertical) {\r\n            switch (this.options.labelPosition) {\r\n                case 'left':\r\n                    factor = 0;\r\n                    break;\r\n                case 'right':\r\n                    factor = 1;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < categoryCount; i++) {\r\n            const value = this.options.categories[i];\r\n            let y1 = (this.isPlacedAtStart ? plotArea.top : plotArea.bottom);\r\n            let y2 = (!this.isPlacedAtStart ? plotArea.top : plotArea.bottom);\r\n            let x1 = plotArea.left + Math.floor(i * categoryWidth);\r\n            let x2 = x1;\r\n            let x = plotArea.left + Math.floor(i * categoryWidth + categoryWidth * factor);\r\n            let y = y1;\r\n            if (this.isVertical)\r\n                [x1, y1, x2, y2, x, y] = [y1, x1, y2, x2, y, x];\r\n\r\n            callback({\r\n                value: value,\r\n                x1: x1,\r\n                y1: y1,\r\n                x2: x2,\r\n                y2: y2,\r\n                x: x,\r\n                y: y\r\n            });\r\n\r\n        }\r\n    }\r\n\r\n    updateFormatter() {\r\n        if (!this.options.labelFormatter) {\r\n            this.options.labelFormatter = Utils.identity;\r\n        }\r\n    }\r\n\r\n    getCategoryLabel(index) {\r\n        return this.options.labelFormatter(this.options.categories[index]);\r\n    }\r\n\r\n    get plotDisplacement() {\r\n        return this.isVertical ? (-this.tayberry.plotArea.height) : (this.tayberry.plotArea.width);\r\n    }\r\n\r\n    getOrigin() {\r\n        return this.tayberry.plotArea[this.isVertical ? 'bottom' : 'left'];\r\n    }\r\n\r\n    getValueDisplacement(value) {\r\n        let ret = this.getOrigin() + this.plotDisplacement * (value + 0.5) / this.options.categories.length;\r\n        ret = this.isVertical ? Math.floor(ret) : Math.ceil(ret);\r\n        return ret;\r\n    }\r\n\r\n}\r\n\r\nclass LinearAxis extends Axis {\r\n    updateFormatter() {\r\n        if (!this.options.labelFormatter) {\r\n            if (this.options.labelFormat === 'percentage') {\r\n                this.options.labelFormatter = Utils.createPercentageFormatter(this.max - this.min, this.options.labelPrefix, this.options.labelSuffix);\r\n            }\r\n            else if (this.options.labelFormat === 'currency') {\r\n                this.options.labelFormatter = Utils.createFixedNumberFormatter(this.max - this.min, this.options.labelPrefix || this.options.currencySymbol, this.options.labelSuffix);\r\n            }\r\n            else {\r\n                this.options.labelFormatter = Utils.createAutoNumberFormatter(this.max - this.min, this.options.labelPrefix, this.options.labelSuffix);\r\n            }\r\n        }\r\n    }\r\n\r\n    enumerateTicks(callback) {\r\n        let tb = this.tayberry;\r\n\r\n        const start = this.startProperty,\r\n            end = this.endProperty;\r\n\r\n        for (let yValue = this.tickStart; yValue <= this.tickEnd && this.tickStep;) {\r\n            let y = this.getValueDisplacement(yValue);\r\n            if (this.isVertical) {\r\n                if (callback({\r\n                        value: yValue,\r\n                        x1: tb.plotArea[start],\r\n                        y1: y,\r\n                        x2: tb.plotArea[end],\r\n                        y2: y,\r\n                        x: tb.plotArea[start],\r\n                        y: y\r\n\r\n                    }))\r\n                    break;\r\n            } else {\r\n                if (callback({\r\n                        value: yValue,\r\n                        y1: tb.plotArea[start],\r\n                        x1: y,\r\n                        y2: tb.plotArea[end],\r\n                        x2: y,\r\n                        y: tb.plotArea[start],\r\n                        x: y\r\n                    }))\r\n                    break;\r\n            }\r\n            yValue = this.tickStart + Math.round((yValue + this.tickStep - this.tickStart) / this.tickStep) * this.tickStep;\r\n        }\r\n    }\r\n\r\n    static snapScaledValue(scaledStep) {\r\n        if (scaledStep < 1)\r\n            scaledStep = 1;\r\n        else if (scaledStep < 2)\r\n            scaledStep = 2;\r\n        else if (scaledStep < 2.5)\r\n            scaledStep = 2.5;\r\n        else if (scaledStep < 5)\r\n            scaledStep = 5;\r\n        else\r\n            scaledStep = 10;\r\n        return scaledStep;\r\n    }\r\n\r\n    calculateExtent() {\r\n        let targetTicks, approxStep, scale;\r\n\r\n        let targetStart = this.options.min;\r\n        let targetEnd = this.options.max;\r\n        const overriddenStart = !Utils.isMissingValue(targetStart);\r\n        const overriddenEnd = !Utils.isMissingValue(targetEnd);\r\n\r\n        if (!overriddenStart || !overriddenEnd) {\r\n            const [dataMin, dataMax] = this.isYAxis ? this.tayberry.getDataMinMax(this) : this.tayberry.getDataXMinMax(this);\r\n            const dataRange = dataMax - dataMin;\r\n            if (!overriddenStart) {\r\n                targetStart = dataMin;\r\n                if (this.isYAxis) {\r\n                    targetStart = targetStart - dataRange * 0.1;\r\n                    if (dataMin >= 0 && targetStart < 0)\r\n                        targetStart = 0;\r\n                }\r\n            }\r\n            if (!overriddenEnd) {\r\n                targetEnd = dataMax;\r\n                if (this.isYAxis) {\r\n                    targetEnd = dataMax + dataRange * 0.1;\r\n                    if (dataMax <= 0 && targetStart > 0)\r\n                        targetEnd = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.options.tickStepValue) {\r\n            this.tickStep = this.options.tickStepValue;\r\n            this.min = targetStart;\r\n            this.max = targetEnd;\r\n        } else {\r\n            const targetRange = targetEnd - targetStart;\r\n            targetTicks = this.plotLength / this.mapLogicalYOrXUnit(this.options.tickStep);\r\n            approxStep = targetRange / targetTicks;\r\n            scale = Math.pow(10, Math.floor(Math.log(approxStep) / Math.log(10)));\r\n            let scaledStep = LinearAxis.snapScaledValue(Math.ceil(approxStep / scale));\r\n            this.tickStep = scaledStep * scale;\r\n            this.min = targetStart;\r\n            this.max = targetEnd;\r\n        }\r\n        this.tickStart = this.options.tickStepValue && overriddenStart ? this.min : Math.floor(this.min / this.tickStep) * this.tickStep;\r\n        this.tickEnd = this.options.tickStepValue && overriddenEnd ? this.max : Math.ceil(this.max / this.tickStep) * this.tickStep;\r\n        if (!overriddenStart && this.isYAxis)\r\n            this.min = this.tickStart;\r\n        if (!overriddenEnd && this.isYAxis)\r\n            this.max = this.tickEnd;\r\n    }\r\n\r\n    get plotDisplacement() {\r\n        return this.isVertical ? (this.tayberry.plotArea.height - 1) : -(this.tayberry.plotArea.width - 1);\r\n    }\r\n\r\n    get plotLength() {\r\n        return Math.abs(this.plotDisplacement);\r\n    }\r\n\r\n    getOrigin() {\r\n        let ret = this.tayberry.plotArea[this.isVertical ? 'bottom' : 'left'] - (0 - this.min) * this.plotDisplacement / (this.max - this.min);\r\n        if (this.isVertical) ret--;\r\n        ret = this.isVertical ? Math.floor(ret) : Math.ceil(ret);\r\n        return ret;\r\n    }\r\n\r\n    getValueDisplacement(value) {\r\n        let ret = this.getOrigin() - value * this.plotDisplacement / (this.max - this.min);\r\n        ret = this.isVertical ? Math.floor(ret) : Math.ceil(ret);\r\n        return ret;\r\n    }\r\n\r\n    getCategoryLabel(index, totalCategories, isRange) {\r\n        if (isRange) {\r\n            const start = index / totalCategories;\r\n            const end = (index + 1) / totalCategories;\r\n            const axisRange = this.max - this.min;\r\n            return Utils.formatString('{0} \\u2264 x < {1}', [this.options.labelFormatter(this.min + start * axisRange), this.options.labelFormatter(this.min + end * axisRange)]);\r\n        } else {\r\n            return this.options.labelFormatter(index);\r\n        }\r\n    }\r\n}\r\n","'use strict';\r\n\r\nimport * as Utils from './utils';\r\n\r\nexport class Colour {\r\n    /**\r\n     * Constructs a Colour object.\r\n     *\r\n     * @param colourCode    an HTML colour code in hex or integer (rgb) form\r\n     */\r\n    constructor() {\r\n        if (arguments.length === 1) {\r\n            let arg1 = arguments[0];\r\n            if (typeof arg1 === 'string')\r\n                this.parseString(arg1);\r\n            else {\r\n                this.r = arg1.r;\r\n                this.g = arg1.g;\r\n                this.b = arg1.b;\r\n                this.a = arg1.a;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses an HTML colour code\r\n     * @param str\r\n     * @returns {Colour}\r\n     */\r\n    parseString(str) {\r\n        let regExHex = /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})|^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i;\r\n        let regExInt = /^rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})(\\s*,\\s*([0-9]*\\.?[0-9]+)\\s*)?\\)$/i;\r\n        const groupsHex = regExHex.exec(str);\r\n        const groupsInt = regExInt.exec(str);\r\n        if (groupsHex) {\r\n            let parseHex = function (value) {\r\n                let ret = parseInt(value, 16);\r\n                ret = ret * 0x10 + ret;\r\n                return ret;\r\n            };\r\n            this.r = groupsHex[1] ? parseInt(groupsHex[1], 16) : parseHex(groupsHex[4]);\r\n            this.g = groupsHex[2] ? parseInt(groupsHex[2], 16) : parseHex(groupsHex[5]);\r\n            this.b = groupsHex[3] ? parseInt(groupsHex[3], 16) : parseHex(groupsHex[6]);\r\n            this.a = 1.0;\r\n        }\r\n        else if (groupsInt) {\r\n            this.r = parseInt(groupsInt[1]);\r\n            this.g = parseInt(groupsInt[2]);\r\n            this.b = parseInt(groupsInt[3]);\r\n            this.a = groupsInt[5] ? parseFloat(groupsInt[5]) : 1.0;\r\n        } else {\r\n            throw new RangeError(str + \" is not a valid HTML colour\");\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clips a colour component to be in the range [0, 255], and round it them to\r\n     * the nearest integer\r\n     * @param component\r\n     * @returns {Colour}\r\n     */\r\n    clipComponent(component) {\r\n        this[component] = Math.round(this[component]);\r\n        this[component] = Math.min(this[component], 255);\r\n        this[component] = Math.max(this[component], 0);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clips r,g,b colour components to be in the range [0, 255], and rounds them to\r\n     * the nearest integer\r\n     * @returns {Colour}\r\n     */\r\n    clip() {\r\n        this.clipComponent('r');\r\n        this.clipComponent('g');\r\n        this.clipComponent('b');\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a number to each colour component\r\n     * @param number\r\n     * @returns {Colour}\r\n     */\r\n    increaseBy(number) {\r\n        this.r += number;\r\n        this.g += number;\r\n        this.b += number;\r\n        this.clip();\r\n        return this;\r\n    }\r\n\r\n    multiplyAlpha(multiplier) {\r\n        this.a *= multiplier;\r\n        return this;\r\n    }\r\n\r\n    get sum() {\r\n        return this.r + this.g + this.b;\r\n    }\r\n\r\n    /**\r\n     * Formats this colour as a string\r\n     * @returns {String}\r\n     */\r\n    toString() {\r\n        var ret;\r\n        if (!Utils.isMissingValue(this.a) && this.a !== 1.0) {\r\n            ret = Utils.formatString('rgba({r},{g},{b},{a})', this);\r\n        } else {\r\n            ret = Utils.formatString('rgb({r},{g},{b})', this);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static createFromBlend(colour1, colour2, blendPosition) {\r\n        const blender = (c1, c2) => (c1 + blendPosition * (c2 - c1));\r\n        return new Colour({\r\n            r: blender(colour1.r, colour2.r),\r\n            g: blender(colour1.g, colour2.g),\r\n            b: blender(colour1.b, colour2.b),\r\n            a: blender(Utils.coalesce(colour1.a, 1), Utils.coalesce(colour2.a, 1))\r\n        }).clip();\r\n    }\r\n\r\n}\r\n","'use strict';\r\n\r\nexport const visibilityState = {\r\n    visible: 1 << 0,\r\n    hidden: 1 << 1,\r\n    transitioning: 1 << 2\r\n};\r\n","'use strict';\r\nimport * as Utils from './helpers/utils.js';\r\nimport * as constants from './constants';\r\nimport {Colour} from './helpers/colour';\r\nimport {Tayberry} from './base';\r\n\r\nexport class Renderer {\r\n    constructor(ctx, tayberry, series) {\r\n        this.ctx = ctx;\r\n        this.tb = tayberry;\r\n        this.series = null;\r\n        this.setSeries(series);\r\n    }\r\n\r\n    setSeries(series) {\r\n        var seriesIndex;\r\n        this.series = series;\r\n\r\n        for (seriesIndex = 0; seriesIndex < this.series.length; seriesIndex++) {\r\n            const series = this.series[seriesIndex];\r\n            series.renderer = this;\r\n        }\r\n    }\r\n\r\n    getVisibleSeriesCount(excludeSeries) {\r\n        let ret = 0;\r\n        for (let index=0; index<this.series.length; index++) {\r\n            if (index !== excludeSeries) {\r\n                const series = this.series[index];\r\n                if (series.visible & (constants.visibilityState.visible))\r\n                    ret++;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    onToggleSeriesAnimationFrame() {\r\n    }\r\n\r\n    onAnimationFrame() {\r\n        this.onToggleSeriesAnimationFrame();\r\n    }\r\n\r\n    drawLegendIndicator(ctx, series, rect, highlighted) {\r\n        ctx.fillStyle = highlighted ? series.highlightColour : series.colour;\r\n        if (!(series.visible & constants.visibilityState.visible))\r\n            ctx.fillStyle = (new Colour(ctx.fillStyle)).multiplyAlpha(this.tb.options.legend.hiddenAlphaMultiplier).toString();\r\n        ctx.fillRect(rect.left, rect.top, rect.width, rect.height);\r\n    }\r\n\r\n    drawLabel(sign, text, rect) {\r\n        if (this.tb.options.swapAxes)\r\n            rect = rect.clone().swapXY();\r\n        let x = (rect.left + rect.right) / 2;\r\n        let y;\r\n        if (this.tb.options.labels.verticalAlignment === 'top')\r\n            y = rect.top;\r\n        else if (this.tb.options.labels.verticalAlignment === 'bottom')\r\n            y = rect.bottom;\r\n        else\r\n            y = (rect.top + rect.bottom) / 2;\r\n        let baseline = 'middle';\r\n        let align = 'center';\r\n        if (this.tb.options.swapAxes) {\r\n            [x, y] = [y, x];\r\n            if (this.tb.options.labels.verticalPosition === 'outside')\r\n                align = 'left';\r\n            else if (this.tb.options.labels.verticalPosition === 'inside')\r\n                align = 'right';\r\n        } else {\r\n            baseline = Tayberry.mapVerticalPosition(sign, this.tb.options.labels.verticalPosition);\r\n        }\r\n        if (this.tb.plotArea.containsPoint(x, y)) {\r\n            this.ctx.save();\r\n            this.ctx.textAlign = align;\r\n            this.ctx.textBaseline = baseline;\r\n            this.ctx.fillText(text, x, y);\r\n            this.ctx.restore();\r\n        }\r\n    }\r\n\r\n    drawPlot() {\r\n    }\r\n\r\n    drawLabels() {\r\n    }\r\n\r\n    hitTest() {\r\n    }\r\n\r\n}\r\n\r\nexport class Enumerator {\r\n    constructor(renderer, startCategoryIndex = 0) {\r\n        this.renderer = renderer;\r\n        this.tb = renderer.tb;\r\n\r\n        this.categoryCount = this.renderer.series[0].data.length;\r\n        this.categoryIndex = 0;\r\n        this.seriesIndex = 0;\r\n        this.seriesCount = this.renderer.series.length;\r\n        if (this.categoryCount) {\r\n            this.isHorizontal = this.tb.options.swapAxes;\r\n            this.plotArea = this.tb.plotArea.clone();\r\n            if (this.isHorizontal)\r\n                this.plotArea.swapXY();\r\n            this.startCategoryIndex = Math.max(startCategoryIndex, 0);\r\n            this.startCategoryIndex = Math.min(this.startCategoryIndex, this.categoryCount - 1);\r\n            this.categoryIndex = this.startCategoryIndex;\r\n        }\r\n    }\r\n\r\n    nextValue() {\r\n    }\r\n}\r\n\r\nexport class ByCategoryEnumerator extends Enumerator {\r\n    nextValue() {\r\n\r\n        let value;\r\n        do {\r\n            if (this.seriesIndex + 1 === this.seriesCount) {\r\n                this.seriesIndex = 0;\r\n                this.categoryIndex++;\r\n                if (this.categoryIndex >= this.categoryCount)\r\n                    break;\r\n            } else {\r\n                this.seriesIndex++;\r\n            }\r\n            value = Tayberry.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]);\r\n        } while (Utils.isMissingValue(value));\r\n\r\n    }\r\n}\r\n\r\nexport class BySeriesEnumerator extends Enumerator {\r\n    nextValue() {\r\n\r\n        let value;\r\n        do {\r\n            if (this.categoryIndex + 1 === this.categoryCount) {\r\n                this.categoryIndex = this.startCategoryIndex;\r\n                this.seriesIndex++;\r\n                if (this.seriesIndex >= this.seriesCount)\r\n                    break;\r\n            } else {\r\n                this.categoryIndex++;\r\n            }\r\n            value = Tayberry.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]);\r\n        } while (Utils.isMissingValue(value));\r\n\r\n    }\r\n}\r\n","'use strict';\r\n\r\nexport class Rect {\r\n    constructor() {\r\n        if (arguments.length === 1) {\r\n            if (typeof arguments[0] === 'object') {\r\n                const rect = arguments[0];\r\n                this.left = rect.left;\r\n                this.top = rect.top;\r\n                this.right = rect.right;\r\n                this.bottom = rect.bottom;\r\n            } else {\r\n                const val = arguments[0];\r\n                this.left = val;\r\n                this.top = val;\r\n                this.right = val;\r\n                this.bottom = val;\r\n            }\r\n        } else if (arguments.length === 4) {\r\n            this.left = arguments[0];\r\n            this.top = arguments[1];\r\n            this.right = arguments[2];\r\n            this.bottom = arguments[3];\r\n        }\r\n    }\r\n\r\n    get width() {\r\n        return this.right - this.left;\r\n    }\r\n\r\n    get height() {\r\n        return this.bottom - this.top;\r\n    }\r\n\r\n    get maxY() {\r\n        return Math.max(this.bottom, this.top);\r\n    }\r\n\r\n    get minY() {\r\n        return Math.min(this.bottom, this.top);\r\n    }\r\n\r\n    get minX() {\r\n        return Math.min(this.left, this.right);\r\n    }\r\n\r\n    get maxX() {\r\n        return Math.max(this.left, this.right);\r\n    }\r\n\r\n    get xMidpoint() {\r\n        return (this.left + this.right) / 2;\r\n    }\r\n\r\n    get yMidpoint() {\r\n        return (this.top + this.bottom) / 2;\r\n    }\r\n\r\n    get area() {\r\n        return Math.abs(this.width) * Math.abs(this.height);\r\n    }\r\n\r\n    containsPoint(x, y) {\r\n        return this.containsX(x) && this.containsY(y);\r\n    }\r\n\r\n    containsY(y) {\r\n        return (y >= this.top && y < this.bottom) || (y >= this.bottom && y < this.top);\r\n    }\r\n\r\n    containsX(x) {\r\n        return (x >= this.left && x < this.right) || (x >= this.right && x < this.left);\r\n    }\r\n\r\n    inflate(val) {\r\n        this.left -= val;\r\n        this.top -= val;\r\n        this.right += val;\r\n        this.bottom += val;\r\n        return this;\r\n    }\r\n\r\n    clip(clipRect) {\r\n        //FIXME: In theory, we should be more careful about how we handle rects where right < left or bottom < top\r\n        if (this.left < clipRect.minX) this.left = clipRect.minX;\r\n        else if (this.left > clipRect.maxX) this.left = clipRect.maxX;\r\n\r\n        if (this.right < clipRect.minX) this.right = clipRect.minX;\r\n        else if (this.right > clipRect.maxX) this.right = clipRect.maxX;\r\n\r\n        if (this.top < clipRect.minY)\r\n            this.top = clipRect.minY;\r\n        else if (this.top > clipRect.maxY)\r\n            this.top = clipRect.maxY;\r\n\r\n        if (this.bottom > clipRect.maxY)\r\n            this.bottom = clipRect.maxY;\r\n        else if (this.bottom < clipRect.minY)\r\n            this.bottom = clipRect.minY;\r\n\r\n        return this;\r\n    }\r\n\r\n    clone() {\r\n        return new Rect(this);\r\n    }\r\n\r\n    swapXY() {\r\n        [this.left, this.top] = [this.top, this.left];\r\n        [this.bottom, this.right] = [this.right, this.bottom];\r\n        return this;\r\n    }\r\n}\r\n","'use strict';\r\nimport {Rect} from './helpers/rect';\r\nimport * as Utils from './helpers/utils.js';\r\nimport {Colour} from './helpers/colour';\r\nimport * as renderer from './renderer.base';\r\nimport * as constants from './constants';\r\nimport {Tayberry} from './base';\r\n\r\nexport class BarRenderer extends renderer.Renderer {\r\n    constructor(ctx, tayberry, series) {\r\n        super(ctx, tayberry, series);\r\n\r\n        this.barPositions = null;\r\n\r\n        this.tb.registerCallback('onResize', this.updateBarWidths.bind(this));\r\n        this.tb.registerCallback('onInit', this.updateBarWidths.bind(this));\r\n    }\r\n\r\n    updateBarWidths() {\r\n        const categoryCount = this.series[0].data.length;\r\n        const isStacked = this.tb.options.barPlot.mode === 'stacked';\r\n        const isOverlaid = this.tb.options.barPlot.mode === 'overlaid';\r\n        const isNormal = !isStacked && !isOverlaid;\r\n        const seriesCount = this.series.length;\r\n        const plotArea = this.tb.options.swapAxes ? this.tb.plotArea.clone().swapXY() : this.tb.plotArea;\r\n        const categoryWidth = (plotArea.width / categoryCount);\r\n        let animatingSeriesCount = 0;\r\n        let totalMultiplier = 0;\r\n\r\n        for (let seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\r\n            const series = this.series[seriesIndex];\r\n            const rState = series.rState;\r\n            if (series.animationState) {\r\n                if (!series.animationState.subtype) {\r\n                    const visibleSeriesCount = this.getVisibleSeriesCount(seriesIndex);\r\n                    if (isNormal && visibleSeriesCount > 0) {\r\n                        series.animationState.subtype = 'width';\r\n                    } else if (isStacked  && visibleSeriesCount > 0) {\r\n                        series.animationState.subtype = 'height';\r\n                    } else {\r\n                        series.animationState.subtype = 'fade';\r\n                    }\r\n\r\n                    rState.colour = series.colour;\r\n                }\r\n\r\n                const isShow = series.animationState.type === 'show';\r\n                if (series.animationState.subtype === 'width') {\r\n                    rState.multiplier = isShow ? series.animationState.stage : 1 - series.animationState.stage;\r\n                    rState.yMultiplier = 1;\r\n                } else if (series.animationState.subtype === 'height') {\r\n                    rState.yMultiplier = isShow ? series.animationState.stage : 1 - series.animationState.stage;\r\n                    rState.multiplier = 1;\r\n                } else {\r\n                    let transColour = new Colour(series.colour);\r\n                    transColour.a = 0;\r\n                    if (isShow)\r\n                        rState.colour = Colour.createFromBlend(transColour, new Colour(series.colour), series.animationState.stage).toString();\r\n                    else\r\n                        rState.colour = Colour.createFromBlend(new Colour(series.colour), transColour, series.animationState.stage).toString();\r\n\r\n                    rState.yMultiplier = 1;\r\n                    rState.multiplier = 1;\r\n                }\r\n                ++animatingSeriesCount;\r\n            } else if (series.visible & constants.visibilityState.visible) {\r\n                rState.multiplier = 1;\r\n                rState.yMultiplier = 1;\r\n            } else {\r\n                rState.multiplier = 0;\r\n                rState.yMultiplier = 0;\r\n            }\r\n            totalMultiplier += rState.multiplier;\r\n        }\r\n\r\n        const totalBarsPerCategory = (isStacked || isOverlaid) ? 1 : totalMultiplier;\r\n        const yOrigin = this.series[0].yAxis.getOrigin();\r\n\r\n        this.barPositions = [];\r\n\r\n        for (let categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {\r\n            let yBottomPositive = yOrigin;\r\n            let yBottomNegative = yOrigin;\r\n            let yRunningTotalPositive = 0;\r\n            let yRunningTotalNegative = 0;\r\n\r\n            const categoryXStart = plotArea.left + Math.floor(categoryIndex * categoryWidth);\r\n            const categoryXEnd = plotArea.left + Math.floor((categoryIndex + 1) * categoryWidth);\r\n            // FIXME: Need to map this.tb.options.barPlot.categorySpacing\r\n            const barXStart = categoryXStart + Math.ceil(categoryWidth * this.tb.options.barPlot.categorySpacing / 2);\r\n            const barXEnd = categoryXEnd - Math.floor(categoryWidth * this.tb.options.barPlot.categorySpacing / 2);\r\n\r\n            let categoryPositions = [];\r\n            let barIndex = 0;\r\n\r\n            let runningBarWidth = 0;\r\n\r\n            for (let seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\r\n                const series = this.series[seriesIndex];\r\n                const rState = series.rState;\r\n                const value = Tayberry.getDataValue(series.data[categoryIndex])*rState.yMultiplier;\r\n\r\n                let barWidth = Math.floor(rState.multiplier * Math.floor((barXEnd - barXStart) / totalBarsPerCategory));\r\n\r\n                const xStart = Math.floor(barXStart + runningBarWidth) + Math.ceil(series.xAxis.mapLogicalXOrYUnit(this.tb.options.barPlot.barPadding) / 2);\r\n                const xEnd = Math.ceil(barXStart + runningBarWidth + barWidth) - Math.floor(series.xAxis.mapLogicalXOrYUnit(this.tb.options.barPlot.barPadding) / 2);\r\n                const yTop = series.yAxis.getValueDisplacement(value + (value > 0 ? yRunningTotalPositive : yRunningTotalNegative));\r\n                const yBottom = isStacked ? (value > 0 ? yBottomPositive : yBottomNegative) : yOrigin;\r\n\r\n                categoryPositions.push([xStart, yTop, xEnd, yBottom]);\r\n\r\n                if (isStacked) {\r\n                    if (value > 0) {\r\n                        yRunningTotalPositive += value;\r\n                        yBottomPositive = yTop;\r\n                    } else {\r\n                        yRunningTotalNegative += value;\r\n                        yBottomNegative = yTop;\r\n                    }\r\n                } else if (isNormal) {\r\n                    barIndex++;\r\n                    runningBarWidth += barWidth;\r\n                }\r\n\r\n            }\r\n\r\n            this.barPositions.push(categoryPositions);\r\n        }\r\n    }\r\n\r\n    onToggleSeriesAnimationFrame() {\r\n        this.updateBarWidths();\r\n    }\r\n\r\n    drawPlot() {\r\n        this.ctx.save();\r\n        let barEnumerator = new BarEnumerator(this);\r\n        let bar;\r\n        while ((bar = barEnumerator.next())) {\r\n            if (bar.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)) {\r\n                this.ctx.fillStyle = bar.selected ? bar.series.rState.highlightColour : bar.series.rState.colour;\r\n                this.ctx.fillRect(bar.rect.left, bar.rect.top, bar.rect.width, bar.rect.height);\r\n            }\r\n        }\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawLabels() {\r\n        if (this.tb.options.labels.enabled) {\r\n            this.ctx.save();\r\n            let barEnumerator = new BarEnumerator(this);\r\n            let bar;\r\n            while ((bar = barEnumerator.next())) {\r\n                if ((bar.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)) === constants.visibilityState.visible) {\r\n                    this.ctx.font = this.tb.labelFont;\r\n                    this.ctx.fillStyle = this.tb.options.labels.font.colour;\r\n                    this.drawLabel(bar.value, bar.series.yAxis.options.labelFormatter(bar.value), bar.rect);\r\n                }\r\n            }\r\n            this.ctx.restore();\r\n        }\r\n    }\r\n\r\n    hitTest(x, y) {\r\n        // TODO: Optimise\r\n        let ret = {\r\n            found: false,\r\n            plotType: 'bar',\r\n            type: 'plotItem',\r\n            isXRange: true\r\n        };\r\n\r\n        const categoryCount = this.series[0].data.length;\r\n        const isHorizontal = this.tb.options.swapAxes;\r\n        let plotArea = this.tb.plotArea.clone();\r\n        if (isHorizontal)\r\n            plotArea.swapXY();\r\n        const categoryIndex = Math.floor(categoryCount * ((isHorizontal ? y : x) - plotArea.left) / plotArea.width);\r\n\r\n        let matches = [];\r\n\r\n        let barEnumerator = new BarEnumerator(this, categoryIndex);\r\n        let bar;\r\n        while ((bar = barEnumerator.next())) {\r\n            if (bar.categoryIndex > categoryIndex)\r\n                break;\r\n            if (!(bar.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)))\r\n                continue;\r\n\r\n            let sortDistance, priority, realDistance;\r\n            if (bar.rect.containsPoint(x, y)) {\r\n                sortDistance = 0;\r\n                priority = 0;\r\n            }\r\n            else if (bar.rect.containsX(x)) {\r\n                sortDistance = y < bar.rect.top ? bar.rect.top - y : y - bar.rect.bottom;\r\n                priority = isHorizontal ? 2 : 1;\r\n            }\r\n            else if (bar.rect.containsY(y)) {\r\n                sortDistance = x < bar.rect.left ? bar.rect.left - x : x - bar.rect.right;\r\n                priority = isHorizontal ? 1 : 2;\r\n            }\r\n            else {\r\n                const xDist = Math.min(Math.abs(x - bar.rect.left), Math.abs(x - bar.rect.right));\r\n                const yDist = Math.min(Math.abs(y - bar.rect.top), Math.abs(y - bar.rect.bottom));\r\n                realDistance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\r\n                sortDistance = isHorizontal ? yDist : xDist;\r\n                priority = 3;\r\n            }\r\n\r\n            if (typeof realDistance === 'undefined')\r\n                realDistance = sortDistance;\r\n\r\n            if (!Utils.isMissingValue(realDistance)) {\r\n                matches.push({\r\n                    sortDistance: sortDistance,\r\n                    distance: realDistance,\r\n                    priority: priority,\r\n                    data: {\r\n                        categoryIndex: bar.categoryIndex,\r\n                        seriesIndex: bar.seriesIndex,\r\n                        rect: bar.rect,\r\n                        series: bar.series,\r\n                        value: Tayberry.getDataValue(this.series[bar.seriesIndex].data[bar.categoryIndex])\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (matches.length) {\r\n            matches.sort((a, b) => {\r\n                let ret = a.priority - b.priority;\r\n                if (!ret) ret = a.sortDistance - b.sortDistance;\r\n                if (!ret) ret = a.distance - b.distance;\r\n                if (!ret) ret = a.data.rect.height - b.data.rect.height;\r\n                return ret;\r\n            });\r\n            ret.found = true;\r\n            ret.normalisedDistance = matches[0].distance + Math.sqrt(matches[0].data.rect.area);\r\n            if (ret.normalisedDistance < 0) {\r\n                ret.normalisedDistance = 0;\r\n            }\r\n            ret = Utils.assign(ret, matches[0].data);\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\nexport class BarEnumerator extends renderer.ByCategoryEnumerator {\r\n    next() {\r\n        let ret;\r\n\r\n        if (this.categoryIndex < this.categoryCount) {\r\n            const [xStart, yTop, xEnd, yBottom] = this.renderer.barPositions[this.categoryIndex][this.seriesIndex];\r\n\r\n            let rect = new Rect(xStart, yTop, xEnd, yBottom);\r\n\r\n            if (rect.right < rect.left)\r\n                rect.right = rect.left;\r\n            if (this.isHorizontal)\r\n                rect.swapXY();\r\n            rect.clip(this.tb.plotArea);\r\n\r\n            ret = {\r\n                seriesIndex: this.seriesIndex,\r\n                categoryIndex: this.categoryIndex,\r\n                series: this.renderer.series[this.seriesIndex],\r\n                value: Tayberry.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]),\r\n                rect: rect,\r\n                selected: this.tb.selectedItem.type === 'plotItem' && this.tb.selectedItem.categoryIndex === this.categoryIndex && (this.tb.options.tooltips.shared || this.tb.selectedItem.series === this.renderer.series[this.seriesIndex])\r\n            };\r\n\r\n            this.nextValue();\r\n\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\n","'use strict';\r\nimport * as Utils from './helpers/utils.js';\r\nimport {Rect} from './helpers/rect';\r\nimport * as renderer from './renderer.base';\r\nimport * as constants from './constants';\r\nimport {Tayberry} from './base';\r\n\r\nvar autoMarkerIndex = 0;\r\nconst markers = ['square', 'diamond', 'circle', 'triangle', 'triangle-inversed'];\r\n\r\nexport class LineRenderer extends renderer.Renderer {\r\n    constructor(ctx, tayberry, series) {\r\n        super(ctx, tayberry, series);\r\n\r\n        this.pointPositions = null;\r\n\r\n        this.tb.registerCallback('onResize', this.updatPointPositions.bind(this));\r\n        this.tb.registerCallback('onInit', this.updatPointPositions.bind(this));\r\n    }\r\n\r\n    updatPointPositions() {\r\n        const seriesCount = this.series.length;\r\n\r\n        this.pointPositions = [];\r\n\r\n        for (let seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\r\n            const series = this.series[seriesIndex];\r\n            const rState = series.rState;\r\n            if (series.animationState) {\r\n                if (!series.animationState.subtype) {\r\n                    series.animationState.subtype = 'height';\r\n                }\r\n\r\n                const isShow = series.animationState.type === 'show';\r\n                if (series.animationState.subtype === 'height') {\r\n                    rState.yMultiplier = isShow ? series.animationState.stage : 1 - series.animationState.stage;\r\n                    rState.xMultiplier = 1;\r\n                }\r\n\r\n            } else if (series.visible & constants.visibilityState.visible) {\r\n                rState.xMultiplier = 1;\r\n                rState.yMultiplier = 1;\r\n            } else {\r\n                rState.xMultiplier = 1;\r\n                rState.yMultiplier = 0;\r\n            }\r\n        }\r\n\r\n        for (let seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\r\n            const series = this.series[seriesIndex];\r\n            const rState = series.rState;\r\n            const valueCount = series.data.length;\r\n            const yOrigin = series.yAxis.valueOrigin;\r\n            let seriesPositions = [];\r\n\r\n            for (let valueIndex = 0; valueIndex < valueCount; valueIndex++) {\r\n                const value = Tayberry.getDataValue(series.data[valueIndex]);\r\n                const xValue = Tayberry.getDataXValue(series.data, valueIndex);\r\n\r\n                const rValue = yOrigin + (rState.yMultiplier)*(value-yOrigin);\r\n                let x = series.xAxis.getValueDisplacement(xValue)*rState.xMultiplier;\r\n                let y = series.yAxis.getValueDisplacement(rValue);\r\n\r\n                seriesPositions.push([x, y]);\r\n            }\r\n\r\n            this.pointPositions.push(seriesPositions);\r\n        }\r\n    }\r\n\r\n    setSeries(series) {\r\n        let totalPoints = 0;\r\n        for (var i = 0; i < series.length; i++) {\r\n            if (!series[i].markerType) {\r\n                series[i].markerType = markers[autoMarkerIndex % markers.length];\r\n                autoMarkerIndex++;\r\n            }\r\n            totalPoints += series[i].data.length;\r\n        }\r\n        const showMarkers = this.tb.options.linePlot.showMarkers;\r\n        this.showMarkers = showMarkers === 'auto' ? totalPoints < this.tb.options.linePlot.noMarkersThreshold : showMarkers;\r\n        super.setSeries(series);\r\n    }\r\n\r\n    drawMarker(type, x, y, size, ctx = this.ctx) {\r\n        if (type === 'square') {\r\n            ctx.fillRect(x - size / 2, y - size / 2, size, size);\r\n        } else if (type === 'diamond') {\r\n            ctx.save();\r\n            ctx.translate(x, y);\r\n            ctx.rotate(-Math.PI / 4);\r\n            ctx.fillRect(0 - size / 2, 0 - size / 2, size, size);\r\n            ctx.restore();\r\n        } else if (type === 'circle') {\r\n            size = Math.round(size * 1.2);\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, size / 2, 0, 2 * Math.PI);\r\n            ctx.fill();\r\n        } else if (type === 'triangle' || (type === 'triangle-inversed' && (size = -size))) {\r\n            size = Math.round(size * 1.2);\r\n            ctx.beginPath();\r\n            ctx.moveTo(x - size / 2, y + size / 2);\r\n            ctx.lineTo(x, y - size / 2);\r\n            ctx.lineTo(x + size / 2, y + size / 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        }\r\n    }\r\n\r\n    onToggleSeriesAnimationFrame() {\r\n        this.updatPointPositions();\r\n    }\r\n\r\n    drawPlot() {\r\n        this.ctx.save();\r\n        let pointEnumerator = new PointEnumerator(this);\r\n        let pt;\r\n        while ((pt = pointEnumerator.next())) {\r\n            if (!(pt.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)))\r\n                continue;\r\n\r\n            if (pt.firstPoint) {\r\n                this.ctx.lineWidth = pt.seriesSelected ? this.tb.options.linePlot.highlightedLineWidth : this.tb.options.linePlot.lineWidth;\r\n                this.ctx.strokeStyle = pt.seriesSelected ? pt.series.rState.highlightColour : pt.series.rState.colour;\r\n                this.ctx.beginPath();\r\n                this.ctx.moveTo(pt.x, pt.y);\r\n            } else {\r\n                this.ctx.lineTo(pt.x, pt.y);\r\n            }\r\n            if (pt.lastPoint) {\r\n                this.ctx.stroke();\r\n            }\r\n        }\r\n        if (this.showMarkers) {\r\n            pointEnumerator = new PointEnumerator(this);\r\n            while ((pt = pointEnumerator.next())) {\r\n                if (!(pt.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)))\r\n                    continue;\r\n\r\n                if (pt.selected) {\r\n                    this.ctx.fillStyle = pt.series.rState.glowColour;\r\n                    this.drawMarker(pt.series.markerType, pt.x, pt.y, this.tb.options.linePlot.highlightedMarkerSize);\r\n                }\r\n                this.ctx.fillStyle = pt.series.rState.colour;\r\n                this.drawMarker(pt.series.markerType, pt.x, pt.y, this.tb.options.linePlot.markerSize);\r\n            }\r\n        }\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawLegendIndicator(ctx, series, rect, highlighted) {\r\n        const colour = highlighted ? series.highlightColour : series.colour;\r\n        ctx.save();\r\n        ctx.lineWidth = 2;\r\n        ctx.strokeStyle = colour;\r\n        this.tb.drawLine(rect.left, rect.yMidpoint, rect.right, rect.yMidpoint);\r\n        ctx.fillStyle = colour;\r\n        this.drawMarker(series.markerType, rect.xMidpoint, rect.yMidpoint, this.tb.options.linePlot.markerSize, ctx);\r\n        ctx.restore();\r\n    }\r\n\r\n    drawLabels() {\r\n        if (this.tb.options.labels.enabled) {\r\n            this.ctx.save();\r\n            this.ctx.font = this.tb.labelFont;\r\n            this.ctx.fillStyle = this.tb.options.labels.font.colour;\r\n            let pointEnumerator = new PointEnumerator(this);\r\n            let pt;\r\n            while ((pt = pointEnumerator.next())) {\r\n                if (!(pt.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)))\r\n                    continue;\r\n\r\n                const rect = new Rect(pt.x, pt.y, pt.x, pt.y).inflate(this.tb.options.linePlot.markerSize / 2);\r\n                this.drawLabel(pt.value, pt.series.yAxis.options.labelFormatter(pt.value), rect);\r\n            }\r\n            this.ctx.restore();\r\n        }\r\n    }\r\n\r\n\r\n    hitTest(x, y) {\r\n        // TODO: Optimise\r\n        let ret = {\r\n            found: false,\r\n            plotType: 'line',\r\n            type: 'plotItem',\r\n            isXRange: false\r\n        };\r\n\r\n        let matches = [];\r\n\r\n        let pointEnumerator = new PointEnumerator(this);\r\n        let pt;\r\n        while ((pt = pointEnumerator.next())) {\r\n            if (!(pt.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)))\r\n                continue;\r\n\r\n            const distance = Math.sqrt(Math.pow(pt.x - x, 2) + Math.pow(pt.y - y, 2));\r\n            const horizontalDistance = Math.abs(this.tb.options.swapAxes ? pt.y - y : pt.x - x);\r\n            matches.push({\r\n                distance: distance,\r\n                horizontalDistance: horizontalDistance,\r\n                priority: 0,\r\n                data: pt\r\n            });\r\n            //if (!pt.firstPoint) {\r\n            //    if (x >= lastPt.x && x < pt.x) {\r\n            //const alpha = Math.arctan((pt.y - lastPt.y) / (pt.x - lastPt.x));\r\n            //const yAtX = (x - lastPt.x) * Math.tan(alpha) + lastPt.y;\r\n            //if (yAtX - 2 <= y < yAtX + 2) {\r\n            //    matches.push({\r\n            //        categoryIndex: pt.categoryIndex,\r\n            //        seriesIndex: pt.seriesIndex,\r\n            //        x: bar.rect,\r\n            //        series: this.series[bar.seriesIndex],\r\n            //        dataPoint: this.series[bar.seriesIndex].data[bar.categoryIndex]\r\n            //\r\n            //    })\r\n            //}\r\n            //}\r\n            //}\r\n            //lastPt = pt;\r\n\r\n        }\r\n        if (matches.length) {\r\n            matches.sort((e1, e2) => {\r\n                return (e1.horizontalDistance - e2.horizontalDistance) || (e1.distance - e2.distance);\r\n            });\r\n            if (true || matches[0].distance <= 5) {\r\n                pt = matches[0].data;\r\n                const rect = new Rect(pt.x, pt.y, pt.x, pt.y).inflate(this.tb.options.linePlot.markerSize / 2);\r\n                Utils.assign(ret, [{\r\n                    found: true,\r\n                    rect: rect,\r\n                    normalisedDistance: matches[0].distance + Math.sqrt(rect.area)\r\n                }, pt]);\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n}\r\n\r\nexport class PointEnumerator extends renderer.BySeriesEnumerator {\r\n    next() {\r\n        let ret;\r\n\r\n        if (this.seriesIndex < this.seriesCount) {\r\n            let [x, y] = this.renderer.pointPositions[this.seriesIndex][this.categoryIndex];\r\n\r\n            if (this.isHorizontal)\r\n                [x, y] = [y, x];\r\n\r\n            ret = {\r\n                firstPoint: this.categoryIndex === 0,\r\n                lastPoint: this.categoryIndex + 1 === this.categoryCount,\r\n                seriesIndex: this.seriesIndex,\r\n                categoryIndex: this.categoryIndex,\r\n                series: this.renderer.series[this.seriesIndex],\r\n                value: Tayberry.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]),\r\n                x: x,\r\n                y: y,\r\n                seriesSelected: this.tb.selectedItem.type === 'plotItem' && !this.tb.options.tooltips.shared && this.tb.selectedItem.series === this.renderer.series[this.seriesIndex],\r\n                selected: this.tb.selectedItem.type === 'plotItem' && this.tb.selectedItem.categoryIndex === this.categoryIndex && (this.tb.options.tooltips.shared || this.tb.selectedItem.series === this.renderer.series[this.seriesIndex])\r\n            };\r\n\r\n            this.nextValue();\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n","'use strict';\r\nimport {Rect} from './helpers/rect';\r\nimport * as Utils from './helpers/utils.js';\r\nimport * as constants from './constants';\r\nimport {Colour} from './helpers/colour';\r\n\r\nexport class Legend {\r\n    /**\r\n     *\r\n     * @param tayberry {Tayberry}\r\n     */\r\n    constructor(tayberry) {\r\n        this.tb = tayberry;\r\n        this.xPos = null;\r\n        this.yPos = null;\r\n        this.rowIndices = null;\r\n        this.calculatedSize = null;\r\n        this.canvas = tayberry.labelsCanvas;\r\n        this.ctx = tayberry.labelsCtx;\r\n        this.font = null;\r\n    }\r\n\r\n    adjustSize(plotArea, reset) {\r\n        let ret = false;\r\n        if (reset) {\r\n            this.calculatedSize = 0;\r\n        }\r\n        if (this.tb.options.legend.enabled) {\r\n            const smallPadding = this.tb.mapLogicalXUnit(this.tb.options.elementSmallPadding);\r\n            const largePadding = this.tb.mapLogicalXUnit(this.tb.options.elementLargePadding);\r\n            const indicatorSize = this.tb.mapLogicalXUnit(this.tb.options.legend.indicatorSize);\r\n            const textWidths = this.getItemTextWidths();\r\n            const maxLegendItemWidth = Utils.reduce(textWidths, Math.max) + indicatorSize + smallPadding;\r\n            const isVertical = this.tb.options.legend.placement === 'left' || this.tb.options.legend.placement === 'right';\r\n            const isHorizontal = !isVertical;\r\n\r\n            let rowIndices = [];\r\n            const numItems = textWidths.length;\r\n            const plotWidth = plotArea.width;\r\n\r\n\r\n            if (isHorizontal) {\r\n                let cumWidth = 0;\r\n                for (let i = 0; i < numItems; i++) {\r\n                    cumWidth += textWidths[i] + indicatorSize + smallPadding;\r\n                    if (i + 1 == numItems) {\r\n                        rowIndices.push(i + 1);\r\n                    } else if (cumWidth > plotWidth) {\r\n                        rowIndices.push(i);\r\n                        cumWidth = 0;\r\n                    } else {\r\n                        cumWidth += largePadding;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = 0; i < numItems; i++) {\r\n                    rowIndices.push(i + 1);\r\n                }\r\n            }\r\n\r\n            this.rowIndices = rowIndices;\r\n            const numRows = rowIndices.length;\r\n            const height = indicatorSize * numRows + (numRows - 1) * smallPadding;\r\n\r\n            let calculatedSize = 0;\r\n\r\n            switch (this.tb.options.legend.placement) {\r\n                case 'bottom':\r\n                    calculatedSize = largePadding + indicatorSize * numRows;\r\n                    plotArea.bottom -= calculatedSize - this.calculatedSize;\r\n                    this.yPos = this.canvas.height - indicatorSize * numRows;\r\n                    break;\r\n                case 'top':\r\n                    calculatedSize = largePadding + indicatorSize * numRows;\r\n                    this.yPos = plotArea.top;\r\n                    plotArea.top += calculatedSize - this.calculatedSize;\r\n                    break;\r\n                case 'left':\r\n                    calculatedSize = maxLegendItemWidth + largePadding;\r\n                    this.xPos = 0;\r\n                    this.yPos = plotArea.bottom - plotArea.height / 2 - height / 2;\r\n                    plotArea.left += calculatedSize - this.calculatedSize;\r\n                    break;\r\n                case 'right':\r\n                    calculatedSize = maxLegendItemWidth + largePadding;\r\n                    plotArea.right -= calculatedSize - this.calculatedSize;\r\n                    this.xPos = plotArea.right + largePadding;\r\n                    this.yPos = plotArea.bottom - plotArea.height / 2 - height / 2;\r\n                    break;\r\n            }\r\n\r\n            ret = this.calculatedSize !== calculatedSize;\r\n            this.calculatedSize = calculatedSize;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    updateFonts() {\r\n        this.font = this.tb.createFontString(this.tb.options.legend.font);\r\n    }\r\n\r\n    draw() {\r\n        if (this.tb.options.legend.enabled) {\r\n            let legendMetrics = this.getMeasurements();\r\n            this.ctx.save();\r\n            this.ctx.font = this.font;\r\n\r\n            for (let index = 0; index < legendMetrics.items.length; index++) {\r\n                const item = legendMetrics.items[index];\r\n                const series = item.series;\r\n                const highlighted = this.tb.selectedItem.type === 'legend' && this.tb.selectedItem.data.series === series;\r\n                series.renderer.drawLegendIndicator(this.ctx, series, item.indicatorRect, highlighted);\r\n                this.ctx.textBaseline = 'middle';\r\n                this.ctx.fillStyle = this.tb.options.legend.font.colour;\r\n                if (!(series.visible & constants.visibilityState.visible))\r\n                    this.ctx.fillStyle = (new Colour(this.ctx.fillStyle)).multiplyAlpha(this.tb.options.legend.hiddenAlphaMultiplier).toString();\r\n                this.ctx.fillText(series.name, item.textX, item.textY);\r\n            }\r\n            this.ctx.restore();\r\n        }\r\n    }\r\n\r\n    hitTest(x, y) {\r\n        let ret = {\r\n            found: false,\r\n            type: 'legend'\r\n        };\r\n        const legendMetrics = this.getMeasurements();\r\n        if (legendMetrics.rect.containsPoint(x, y)) {\r\n            for (let index = 0; index < legendMetrics.items.length; index++) {\r\n                const item = legendMetrics.items[index];\r\n                if (item.rect.containsPoint(x, y)) {\r\n                    Utils.assign(ret, [{found: true, normalisedDistance: -5, data: item}]);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    getItemTextWidths() {\r\n        let ret = [];\r\n        for (let index = 0; index < this.tb.options.series.length; index++) {\r\n            const series = this.tb.options.series[index];\r\n            let width = 0;\r\n            if (series.name) {\r\n                width = Math.max(this.tb.getTextWidth(series.name, this.font));\r\n            }\r\n            ret.push(width);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    getMeasurements() {\r\n        let ret = {\r\n            rect: new Rect(0),\r\n            items: []\r\n        };\r\n        if (this.tb.options.legend.enabled) {\r\n            const smallPadding = this.tb.mapLogicalXUnit(this.tb.options.elementSmallPadding);\r\n            const largePadding = this.tb.mapLogicalXUnit(this.tb.options.elementLargePadding);\r\n            const indicatorSize = this.tb.mapLogicalXUnit(this.tb.options.legend.indicatorSize);\r\n            const isVertical = this.tb.options.legend.placement === 'left' || this.tb.options.legend.placement === 'right';\r\n            const isHorizontal = !isVertical;\r\n            let newLineIndices = this.rowIndices;\r\n\r\n            let lineWidths = [];\r\n\r\n            let lineStart = 0;\r\n            for (let lineIndex = 0; lineIndex < newLineIndices.length; lineIndex++) {\r\n                const lineEnd = newLineIndices[lineIndex];\r\n                let lineWidth = 0;\r\n\r\n                for (let index = lineStart; index < lineEnd; index++) {\r\n                    const series = this.tb.options.series[index];\r\n                    if (index > newLineIndices[lineIndex]) {\r\n                        ++lineIndex;\r\n                    }\r\n                    let textWidth = 0;\r\n\r\n                    if (series.name) {\r\n                        textWidth = this.tb.getTextWidth(series.name, this.font);\r\n                        lineWidth += textWidth + indicatorSize + smallPadding;\r\n                        if (index + 1 < lineEnd)\r\n                            lineWidth += largePadding;\r\n                        ret.items.push({textWidth: textWidth, series: series});\r\n                    } else {\r\n                        ret.items.push({textWidth: 0, series: series});\r\n                    }\r\n                }\r\n                lineStart = lineEnd;\r\n                lineWidths.push(lineWidth);\r\n            }\r\n\r\n            lineStart = 0;\r\n            for (let lineIndex = 0; lineIndex < newLineIndices.length; lineIndex++) {\r\n                const lineEnd = newLineIndices[lineIndex];\r\n                const lineWidth = lineWidths[lineIndex];\r\n                let x = isHorizontal ? this.tb.plotArea.left + this.tb.plotArea.width / 2 - lineWidth / 2 : this.xPos;\r\n                let y = this.yPos + (indicatorSize + smallPadding) * lineIndex;\r\n\r\n                if (lineIndex === 0) {\r\n                    ret.rect.left = x;\r\n                    ret.rect.right = x;\r\n                    ret.rect.top = y;\r\n                }\r\n\r\n                for (let index = lineStart; index < lineEnd; index++) {\r\n                    let item = ret.items[index];\r\n\r\n                    if (item.textWidth > 0) {\r\n                        item.rect = new Rect(x, y, x + indicatorSize + smallPadding + item.textWidth, y + indicatorSize);\r\n                        item.indicatorRect = new Rect(x, y, x + indicatorSize, y + indicatorSize);\r\n                        item.textX = x + indicatorSize + smallPadding;\r\n                        item.textY = y + indicatorSize / 2;\r\n\r\n                        ret.rect.right = Math.max(ret.rect.right, item.rect.right);\r\n\r\n                        if (isHorizontal) {\r\n                            x += ret.items[index].textWidth + largePadding;\r\n                            x += indicatorSize + smallPadding;\r\n                        }\r\n                    } else {\r\n                        item.rect = new Rect(0);\r\n                        item.indicatorRect = new Rect(0);\r\n                        item.textX = 0;\r\n                        item.textY = 0;\r\n                    }\r\n                }\r\n                lineStart = lineEnd;\r\n                if (lineIndex + 1 === newLineIndices.length) {\r\n                    ret.rect.bottom = y + indicatorSize;\r\n                }\r\n            }\r\n\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n","'use strict';\r\nimport {Colour} from './helpers/colour';\r\nimport * as Utils from './helpers/utils.js';\r\n\r\nimport {Tayberry} from './base';\r\nimport {Axis} from './axis';\r\nimport {BarRenderer} from './renderer.bar';\r\nimport {LineRenderer} from './renderer.line';\r\nimport {Legend} from './legend';\r\n\r\nvar currentAutoColourIndex = 0;\r\n\r\nTayberry.getAutoColour = function () {\r\n    let ret = Tayberry.defaultColours[currentAutoColourIndex % Tayberry.defaultColours.length];\r\n    currentAutoColourIndex++;\r\n    return ret;\r\n};\r\n\r\nTayberry.getDataValue = function (dataPoint) {\r\n    let ret;\r\n    if (Array.isArray(dataPoint)) {\r\n        ret = dataPoint[1];\r\n    } else {\r\n        ret = dataPoint;\r\n    }\r\n    return ret;\r\n};\r\n\r\nTayberry.getDataXValue = function (data, index) {\r\n    let ret;\r\n    if (Array.isArray(data[index])) {\r\n        ret = data[index][0];\r\n    } else {\r\n        ret = index;\r\n    }\r\n    return ret;\r\n};\r\n\r\nTayberry.setDataValue = function (data, index, newValue) {\r\n    if (Array.isArray(data[index])) {\r\n        data[index][1] = newValue;\r\n    } else {\r\n        data[index] = newValue;\r\n    }\r\n};\r\n\r\nTayberry.prototype.createCanvas = function () {\r\n    let ret = document.createElement('canvas');\r\n    // IE11 hack-fix - clientWidth sometimes incorrect on first access\r\n    ret.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\r\n    ret.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\r\n    ret.style.height = Math.floor(this.containerElement.clientHeight) + 'px';\r\n    ret.style.position = 'absolute';\r\n    this.containerElement.appendChild(ret);\r\n    return ret;\r\n};\r\n\r\nTayberry.prototype.create = function (containerElement) {\r\n    if (typeof containerElement == 'string') {\r\n        this.containerElement = document.getElementById(containerElement);\r\n    } else {\r\n        this.containerElement = containerElement;\r\n    }\r\n    this.labelsCanvas = this.createCanvas();\r\n    this.labelsCtx = this.labelsCanvas.getContext('2d');\r\n    this.plotCanvas = this.createCanvas();\r\n    this.plotCtx = this.plotCanvas.getContext('2d');\r\n    this.options = {};\r\n    this.yAxes = null;\r\n    this.xAxes = null;\r\n    this.initialise();\r\n};\r\n\r\nTayberry.prototype.destroy = function () {\r\n    this.labelsCanvas.parentNode.removeChild(this.labelsCanvas);\r\n    this.tooltipElement.parentNode.removeChild(this.tooltipElement);\r\n    this.options = {};\r\n    this.plotCanvas.removeEventListener('click', this.onClickReal);\r\n    this.plotCanvas.removeEventListener('mousemove', this.onMouseMoveReal);\r\n    this.plotCanvas.removeEventListener('mouseleave', this.onMouseLeaveReal);\r\n    // this.plotCanvas.removeEventListener('touchstart', this.onTouchStartReal);\r\n    window.removeEventListener('resize', this.onWindowResizeReal);\r\n};\r\n\r\nTayberry.prototype.initialise = function () {\r\n    this.scaleFactor = window.devicePixelRatio || 1.0;\r\n    this.labelsCanvas.width = Math.round(this.labelsCanvas.clientWidth * this.scaleFactor);\r\n    this.labelsCanvas.height = Math.round(this.labelsCanvas.clientHeight * this.scaleFactor);\r\n    this.plotCanvas.width = this.labelsCanvas.width;\r\n    this.plotCanvas.height = this.labelsCanvas.height;\r\n    this.scaleFactorX = this.labelsCanvas.width / this.labelsCanvas.clientWidth;\r\n    this.scaleFactorY = this.labelsCanvas.height / this.labelsCanvas.clientHeight;\r\n    this.selectedItem = {};\r\n    this.plotArea = null;\r\n};\r\n\r\nTayberry.prototype.getFontHeight = function (font, forDom) {\r\n    let ret = font.size;\r\n    if (font.autoScale)\r\n        ret *= Math.pow(this.labelsCanvas.width / 800, 0.25);\r\n    if (!forDom) ret = this.mapLogicalYUnit(ret);\r\n    return ret;\r\n};\r\n\r\nTayberry.prototype.createFontString = function (font, forDom) {\r\n    return (font.style ? font.style + ' ' : '') + this.getFontHeight(font, forDom).toFixed(1) + 'px ' + font.face;\r\n};\r\n\r\nTayberry.prototype.updateFonts = function () {\r\n    //this.labelsCtx.font = this.createFontString(this.options.font);\r\n    this.titleFont = this.createFontString(this.options.title.font);\r\n    this.labelFont = this.createFontString(this.options.labels.font);\r\n    this.legend.updateFonts();\r\n    this.yAxes.map(e => e.updateFonts());\r\n    this.xAxes.map(e => e.updateFonts());\r\n};\r\n\r\nTayberry.prototype.setOptions = function (options) {\r\n    let optionOverrides = [this.defaultOptions()];\r\n    if (!options.presets) {\r\n        options.presets = ['default'];\r\n    }\r\n    if (options.presets) {\r\n        for (let index = 0; index < options.presets.length; index++) {\r\n            optionOverrides.push(Tayberry.presets[options.presets[index]]);\r\n        }\r\n    }\r\n    optionOverrides.push(options);\r\n    this.options = Utils.deepAssign({}, optionOverrides);\r\n    this.options.title.font = Utils.deepAssign({}, [this.options.font, this.options.title.font]);\r\n    this.options.tooltips.font = Utils.deepAssign({}, [this.options.font, this.options.tooltips.font]);\r\n    this.options.labels.font = Utils.deepAssign({}, [this.options.font, this.options.labels.font]);\r\n    this.options.legend.font = Utils.deepAssign({}, [this.options.font, this.options.legend.font]);\r\n    this.options.allAxes.font = Utils.deepAssign({}, [this.options.font, this.options.allAxes.font]);\r\n    this.options.allAxes.title.font = Utils.deepAssign({}, [this.options.font, this.options.allAxes.title.font]);\r\n    if (!Array.isArray(this.options.yAxis))\r\n        this.options.yAxis = [this.options.yAxis || {}];\r\n    if (!Array.isArray(this.options.xAxis))\r\n        this.options.xAxis = [this.options.xAxis || {}];\r\n    for (let i = 0; i < this.options.yAxis.length; i++) {\r\n        this.options.yAxis[i] = Utils.deepAssign({}, [i === 0 ? Tayberry.defaultPrimaryYAxis : Tayberry.defaultSecondaryYAxis, this.options.allAxes, this.options.yAxis[i]]);\r\n    }\r\n    for (let i = 0; i < this.options.xAxis.length; i++) {\r\n        this.options.xAxis[i] = Utils.deepAssign({}, [Tayberry.defaultXAxis, this.options.allAxes, this.options.xAxis[i]]);\r\n    }\r\n    for (let i = 0; i < this.options.series.length; i++) {\r\n        this.options.series[i] = Utils.deepAssign({}, [Tayberry.defaultSeries, this.options.series[i]]);\r\n    }\r\n\r\n    this.yAxes = [];\r\n    this.xAxes = [];\r\n    for (let i = 0; i < this.options.xAxis.length; i++) {\r\n        this.xAxes.push(Axis.create(this, this.options.xAxis[i], i, 'x', this.options.swapAxes));\r\n    }\r\n    for (let i = 0; i < this.options.yAxis.length; i++) {\r\n        this.yAxes.push(Axis.create(this, this.options.yAxis[i], i, 'y', this.options.swapAxes));\r\n    }\r\n    this.legend = new Legend(this);\r\n    this.updateFonts();\r\n    this.createRenderers();\r\n    this.calculatePlotArea();\r\n    this.callbacks['onInit'].forEach(func => func());\r\n    this.plotCanvas.addEventListener('click', this.onClickReal = this.onClick.bind(this));\r\n    this.plotCanvas.addEventListener('mousemove', this.onMouseMoveReal = this.onMouseMove.bind(this));\r\n    this.plotCanvas.addEventListener('mouseleave', this.onMouseLeaveReal = this.onMouseLeave.bind(this));\r\n    //this.plotCanvas.addEventListener('touchstart', this.onTouchStartReal = this.onTouchStart.bind(this));\r\n    window.addEventListener('resize', this.onWindowResizeReal = Utils.throttle(this.onWindowResize, 50).bind(this));\r\n};\r\n\r\nTayberry.calculateHighlightColour = function (colour) {\r\n    let newColour = new Colour(colour);\r\n    return newColour.increaseBy(30 * (newColour.sum >= 180 * 3 ? -1 : 1)).toString();\r\n};\r\n\r\nTayberry.calculateGlowColour = function (highlightColour) {\r\n    let newColour = new Colour(highlightColour);\r\n    newColour.a = 0.4;\r\n    return newColour.toString();\r\n};\r\n\r\nTayberry.prototype.createRenderers = function () {\r\n    let series, groupedSeries = {'bar': [], 'line': []};\r\n    if (!Array.isArray(this.options.series)) {\r\n        series = [this.options.series];\r\n    } else {\r\n        series = this.options.series;\r\n    }\r\n\r\n    for (let i = 0; i < series.length; i++) {\r\n        const curSeries = series[i];\r\n        curSeries.index = i;\r\n        curSeries.colour = curSeries.colour || Tayberry.getAutoColour();\r\n        curSeries.highlightColour = curSeries.highlightColour || Tayberry.calculateHighlightColour(curSeries.colour);\r\n        curSeries.glowColour = curSeries.glowColour || Tayberry.calculateGlowColour(curSeries.highlightColour);\r\n        curSeries.rState = {\r\n            colour: curSeries.colour,\r\n            highlightColour: curSeries.highlightColour,\r\n            glowColour: curSeries.glowColour\r\n        };\r\n        curSeries.xAxis = this.xAxes[curSeries.xAxisIndex || 0];\r\n        curSeries.yAxis = this.yAxes[curSeries.yAxisIndex || 0];\r\n        curSeries.plotType = curSeries.plotType || this.options.plotType;\r\n        if (groupedSeries.hasOwnProperty(curSeries.plotType)) {\r\n            groupedSeries[curSeries.plotType].push(curSeries);\r\n        }\r\n    }\r\n    if (groupedSeries['bar'].length) {\r\n        this.renderers.push(new BarRenderer(this.plotCtx, this, groupedSeries['bar']));\r\n    }\r\n    if (groupedSeries['line'].length) {\r\n        this.renderers.push(new LineRenderer(this.plotCtx, this, groupedSeries['line']));\r\n    }\r\n};\r\n\r\nTayberry.prototype.getDataMinMax = function (axis) {\r\n    var minNormal, maxNormal, minStacked, maxStacked;\r\n    if (this.options.barPlot.mode === 'stacked') {\r\n        let seriesPositiveTotals = [];\r\n        let seriesNegativeTotals = [];\r\n        const barSeries = this.options.series.filter(series => series.plotType === 'bar' && series.yAxis === axis);\r\n        if (barSeries.length) {\r\n            for (let categoryIndex = 0; categoryIndex < barSeries[0].data.length; categoryIndex++) {\r\n                seriesPositiveTotals[categoryIndex] = 0;\r\n                seriesNegativeTotals[categoryIndex] = 0;\r\n                for (let seriesIndex = 0; seriesIndex < barSeries.length; seriesIndex++) {\r\n                    const value = Tayberry.getDataValue(barSeries[seriesIndex].data[categoryIndex]);\r\n                    if (!Utils.isMissingValue(value)) {\r\n                        if (value < 0) {\r\n                            seriesNegativeTotals[categoryIndex] += value;\r\n                        } else {\r\n                            seriesPositiveTotals[categoryIndex] += value;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        minStacked = Math.min(0, Utils.reduce(seriesNegativeTotals, Math.min, undefined, true));\r\n        maxStacked = Math.max(Utils.reduce(seriesPositiveTotals, Math.max, undefined, true), 0);\r\n    }\r\n    {\r\n        let seriesMinima = [];\r\n        let seriesMaxima = [];\r\n        for (let index = 0; index < this.options.series.length; index++) {\r\n            const series = this.options.series[index];\r\n            if (series.yAxis === axis && (series.plotType !== 'bar' || this.options.barPlot.mode !== 'stacked')) {\r\n                seriesMinima.push(Utils.reduce(series.data, Math.min, Tayberry.getDataValue, true));\r\n                seriesMaxima.push(Utils.reduce(series.data, Math.max, Tayberry.getDataValue, true));\r\n            }\r\n        }\r\n        minNormal = Utils.reduce(seriesMinima, Math.min, undefined, true);\r\n        maxNormal = Utils.reduce(seriesMaxima, Math.max, undefined, true);\r\n    }\r\n    const min = Utils.reduce([minNormal, minStacked], Math.min, undefined, true);\r\n    const max = Utils.reduce([maxNormal, maxStacked], Math.max, undefined, true);\r\n    return [min, max];\r\n};\r\n\r\nTayberry.prototype.getDataXMinMax = function (axis) {\r\n    var min, max;\r\n    const seriesMinima = [];\r\n    const seriesMaxima = [];\r\n    for (let index = 0; index < this.options.series.length; index++) {\r\n        const series = this.options.series[index];\r\n        if (series.xAxis === axis) {\r\n            seriesMinima.push(Utils.reduce(series.data, Math.min, Tayberry.getDataXValue, true));\r\n            seriesMaxima.push(Utils.reduce(series.data, Math.max, Tayberry.getDataXValue, true));\r\n        }\r\n    }\r\n    min = Utils.reduce(seriesMinima, Math.min, undefined, true);\r\n    max = Utils.reduce(seriesMaxima, Math.max, undefined, true);\r\n    return [min, max];\r\n};\r\n\r\n\r\nTayberry.prototype.createTooltip = function () {\r\n    if (this.tooltipElement) {\r\n        this.tooltipElement.parentNode.removeChild(this.tooltipElement);\r\n        this.tooltipElement = null;\r\n    }\r\n    this.tooltipElement = document.createElement('div');\r\n    this.tooltipElement.className = 'tayberry-tooltip';\r\n    this.tooltipElement.style.position = 'absolute';\r\n    this.tooltipElement.style.left = '0px';\r\n    this.tooltipElement.style.top = '0px';\r\n    this.tooltipElement.style.zIndex = '99999';\r\n    this.tooltipElement.style.font = this.createFontString(this.options.tooltips.font, true);\r\n    this.tooltipElement.style.borderRadius = '3px';\r\n    this.tooltipElement.style.backgroundColor = 'white';\r\n    this.tooltipElement.style.border = '2px solid #bbb';\r\n    this.tooltipElement.style.padding = '0.15em 0.4em';\r\n    this.tooltipElement.style.display = 'none';\r\n    this.tooltipElement.innerHTML = '';\r\n    document.body.appendChild(this.tooltipElement);\r\n    this.tooltipElement.addEventListener('mousemove', this.onMouseMove.bind(this));\r\n    this.tooltipElement.addEventListener('mouseleave', this.onMouseLeave.bind(this));\r\n};\r\n","'use strict';\r\nimport {Tayberry} from './base';\r\nimport {Rect} from './helpers/rect';\r\n\r\nTayberry.prototype.getTextWidth = function (text, fontString) {\r\n    let ret;\r\n    if (fontString) {\r\n        this.labelsCtx.save();\r\n        this.labelsCtx.font = fontString;\r\n    }\r\n    ret = this.labelsCtx.measureText(text).width;\r\n    if (fontString) {\r\n        this.labelsCtx.restore();\r\n    }\r\n    return ret;\r\n};\r\n\r\nTayberry.prototype.getMultilineTextHeight = function (fontString, maxWidth, text) {\r\n    let ret;\r\n    if (fontString) {\r\n        this.labelsCtx.save();\r\n        this.labelsCtx.font = fontString;\r\n    }\r\n    ret = this.splitMultilineText(maxWidth, text).length;\r\n    if (fontString) {\r\n        this.labelsCtx.restore();\r\n    }\r\n    return ret;\r\n};\r\n\r\n\r\nTayberry.prototype.splitMultilineText = function (maxWidth, text) {\r\n    let lines = [];\r\n    let lineWidth = 0;\r\n    let lineText = '';\r\n    const spaceWidth = this.labelsCtx.measureText(' ').width;\r\n    for (let i = 0; i < text.length;) {\r\n        const wordStart = i;\r\n        while (i < text.length && text[i] !== ' ' && text[i] !== '\\r' && text[i] !== '\\n') i++;\r\n        const wordEnd = i;\r\n        while (i < text.length && (text[i] === ' ' || text[i] === '\\r' || text[i] === '\\n')) i++;\r\n        if (wordEnd > wordStart) {\r\n            const word = text.substring(wordStart, wordEnd);\r\n            const wordWidth = this.labelsCtx.measureText(word).width;\r\n            if (lineWidth + wordWidth > maxWidth) {\r\n                if (!lineWidth) {\r\n                    lineText = word;\r\n                }\r\n                lines.push(lineText);\r\n                if (lineWidth) {\r\n                    lineWidth = 0;\r\n                    lineText = word;\r\n                }\r\n            } else {\r\n                lineText += (lineText ? ' ' : '') + word;\r\n                lineWidth += wordWidth + spaceWidth;\r\n            }\r\n        }\r\n    }\r\n    if (lineText) {\r\n        lines.push(lineText);\r\n    }\r\n    return lines;\r\n};\r\n\r\nTayberry.prototype.drawTextMultiline = function (lineHeight, x, y, maxWidth, text) {\r\n    let lines = this.splitMultilineText(maxWidth, text);\r\n\r\n    for (let i = 0; i < lines.length; i++) {\r\n        let line = lines[i];\r\n        this.labelsCtx.fillText(line, x, y + lineHeight * i);\r\n    }\r\n};\r\n\r\nTayberry.prototype.render = function () {\r\n    this.drawLabelLayer();\r\n    this.createTooltip();\r\n    if (this.options.animations.enabled) {\r\n        for (let index = 0; index < this.options.series.length; index++) {\r\n            const series = this.options.series[index];\r\n            this.setSeriesVisibility(series, true, 'height');\r\n        }\r\n    } else {\r\n        this.drawPlotLayer();\r\n    }\r\n};\r\n\r\nTayberry.prototype.clear = function (plot = true, labels = true) {\r\n    if (plot) this.plotCtx.clearRect(0, 0, this.plotCanvas.width, this.plotCanvas.height);\r\n    if (labels) this.labelsCtx.clearRect(0, 0, this.labelsCanvas.width, this.labelsCanvas.height);\r\n};\r\n\r\nTayberry.prototype.drawBackground = function () {\r\n    if (this.options.plotBackgroundColour) {\r\n        this.labelsCtx.save();\r\n        this.labelsCtx.fillStyle = this.options.plotBackgroundColour;\r\n        this.labelsCtx.fillRect(this.plotArea.left, this.plotArea.top, this.plotArea.width, this.plotArea.height);\r\n        this.labelsCtx.restore();\r\n    }\r\n};\r\n\r\nTayberry.prototype.drawTitle = function () {\r\n    if (this.options.title.text) {\r\n        const x = (this.labelsCanvas.width) / 2, y = 0;\r\n        this.labelsCtx.save();\r\n        this.labelsCtx.textAlign = 'center';\r\n        this.labelsCtx.textBaseline = 'top';\r\n        this.labelsCtx.font = this.titleFont;\r\n        this.labelsCtx.fillStyle = this.options.title.font.colour;\r\n        this.drawTextMultiline(this.getFontHeight(this.options.title.font), x, y, this.labelsCanvas.width, this.options.title.text);\r\n        // this.labelsCtx.fillText(this.options.title.text, x, y);\r\n        this.labelsCtx.restore();\r\n    }\r\n};\r\n\r\nTayberry.prototype.drawPlotLayer = function () {\r\n    for (let i = 0; i < this.renderers.length; i++) {\r\n        this.renderers[i].drawPlot();\r\n    }\r\n    for (let i = 0; i < this.renderers.length; i++) {\r\n        this.renderers[i].drawLabels();\r\n    }\r\n};\r\n\r\n\r\nTayberry.prototype.drawLine = function (x1, y1, x2, y2, colour, ctx = this.labelsCtx) {\r\n    ctx.save();\r\n    if (colour) {\r\n        ctx.strokeStyle = colour;\r\n    }\r\n    ctx.beginPath();\r\n    ctx.moveTo(x1 + 0.5, y1 + 0.5);\r\n    ctx.lineTo(x2 + 0.5, y2 + 0.5);\r\n    ctx.stroke();\r\n    ctx.restore();\r\n};\r\n\r\nTayberry.prototype.drawLabelLayer = function () {\r\n    this.drawBackground();\r\n    this.drawTitle();\r\n    let offsetRect = new Rect(0);\r\n    this.xAxes.map(e => e.draw(offsetRect));\r\n    this.yAxes.map(e => e.draw(offsetRect));\r\n    this.legend.draw();\r\n};\r\n\r\nTayberry.prototype.redraw = function (plotOnly) {\r\n    this.clear(true, !plotOnly);\r\n    if (!plotOnly) {\r\n        this.drawLabelLayer();\r\n    }\r\n    this.drawPlotLayer();\r\n};\r\n\r\n","'use strict';\r\nimport {Rect} from './helpers/rect';\r\nimport * as Utils from './helpers/utils.js';\r\n\r\nimport {Tayberry} from './base';\r\n\r\nTayberry.prototype.registerCallback = function (eventName, func) {\r\n    this.callbacks[eventName].push(func);\r\n};\r\n\r\nTayberry.prototype.onMouseLeave = function (event) {\r\n    if ((event.currentTarget == this.plotCanvas && event.relatedTarget !== this.tooltipElement) || (event.currentTarget == this.tooltipElement && event.relatedTarget !== this.plotCanvas)) {\r\n        this.selectedItem = {};\r\n        this.tooltipElement.style.display = 'none';\r\n        this.redraw();\r\n    }\r\n};\r\n\r\nTayberry.prototype.handleMouseMove = function (clientX, clientY) {\r\n    let boundingRect = new Rect(this.plotCanvas.getBoundingClientRect());\r\n    let ret = false;\r\n    let tooltipDisplayStyleSet = false;\r\n    if (boundingRect.containsPoint(clientX, clientY)) {\r\n        let x = clientX - boundingRect.left;\r\n        let y = clientY - boundingRect.top;\r\n\r\n        let hitTestResult = this.hitTest(this.mapLogicalXUnit(x), this.mapLogicalYUnit(y));\r\n        if (hitTestResult.found) {\r\n            if (hitTestResult.type === 'legend') {\r\n                this.selectedItem = hitTestResult;\r\n                ret = true;\r\n            } else if (hitTestResult.type === 'plotItem') {\r\n                let tooltipHtml = '';\r\n                const aboveZero = hitTestResult.rect.top < hitTestResult.rect.bottom;\r\n                this.tooltipElement.style.display = 'block';\r\n                tooltipDisplayStyleSet = true;\r\n                if (this.options.tooltips.shared) {\r\n                    const category = this.xAxes[0].getCategoryLabel(hitTestResult.categoryIndex, this.categoryCount, hitTestResult.isXRange);\r\n                    tooltipHtml += Utils.formatString(this.options.tooltips.headerTemplate, {category: category}, true);\r\n                    for (let index = 0; index < this.seriesCount; index++) {\r\n                        const series = this.options.series[index];\r\n                        const value = Tayberry.getDataValue(series.data[hitTestResult.categoryIndex]);\r\n                        tooltipHtml += Utils.formatString(this.options.tooltips.valueTemplate, {\r\n                            value: series.yAxis.options.labelFormatter(value),\r\n                            name: series.name,\r\n                            colour: series.colour\r\n                        }, true);\r\n                    }\r\n                } else {\r\n                    const series = hitTestResult.series;\r\n                    const value = hitTestResult.value;\r\n                    const category = series.xAxis.getCategoryLabel(hitTestResult.categoryIndex, this.categoryCount, hitTestResult.isXRange);\r\n                    tooltipHtml += Utils.formatString(this.options.tooltips.headerTemplate, {category: category}, true);\r\n                    tooltipHtml += Utils.formatString(this.options.tooltips.valueTemplate, {\r\n                        value: series.yAxis.options.labelFormatter(value),\r\n                        name: series.name,\r\n                        colour: series.colour\r\n                    }, true);\r\n                }\r\n                tooltipHtml += this.options.tooltips.footerTemplate;\r\n                this.tooltipElement.innerHTML = tooltipHtml;\r\n                let tooltipRect = this.tooltipElement.getBoundingClientRect();\r\n                if (!this.options.tooltips.shared) {\r\n                    this.tooltipElement.style.borderColor = hitTestResult.series.colour;\r\n                }\r\n                this.tooltipElement.style.left = window.pageXOffset + boundingRect.left + this.mapScreenUnit(hitTestResult.rect.width) / 2 + hitTestResult.rect.left / this.scaleFactor - tooltipRect.width / 2 + 'px';\r\n                this.tooltipElement.style.top = window.pageYOffset + boundingRect.top + this.mapScreenUnit(hitTestResult.rect.top) - tooltipRect.height * (aboveZero ? 1 : 0) - this.options.elementSmallPadding * (aboveZero ? 1 : -1) + 'px';\r\n                this.selectedItem = hitTestResult;\r\n                ret = true;\r\n            }\r\n        }\r\n    }\r\n    if (!tooltipDisplayStyleSet)\r\n        this.tooltipElement.style.display = 'none';\r\n    return ret;\r\n};\r\n\r\n\r\n//Tayberry.prototype.onTouchStart = function (event) {\r\n//    for (let index = 0; index < event.targetTouches.length; index++) {\r\n//        let touch = event.targetTouches[index];\r\n//        if (this.handleMouseMove(touch.clientX, touch.clientY)) {\r\n//            // event.preventDefault();\r\n//            this.redraw();\r\n//            break;\r\n//        }\r\n//    }\r\n//};\r\n\r\nTayberry.prototype.onClick = function (event) {\r\n    let boundingRect = new Rect(this.plotCanvas.getBoundingClientRect());\r\n    // Why is event.buttons always 0?\r\n    if ((event.button === 0) && boundingRect.containsPoint(event.clientX, event.clientY)) {\r\n        let x = event.clientX - boundingRect.left;\r\n        let y = event.clientY - boundingRect.top;\r\n        let hitTestResult = this.hitTest(this.mapLogicalXUnit(x), this.mapLogicalYUnit(y));\r\n        if (hitTestResult.found) {\r\n            if (hitTestResult.type === 'legend') {\r\n                const series = hitTestResult.data.series;\r\n\r\n                this.toggleSeriesVisibility(series);\r\n                this.clear(false, true);\r\n                this.drawLabelLayer();\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nTayberry.prototype.onMouseMove = function (event) {\r\n    let oldSelectedItem = Utils.assign({}, this.selectedItem);\r\n    if (!this.handleMouseMove(event.clientX, event.clientY)) {\r\n        this.selectedItem = {};\r\n    }\r\n\r\n    if (oldSelectedItem.type !== this.selectedItem.type ||\r\n        oldSelectedItem.categoryIndex !== this.selectedItem.categoryIndex ||\r\n        oldSelectedItem.series !== this.selectedItem.series) {\r\n        this.redraw();\r\n    }\r\n};\r\n\r\nTayberry.prototype.onWindowResize = function () {\r\n    this.tooltipElement.style.display = 'none';\r\n    this.labelsCanvas.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\r\n    this.labelsCanvas.style.height = Math.floor(this.containerElement.clientHeight) + 'px';\r\n    this.plotCanvas.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\r\n    this.plotCanvas.style.height = Math.floor(this.containerElement.clientHeight) + 'px';\r\n    this.initialise();\r\n    this.updateFonts();\r\n    this.calculatePlotArea();\r\n    this.createTooltip();\r\n    this.callbacks['onResize'].forEach(func => func());\r\n    this.redraw();\r\n};\r\n","'use strict';\r\nimport {Tayberry} from './base';\r\nimport * as Utils from './helpers/utils.js';\r\nimport * as constants from './constants';\r\n\r\nTayberry.prototype.defaultOptions = function () {\r\n    return {\r\n        title: {\r\n            text: '',\r\n            font: {\r\n                size: 20\r\n            }\r\n        },\r\n        font: {\r\n            colour: '#444',\r\n            size: 12,\r\n            face: 'sans-serif',\r\n            style: '',\r\n            autoScale: true\r\n        },\r\n        allAxes: {\r\n            font: {},\r\n            title: {\r\n                font: {}\r\n            }\r\n        },\r\n        xAxis: [],\r\n        yAxis: [],\r\n        animations: {\r\n            enabled: true\r\n        },\r\n        series: [],\r\n        backgroundColour: undefined,\r\n        swapAxes: false,\r\n        plotType: 'bar',\r\n        barPlot: {\r\n            mode: 'normal', //[normal|stacked|overlaid]\r\n            barPadding: 2,\r\n            categorySpacing: 0.3\r\n        },\r\n        linePlot: {\r\n            lineWidth: 2,\r\n            highlightedLineWidth: 4,\r\n            showMarkers: 'auto',\r\n            noMarkersThreshold: 100,\r\n            markerSize: 10,\r\n            highlightedMarkerSize: 18\r\n        },\r\n        elementSmallPadding: 5,\r\n        elementLargePadding: 10,\r\n        presets: [],\r\n        tooltips: {\r\n            shared: false,\r\n            headerTemplate: '<strong>{category}</strong><table>',\r\n            valueTemplate: '<tr><td style=\"padding-right: 0.5em\"><span style=\"color: {colour}\">\\u25CF</span> {name}</td><td style=\"text-align: right\">{value}</td></tr>',\r\n            footerTemplate: '</table>',\r\n            font: {}\r\n        },\r\n        legend: {\r\n            enabled: true,\r\n            indicatorSize: 15,\r\n            font: {},\r\n            hiddenAlphaMultiplier: 0.5,\r\n            placement: 'bottom'\r\n        },\r\n        labels: {\r\n            enabled: false,\r\n            verticalAlignment: 'top',\r\n            verticalPosition: 'outside',\r\n            font: {}\r\n        }\r\n    }\r\n};\r\n\r\nTayberry.defaultSeries = {\r\n    visible: constants.visibilityState.visible\r\n};\r\n\r\nTayberry.defaultXAxis = {\r\n    title: {\r\n        text: '',\r\n        font: {}\r\n    },\r\n    type: 'categorial',\r\n    min: null,\r\n    max: null,\r\n    tickStep: 40,\r\n    tickStepValue: null,\r\n    font: {},\r\n    categories: [],\r\n    labelPosition: 'middle', //left|middle|right\r\n    placement: 'auto',\r\n    gridLines: {}\r\n};\r\n\r\nTayberry.defaultYAxis = {\r\n    title: {\r\n        text: '',\r\n        font: {}\r\n    },\r\n    min: undefined,\r\n    max: undefined,\r\n    tickStep: 40,\r\n    tickStepValue: null,\r\n    font: {},\r\n    labelFormat: 'number', //[number|percentage|currency],\r\n    labelFormatter: undefined,\r\n    labelPrefix: undefined,\r\n    labelSuffix: undefined,\r\n    currencySymbol: '£',\r\n    placement: 'auto',\r\n    type: 'linear',\r\n    gridLines: {}\r\n\r\n};\r\n\r\nTayberry.defaultPrimaryYAxis = Utils.deepAssign({}, [Tayberry.defaultYAxis, {\r\n    gridLines: {\r\n        colour: '#ccc'\r\n    }\r\n}]);\r\n\r\nTayberry.defaultSecondaryYAxis = Tayberry.defaultYAxis;\r\n\r\nTayberry.presets = {\r\n    histogram: {\r\n        barPlot: {\r\n            mode: 'overlaid',\r\n            categorySpacing: 0,\r\n            barPadding: 1\r\n        }\r\n    },\r\n    darkGrid: {\r\n        allAxes: {\r\n            gridLines: {\r\n                colour: 'rgba(255, 255, 255, 0.6)'\r\n            }\r\n        },\r\n        plotBackgroundColour: '#E5E5E5'\r\n    }\r\n};\r\n\r\nTayberry.defaultColours = [\r\n    '#6FE87B', //green\r\n    '#FFAB51', //orange\r\n    '#51A8FF', //blue\r\n    '#B651FF', //purple\r\n    '#FF6051', //red\r\n    '#636363', //dark grey\r\n    '#FFE314', //yellow\r\n    '#A88572', //brown\r\n    '#B7B7B7' //light grey\r\n];\r\n","'use strict';\r\nimport {Rect} from './helpers/rect';\r\nimport {Tayberry} from './base';\r\nimport * as Utils from './helpers/utils.js';\r\n\r\nTayberry.mapVerticalPosition = function (sign, position) {\r\n    switch (position) {\r\n        case \"outside\":\r\n            return sign > 0 ? \"bottom\" : \"top\";\r\n        case \"inside\":\r\n            return sign > 0 ? \"top\" : \"bottom\";\r\n        default:\r\n            return \"middle\";\r\n    }\r\n};\r\n\r\nTayberry.prototype.mapLogicalXUnit = function (x) {\r\n    return this.scaleFactorX * x;\r\n};\r\n\r\nTayberry.prototype.mapLogicalYUnit = function (x) {\r\n    return this.scaleFactorY * x;\r\n};\r\n\r\nTayberry.prototype.mapScreenUnit = function (x) {\r\n    return x / this.scaleFactor;\r\n};\r\n\r\nTayberry.prototype.calculatePlotArea = function () {\r\n    const MAX_AXIS_CALC_SIZE_ATTEMPTS = 5;\r\n\r\n    this.plotArea = new Rect(0, 0, this.labelsCanvas.width, this.labelsCanvas.height);\r\n    if (this.options.title.text) {\r\n        this.plotArea.top += this.mapLogicalYUnit(this.options.elementSmallPadding);\r\n        this.plotArea.top += this.getFontHeight(this.options.title.font) * this.getMultilineTextHeight(this.titleFont, this.labelsCanvas.width, this.options.title.text);\r\n    }\r\n\r\n    this.legend.adjustSize(this.plotArea, true);\r\n\r\n    this.yAxes.map(e => e.adjustSize(this.plotArea, true, true));\r\n    this.xAxes.map(e => e.adjustSize(this.plotArea, true, true));\r\n\r\n    for (let i = 0; i < MAX_AXIS_CALC_SIZE_ATTEMPTS; i++) {\r\n        this.yAxes.map(e => e.calculateExtent());\r\n        this.xAxes.map(e => e.calculateExtent());\r\n        this.yAxes.map(e => e.updateFormatter());\r\n        this.xAxes.map(e => e.updateFormatter());\r\n        if (Utils.none(this.yAxes.map(e => e.adjustSize(this.plotArea))) && Utils.none(this.xAxes.map(e => e.adjustSize(this.plotArea))) && !this.legend.adjustSize(this.plotArea))\r\n            break;\r\n    }\r\n    this.plotArea.left = Math.ceil(this.plotArea.left);\r\n    this.plotArea.top = Math.ceil(this.plotArea.top);\r\n    this.plotArea.right = Math.floor(this.plotArea.right);\r\n    this.plotArea.bottom = Math.floor(this.plotArea.bottom);\r\n};\r\n\r\nTayberry.prototype.hitTest = function (x, y) {\r\n    let ret = {\r\n        found: false\r\n    };\r\n    let matches = [];\r\n    if (this.plotArea.containsPoint(x, y)) {\r\n        for (let i = 0; i < this.renderers.length; i++) {\r\n            const hitTestResult = this.renderers[i].hitTest(x, y);\r\n            if (hitTestResult.found) {\r\n                matches.push(hitTestResult);\r\n            }\r\n        }\r\n    }\r\n    matches.push(this.legend.hitTest(x, y));\r\n    if (matches.length) {\r\n        matches.sort((a, b) => !a.found - !b.found || a.normalisedDistance - b.normalisedDistance);\r\n        ret = matches[0];\r\n    }\r\n    return ret;\r\n};\r\n\r\n","'use strict';\r\nimport {Tayberry} from './base';\r\nimport * as Utils from './helpers/utils.js';\r\nimport * as constants from './constants';\r\n\r\nTayberry.prototype.revokeAnimation = function (series) {\r\n    for (let index = this.pendingAnimations.length; index; index--) {\r\n        if (this.pendingAnimations[index-1].series === series) {\r\n            this.pendingAnimations.splice(index-1, 1);\r\n        }\r\n    }\r\n};\r\n\r\nTayberry.prototype.startAnimation = function (animation) {\r\n    animation.initialStage = animation.initialStage || 0;\r\n    var newAnimation = Utils.assign({}, [{\r\n        length: 500*(1-animation.initialStage),\r\n        startTime: (typeof performance !== 'undefined' && typeof performance.now !== 'undefined') ? performance.now() : null\r\n    },\r\n        animation\r\n    ]);\r\n    this.pendingAnimations.push(newAnimation);\r\n    if (!this.animator)\r\n        this.animator = requestAnimationFrame(this.onAnimate.bind(this));\r\n    return newAnimation;\r\n};\r\n\r\nTayberry.prototype.onAnimate = function (timestamp) {\r\n    var elapsed;\r\n    for (let index = this.pendingAnimations.length - 1; index >= 0; index--) {\r\n        let animation = this.pendingAnimations[index];\r\n        if (animation.startTime === null) {\r\n            animation.startTime = timestamp;\r\n        }\r\n        elapsed = timestamp - animation.startTime;\r\n        if (animation.onFrame) {\r\n            animation.onFrame(animation.initialStage + Math.min(elapsed / animation.length, 1) * (1 - animation.initialStage));\r\n        }\r\n        if (elapsed >= animation.length) {\r\n            this.pendingAnimations.splice(index, 1);\r\n            if (animation.onCompletion) {\r\n                animation.onCompletion();\r\n            }\r\n        }\r\n    }\r\n    for (let i = 0; i < this.renderers.length; i++) {\r\n        this.renderers[i].onAnimationFrame();\r\n    }\r\n    this.redraw(true);\r\n    if (this.pendingAnimations.length) {\r\n        this.animator = requestAnimationFrame(this.onAnimate.bind(this));\r\n    } else {\r\n        this.animator = null;\r\n    }\r\n};\r\n\r\nTayberry.prototype.setSeriesVisibility = function(series, visible, subtype) {\r\n    series.visible = visible ? constants.visibilityState.visible : constants.visibilityState.hidden;\r\n    series.visible |= constants.visibilityState.transitioning;\r\n\r\n    if (series.animationState) {\r\n        const newType = visible ? 'show' : 'hide';\r\n        if (series.animationState.type !== newType) {\r\n            series.animationState.type = newType;\r\n            series.animationState.stage = 1 - series.animationState.stage;\r\n\r\n            delete series.animationState.animator;\r\n            this.revokeAnimation(series);\r\n        }\r\n    } else {\r\n        series.animationState = {\r\n            type: (series.visible & constants.visibilityState.visible) ? 'show' : 'hide',\r\n            subtype: subtype,\r\n            stage: 0\r\n        };\r\n    }\r\n    if (!series.animationState.animator) {\r\n        series.animationState.animator = this.startAnimation({\r\n            type: visible ? 'showSeries' : 'hideSeries',\r\n            series: series,\r\n            initialStage: series.animationState.stage,\r\n            onFrame: (stage) => series.animationState.stage = stage,\r\n            onCompletion: () => {\r\n                series.visible = (series.visible & ~constants.visibilityState.transitioning);\r\n                delete series.animationState;\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\nTayberry.prototype.toggleSeriesVisibility = function(series) {\r\n    this.setSeriesVisibility(series, !(series.visible & constants.visibilityState.visible))\r\n};\r\n","import {Tayberry as TayberryBase} from './base';\r\nimport './axis';\r\nimport './core';\r\nimport './drawing';\r\nimport './events';\r\nimport './defaults';\r\nimport './sizing';\r\nimport './legend';\r\nimport './animation';\r\nimport './renderer.base';\r\nimport './renderer.bar';\r\nimport './renderer.line';\r\n\r\n\r\nlet Tayberry = {\r\n    /**\r\n     * Creates a Tayberry chart\r\n     *\r\n     * @param element   ID of container div, or HTMLElement\r\n     * @param options   Options object\r\n     */\r\n    create: function (element, options) {\r\n        let chart = new TayberryBase();\r\n        chart.create(element);\r\n        chart.setOptions(options);\r\n        chart.render();\r\n    }\r\n};\r\n\r\nexport default Tayberry;"],"sourceRoot":"/source/"}