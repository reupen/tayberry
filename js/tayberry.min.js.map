{"version":3,"sources":["tayberry.min.js","/source/helpers/utils.js","/source/base.js","/source/axis.js","/source/helpers/colour.js","/source/constants.js","/source/renderer.base.js","/source/helpers/rect.js","/source/renderer.bar.js","/source/renderer.line.js","/source/core.js","/source/drawing.js","/source/events.js","/source/defaults.js","/source/sizing.js","/source/legend.js","/source/animation.js","/source/tayberry.js"],"names":["global","factory","exports","module","define","amd","Tayberry","this","identity","obj","isMissingValue","n","isNaN","coalesce","_len","arguments","length","vals","Array","_key","i","reduce","array","func","getter","ret","ignoreMissing","undefined","retInitialised","value","a","b","none","every","elem","assign","targetObject","sourceObjects","innerAssign","deepAssign","formatString","formatValues","escapeAsHtml","replace","match","placeholder","stringToHtml","locateDecimalPoint","number","Math","floor","log","formatNumberThousands","decimalPlaces","parts","toFixed","split","join","createAutoNumberFormatter","scale","prefix","suffix","precision","x","createFixedNumberFormatter","createPercentageFormatter","str","div","document","createElement","appendChild","createTextNode","innerHTML","throttle","fn","threshold","last","deferTimer","context","now","Date","args","clearTimeout","setTimeout","apply","babelHelpers","Symbol","iterator","constructor","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","call","inherits","subClass","superClass","create","setPrototypeOf","__proto__","possibleConstructorReturn","self","ReferenceError","slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","next","done","push","err","isArray","selectedItem","containerElement","labelsCanvas","labelsCtx","options","scaleFactor","titleFont","plotArea","categories","labelFont","legendFont","renderers","onClickReal","onMouseLeaveReal","onMouseMoveReal","onWindowResizeReal","pendingAnimations","callbacks","onResize","onInit","series","data","concat","to","currentSourceObject","keysArray","keys","nextIndex","len","nextKey","nextValue","Axis","tayberry","index","axisType","isHorizontal","tickStep","min","max","tickStart","tickEnd","calculatedSize","topAdjustment","rightAdjustment","numLabelLines","setPlacement","xYSwapped","type","LinearAxis","CategorialAxis","createFontString","font","title","validAndSpecificPlacements","indexOf","placement","isVertical","_this","tb","ticks","getTicks","Utils.reduce","getTextWidth","labelFormatter","mapLogicalXUnit","mapLogicalYUnit","fixedOnly","reset","size","titleFontHeight","getFontHeight","fontHeight","mapLogicalXOrYUnit","elementSmallPadding","text","lastTick","lastTickYStart","y","top","adjustment","maxLabelSize","lastXEnd","tick","textWidth","xStart","xEnd","lastTickXEnd","right","isPlacedAtStart","left","bottom","offsetRect","drawTicksAndLabels","drawTitle","_this2","labelPadding","labelPaddingX","labelPaddingY","xOffset","startProperty","yOffset","save","fillStyle","colour","textAlign","textBaseline","lastXEnds","tickIndex","maxWidth","enumerateTicks","formattedValue","row","rowOffset","width","fillText","gridLines","drawLine","x1","y1","x2","y2","adjustOffsetRect","restore","displacement","labelPaddingSize","yMidpoint","translate","rotate","PI","xMidpoint","visibleOnly","_Axis","callback","categoryCount","clone","swapXY","categoryWidth","factor","labelPosition","_ref","Utils.identity","getOrigin","plotDisplacement","ceil","height","_Axis2","labelFormat","Utils.createPercentageFormatter","labelPrefix","labelSuffix","Utils.createFixedNumberFormatter","currencySymbol","Utils.createAutoNumberFormatter","start","end","endProperty","yValue","getValueDisplacement","round","targetTicks","approxStep","targetStart","targetEnd","overriddenStart","Utils.isMissingValue","overriddenEnd","_ref2","isYAxis","getDataMinMax","getDataXMinMax","_ref3","dataMin","dataMax","dataRange","tickStepValue","targetRange","plotLength","mapLogicalYOrXUnit","pow","scaledStep","snapScaledValue","totalCategories","isRange","axisRange","Utils.formatString","abs","Colour","arg1","parseString","r","g","regExHex","regExInt","groupsHex","exec","groupsInt","parseHex","parseInt","RangeError","parseFloat","component","clipComponent","clip","multiplier","colour1","colour2","blendPosition","blender","c1","c2","Utils.coalesce","visibilityState","visible","hidden","transitioning","Renderer","ctx","setSeries","seriesIndex","_series","renderer","excludeSeries","constants.visibilityState","onToggleSeriesAnimationFrame","rect","highlighted","highlightColour","multiplyAlpha","legend","hiddenAlphaMultiplier","toString","fillRect","sign","swapAxes","labels","verticalAlignment","baseline","align","verticalPosition","mapVerticalPosition","containsPoint","Enumerator","startCategoryIndex","categoryIndex","seriesCount","ByCategoryEnumerator","_Enumerator","getDataValue","BySeriesEnumerator","_Enumerator2","Rect","val","containsX","containsY","clipRect","minX","maxX","minY","maxY","BarRenderer","_renderer$Renderer","barPositions","registerCallback","updateBarWidths","bind","isStacked","barPlot","mode","isOverlaid","isNormal","animatingSeriesCount","totalMultiplier","rState","animationState","subtype","visibleSeriesCount","getVisibleSeriesCount","isShow","stage","yMultiplier","transColour","createFromBlend","totalBarsPerCategory","yOrigin","yAxis","yBottomPositive","yBottomNegative","yRunningTotalPositive","yRunningTotalNegative","categoryXStart","categoryXEnd","barXStart","categorySpacing","barXEnd","categoryPositions","barIndex","runningBarWidth","barWidth","xAxis","barPadding","yTop","yBottom","barEnumerator","BarEnumerator","bar","selected","enabled","drawLabel","found","plotType","isXRange","matches","sortDistance","priority","realDistance","xDist","yDist","sqrt","distance","sort","normalisedDistance","area","Utils.assign","renderer.Renderer","_renderer$ByCategoryE","_renderer$barPosition","tooltips","shared","renderer.ByCategoryEnumerator","autoMarkerIndex","markers","LineRenderer","pointPositions","updatPointPositions","xMultiplier","valueCount","valueOrigin","seriesPositions","valueIndex","xValue","getDataXValue","rValue","totalPoints","markerType","showMarkers","linePlot","noMarkersThreshold","beginPath","arc","fill","moveTo","lineTo","closePath","pointEnumerator","PointEnumerator","pt","firstPoint","lineWidth","seriesSelected","highlightedLineWidth","strokeStyle","lastPoint","stroke","glowColour","drawMarker","highlightedMarkerSize","markerSize","inflate","horizontalDistance","e1","e2","_renderer$BySeriesEnu","_renderer$pointPositi","renderer.BySeriesEnumerator","currentAutoColourIndex","getAutoColour","defaultColours","dataPoint","setDataValue","newValue","createCanvas","style","clientWidth","clientHeight","position","getElementById","getContext","plotCanvas","plotCtx","yAxes","xAxes","initialise","destroy","parentNode","removeChild","tooltipElement","removeEventListener","window","devicePixelRatio","scaleFactorX","scaleFactorY","forDom","autoScale","face","updateFonts","map","e","setOptions","optionOverrides","defaultOptions","presets","Utils.deepAssign","allAxes","defaultPrimaryYAxis","defaultSecondaryYAxis","defaultXAxis","defaultSeries","createRenderers","calculatePlotArea","forEach","addEventListener","onClick","onMouseMove","onMouseLeave","Utils.throttle","onWindowResize","calculateHighlightColour","newColour","increaseBy","sum","calculateGlowColour","groupedSeries","line","curSeries","xAxisIndex","yAxisIndex","hasOwnProperty","axis","minNormal","maxNormal","minStacked","maxStacked","seriesPositiveTotals","seriesNegativeTotals","barSeries","filter","seriesMinima","seriesMaxima","createTooltip","className","zIndex","borderRadius","backgroundColor","border","padding","display","body","fontString","measureText","getMultilineTextHeight","splitMultilineText","lines","lineText","spaceWidth","wordStart","wordEnd","word","substring","wordWidth","drawTextMultiline","lineHeight","render","drawLabelLayer","animations","setSeriesVisibility","drawPlotLayer","clear","plot","clearRect","drawBackground","plotBackgroundColour","drawPlot","drawLabels","draw","drawLegend","redraw","plotOnly","eventName","event","currentTarget","relatedTarget","handleMouseMove","clientX","clientY","boundingRect","getBoundingClientRect","tooltipDisplayStyle","hitTestResult","hitTest","tooltipHtml","aboveZero","category","getCategoryLabel","headerTemplate","valueTemplate","name","footerTemplate","tooltipRect","borderColor","pageXOffset","mapScreenUnit","pageYOffset","button","toggleSeriesVisibility","oldSelectedItem","backgroundColour","elementLargePadding","indicatorSize","defaultYAxis","histogram","darkGrid","MAX_AXIS_CALC_SIZE_ATTEMPTS","adjustSize","calculateExtent","updateFormatter","Utils.none","hitTestLegend","legendMetrics","getLegendMeasurements","items","item","drawLegendIndicator","indicatorRect","textX","textY","smallPadding","largePadding","totalWidth","revokeAnimation","splice","startAnimation","animation","initialStage","newAnimation","startTime","performance","animator","requestAnimationFrame","onAnimate","timestamp","elapsed","onFrame","onCompletion","onAnimationFrame","newType","element","chart","TayberryBase"],"mappings":"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","file":"tayberry.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.Tayberry = factory());\n}(this, function () { 'use strict';\n\n    var babelHelpers = {};\n    babelHelpers.typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n    };\n\n    babelHelpers.classCallCheck = function (instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    };\n\n    babelHelpers.createClass = function () {\n      function defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      return function (Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n      };\n    }();\n\n    babelHelpers.get = function get(object, property, receiver) {\n      if (object === null) object = Function.prototype;\n      var desc = Object.getOwnPropertyDescriptor(object, property);\n\n      if (desc === undefined) {\n        var parent = Object.getPrototypeOf(object);\n\n        if (parent === null) {\n          return undefined;\n        } else {\n          return get(parent, property, receiver);\n        }\n      } else if (\"value\" in desc) {\n        return desc.value;\n      } else {\n        var getter = desc.get;\n\n        if (getter === undefined) {\n          return undefined;\n        }\n\n        return getter.call(receiver);\n      }\n    };\n\n    babelHelpers.inherits = function (subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n      }\n\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n          value: subClass,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    };\n\n    babelHelpers.possibleConstructorReturn = function (self, call) {\n      if (!self) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n\n      return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    };\n\n    babelHelpers.slicedToArray = function () {\n      function sliceIterator(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"]) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      return function (arr, i) {\n        if (Array.isArray(arr)) {\n          return arr;\n        } else if (Symbol.iterator in Object(arr)) {\n          return sliceIterator(arr, i);\n        } else {\n          throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n        }\n      };\n    }();\n\n    babelHelpers;\n\n    var Tayberry$1 = function () {\n        function Tayberry() {\n            babelHelpers.classCallCheck(this, Tayberry);\n\n            this.selectedItem = {};\n            this.containerElement = null;\n            this.labelsCanvas = null;\n            this.labelsCtx = null;\n            this.options = null;\n            this.scaleFactor = null;\n            this.titleFont = null;\n            this.plotArea = null;\n            this.categories = [];\n            this.titleFont = null;\n            this.labelFont = null;\n            this.legendFont = null;\n            this.renderers = [];\n            this.onClickReal = null;\n            this.onMouseLeaveReal = null;\n            this.onMouseMoveReal = null;\n            this.onWindowResizeReal = null;\n            this.pendingAnimations = [];\n            this.callbacks = {\n                onResize: [],\n                onInit: []\n            };\n        }\n\n        babelHelpers.createClass(Tayberry, [{\n            key: \"seriesCount\",\n            get: function get() {\n                return this.options.series.length;\n            }\n        }, {\n            key: \"categoryCount\",\n            get: function get() {\n                return this.options.series.length ? this.options.series[0].data.length : 0;\n            }\n        }]);\n        return Tayberry;\n    }();\n\n    function identity(obj) {\n        return obj;\n    }\n\n    function isMissingValue(n) {\n        return n === null || typeof n === 'undefined' || isNaN(n) && typeof n === 'number';\n    }\n\n    function coalesce() {\n        for (var _len = arguments.length, vals = Array(_len), _key = 0; _key < _len; _key++) {\n            vals[_key] = arguments[_key];\n        }\n\n        for (var i = 0; i < vals.length; i++) {\n            if (!isMissingValue(vals[i])) {\n                return vals[i];\n            }\n        }\n    }\n\n    function reduce(array, func, getter) {\n        var ignoreMissing = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\n        var ret, i;\n        if (array.reduce && !getter && !ignoreMissing) {\n            ret = array.reduce(function (a, b) {\n                return func(a, b);\n            });\n        } else {\n            var retInitialised = false;\n            getter = getter || identity;\n            for (i = 0; i < array.length; i++) {\n                var value = getter(array[i], i);\n                if (!ignoreMissing || !isMissingValue(value)) {\n                    ret = retInitialised ? func(ret, value) : value;\n                    retInitialised = true;\n                }\n            }\n        }\n        return ret;\n    }\n\n    var innerAssign = function innerAssign(deepAssign, targetObject, sourceObjects) {\n        if (!Array.isArray(sourceObjects)) sourceObjects = [sourceObjects];\n        if (!deepAssign && Object.assign) {\n            return Object.assign.apply(Object, [targetObject].concat(sourceObjects));\n        } else {\n            if (targetObject === undefined || targetObject === null) {\n                throw new TypeError('Cannot convert first argument to object');\n            }\n\n            var to = Object(targetObject);\n            for (var i = 0; i < sourceObjects.length; i++) {\n                var currentSourceObject = sourceObjects[i];\n                if (currentSourceObject === undefined || currentSourceObject === null) {\n                    continue;\n                }\n                currentSourceObject = Object(currentSourceObject);\n\n                var keysArray = Object.keys(currentSourceObject);\n                for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n                    var nextKey = keysArray[nextIndex];\n                    var nextValue = currentSourceObject[nextKey];\n                    var desc = Object.getOwnPropertyDescriptor(currentSourceObject, nextKey);\n                    if (desc !== undefined && desc.enumerable) {\n                        if (deepAssign && !Array.isArray(nextValue) && (typeof nextValue === 'undefined' ? 'undefined' : babelHelpers.typeof(nextValue)) === 'object' && nextValue !== null) to[nextKey] = innerAssign(true, {}, [to[nextKey], nextValue]);else to[nextKey] = nextValue;\n                    }\n                }\n            }\n            return to;\n        }\n    };\n\n    function none(array) {\n        return array.every(function (elem) {\n            return !elem;\n        });\n    }\n\n    function assign(targetObject, sourceObjects) {\n        return innerAssign(false, targetObject, sourceObjects);\n    }\n\n    function deepAssign(targetObject, sourceObjects) {\n        return innerAssign(true, targetObject, sourceObjects);\n    }\n\n    function formatString(formatString, formatValues, escapeAsHtml) {\n        return formatString.replace(/{(\\w+)}/g, function (match, placeholder) {\n            var value = formatValues[placeholder];\n            return typeof value !== 'undefined' ? escapeAsHtml ? stringToHtml(value) : value : match;\n        });\n    }\n\n    function locateDecimalPoint(number) {\n        return Math.floor(Math.log(number) / Math.log(10));\n    }\n\n    function formatNumberThousands(number) {\n        var decimalPlaces = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n        var parts = number.toFixed(decimalPlaces).split(\".\");\n        parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n        return parts.join(\".\");\n    }\n\n    function createAutoNumberFormatter(scale) {\n        var prefix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n        var suffix = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];\n        var precision = arguments.length <= 3 || arguments[3] === undefined ? 2 : arguments[3];\n\n        var decimalPlaces = locateDecimalPoint(scale);\n        decimalPlaces = decimalPlaces < 0 ? -decimalPlaces + precision - 1 : 0;\n        return function (x) {\n            return prefix + formatNumberThousands(x, decimalPlaces) + suffix;\n        };\n    }\n\n    function createFixedNumberFormatter(scale) {\n        var prefix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n        var suffix = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];\n        var decimalPlaces = arguments.length <= 3 || arguments[3] === undefined ? 2 : arguments[3];\n\n        return function (x) {\n            return prefix + formatNumberThousands(x, decimalPlaces) + suffix;\n        };\n    }\n\n    function createPercentageFormatter(scale) {\n        var prefix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n        var suffix = arguments.length <= 2 || arguments[2] === undefined ? '%' : arguments[2];\n        var precision = arguments.length <= 3 || arguments[3] === undefined ? 2 : arguments[3];\n\n        var decimalPlaces = locateDecimalPoint(scale * 100);\n        decimalPlaces = decimalPlaces < precision ? -decimalPlaces + precision - 1 : 0;\n        return function (x) {\n            return prefix + formatNumberThousands(x * 100, decimalPlaces) + suffix;\n        };\n    }\n\n    function stringToHtml(str) {\n        var div = document.createElement('div');\n        div.appendChild(document.createTextNode(str));\n        return div.innerHTML;\n    }\n\n    function throttle(fn, threshold) {\n        var last, deferTimer;\n        return function () {\n            var context = this;\n\n            var now = Date.now(),\n                args = arguments;\n            if (last && now < last + threshold) {\n                clearTimeout(deferTimer);\n                deferTimer = setTimeout(function () {\n                    last = now;\n                    fn.apply(context, args);\n                }, threshold);\n            } else {\n                last = now;\n                fn.apply(context, args);\n            }\n        };\n    }\n\n    var Axis = function () {\n        babelHelpers.createClass(Axis, null, [{\n            key: 'create',\n            value: function create(tayberry, options, index, axisType, xYSwapped) {\n                var isHorizontal = axisType === 'x' && !xYSwapped || axisType === 'y' && xYSwapped;\n                if (options.type === 'linear') return new LinearAxis(tayberry, index, options, axisType, isHorizontal);else return new CategorialAxis(tayberry, index, options, axisType, isHorizontal);\n            }\n        }]);\n\n        function Axis(tayberry, index, options, axisType, isHorizontal) {\n            babelHelpers.classCallCheck(this, Axis);\n\n            this.tayberry = tayberry;\n            this.options = options;\n            this.axisType = axisType;\n            this.isHorizontal = isHorizontal;\n            this.index = index;\n            this.tickStep = null;\n            this.min = null;\n            this.max = null;\n            this.tickStart = null;\n            this.tickEnd = null;\n            this.calculatedSize = 0;\n            this.topAdjustment = 0;\n            this.rightAdjustment = 0;\n            this.titleFont = null;\n            this.labelFont = null;\n            this.numLabelLines = 1;\n\n            this.setPlacement();\n        }\n\n        babelHelpers.createClass(Axis, [{\n            key: 'updateFonts',\n            value: function updateFonts() {\n                this.labelFont = this.tayberry.createFontString(this.options.font);\n                this.titleFont = this.tayberry.createFontString(this.options.title.font);\n            }\n        }, {\n            key: 'setPlacement',\n            value: function setPlacement() {\n                var validAndSpecificPlacements = ['left', 'right', 'top', 'bottom', 'start', 'end'];\n                if (validAndSpecificPlacements.indexOf(this.options.placement) === -1) {\n                    this.options.placement = this.isVertical ^ this.index > 0 ? 'start' : 'end';\n                }\n            }\n        }, {\n            key: 'maxLabelSize',\n            value: function maxLabelSize() {\n                var _this = this;\n\n                var tb = this.tayberry;\n                var ticks = this.getTicks();\n                return reduce(ticks, Math.max, function (x) {\n                    return tb.getTextWidth(_this.options.labelFormatter(x.value), _this.labelFont);\n                });\n            }\n        }, {\n            key: 'mapLogicalXOrYUnit',\n            value: function mapLogicalXOrYUnit(x) {\n                return this.isVertical ? this.tayberry.mapLogicalXUnit(x) : this.tayberry.mapLogicalYUnit(x);\n            }\n        }, {\n            key: 'mapLogicalYOrXUnit',\n            value: function mapLogicalYOrXUnit(x) {\n                return !this.isVertical ? this.tayberry.mapLogicalXUnit(x) : this.tayberry.mapLogicalYUnit(x);\n            }\n        }, {\n            key: 'adjustSize',\n            value: function adjustSize(plotArea, fixedOnly, reset) {\n                var size = 0,\n                    tb = this.tayberry,\n                    ret = undefined;\n\n                var titleFontHeight = tb.getFontHeight(this.options.title.font);\n                var fontHeight = tb.getFontHeight(this.options.font);\n\n                if (reset) {\n                    this.calculatedSize = 0;\n                    this.topAdjustment = 0;\n                    this.rightAdjustment = 0;\n                    this.numLabelLines = 1;\n                }\n\n                size += this.mapLogicalXOrYUnit(tb.options.elementSmallPadding);\n                if (this.options.title.text) {\n                    size += this.mapLogicalXOrYUnit(tb.options.elementSmallPadding) + titleFontHeight;\n                }\n\n                if (!fixedOnly) {\n                    var ticks = this.getTicks(false);\n                    if (this.isVertical) {\n                        if (ticks.length) {\n                            var lastTick = ticks[ticks.length - 1];\n                            var lastTickYStart = lastTick.y - fontHeight / 2;\n                            if (lastTickYStart < plotArea.top - this.topAdjustment) {\n                                var adjustment = plotArea.top - lastTickYStart - this.topAdjustment + 1;\n                                plotArea.top += adjustment;\n                                this.topAdjustment += adjustment;\n                            }\n                        }\n                        size += this.maxLabelSize();\n                    } else {\n                        {\n                            var lastXEnd = undefined;\n                            for (var i = 0; i < ticks.length; i++) {\n                                var tick = ticks[i];\n                                var textWidth = tb.getTextWidth(this.options.labelFormatter(tick.value), this.labelFont);\n                                var xStart = tick.x - textWidth / 2;\n                                var xEnd = tick.x + textWidth / 2;\n                                if (typeof lastXEnd !== 'undefined' && xStart <= lastXEnd + 1) {\n                                    this.numLabelLines = 2;\n                                    break;\n                                }\n                                lastXEnd = xEnd;\n                            }\n                        }\n                        if (ticks.length) {\n                            var lastTick = ticks[ticks.length - 1];\n                            var textWidth = tb.getTextWidth(this.options.labelFormatter(lastTick.value), this.labelFont);\n                            var lastTickXEnd = lastTick.x + textWidth / 2;\n                            if (lastTickXEnd >= plotArea.right + this.rightAdjustment) {\n                                var adjustment = lastTickXEnd - plotArea.right - this.rightAdjustment + 1;\n                                plotArea.right -= adjustment;\n                                this.rightAdjustment += adjustment;\n                            }\n                        }\n                        size += fontHeight * this.numLabelLines;\n                    }\n                }\n\n                if (this.isPlacedAtStart) {\n                    if (this.isVertical) {\n                        plotArea.left += size - this.calculatedSize;\n                    } else {\n                        plotArea.top += size - this.calculatedSize;\n                    }\n                } else {\n                    size *= -1;\n                    if (this.isVertical) {\n                        plotArea.right += size - this.calculatedSize;\n                    } else {\n                        plotArea.bottom += size - this.calculatedSize;\n                    }\n                }\n\n                ret = this.calculatedSize !== size;\n                this.calculatedSize = size;\n\n                return ret;\n            }\n        }, {\n            key: 'calculateExtent',\n            value: function calculateExtent() {}\n        }, {\n            key: 'getCategoryLabel',\n            value: function getCategoryLabel() {}\n        }, {\n            key: 'draw',\n            value: function draw(offsetRect) {\n                this.drawTicksAndLabels(offsetRect);\n                this.drawTitle(offsetRect);\n            }\n        }, {\n            key: 'drawTicksAndLabels',\n            value: function drawTicksAndLabels(offsetRect) {\n                var _this2 = this;\n\n                var tb = this.tayberry;\n                var labelPadding = this.mapLogicalXOrYUnit(tb.options.elementSmallPadding);\n                var labelPaddingX = this.isVertical ? labelPadding * (this.isPlacedAtStart ? -1 : 1) : 0;\n                var labelPaddingY = !this.isVertical ? labelPadding * (this.isPlacedAtStart ? -1 : 1) : 0;\n                var fontHeight = tb.getFontHeight(this.options.font);\n                var xOffset = this.isVertical ? offsetRect[this.startProperty] : 0;\n                var yOffset = !this.isVertical ? offsetRect[this.startProperty] : 0;\n\n                tb.labelsCtx.save();\n                tb.labelsCtx.font = this.labelFont;\n                tb.labelsCtx.fillStyle = this.options.font.colour;\n                tb.labelsCtx.textAlign = this.isVertical ? this.isPlacedAtStart ? 'right' : 'left' : 'center';\n                tb.labelsCtx.textBaseline = this.isVertical ? 'middle' : this.isPlacedAtStart ? 'bottom' : 'top';\n\n                var lastXEnds = [],\n                    tickIndex = 0,\n                    maxWidth = 0;\n\n                this.enumerateTicks(function (tick) {\n                    var xStart = undefined,\n                        xEnd = undefined;\n                    var formattedValue = _this2.options.labelFormatter(tick.value);\n                    var row = tickIndex % _this2.numLabelLines;\n                    var rowOffset = _this2.isVertical ? 0 : fontHeight * row;\n                    var textWidth = tb.getTextWidth(formattedValue, _this2.labelFont);\n                    if (!_this2.isVertical) {\n                        xStart = tick.x - textWidth / 2;\n                        xEnd = tick.x + textWidth / 2;\n                    }\n\n                    if (_this2.isVertical || (typeof lastXEnds[row] === 'undefined' || xStart > lastXEnds[row] + 1) && xStart >= 0 && xEnd < tb.labelsCanvas.width) {\n                        maxWidth = Math.max(maxWidth, textWidth);\n                        tb.labelsCtx.fillText(formattedValue, tick.x + labelPaddingX + xOffset, tick.y + labelPaddingY + rowOffset + yOffset);\n                        lastXEnds[row] = xEnd;\n                    }\n                    if (_this2.options.gridLines.colour) tb.drawLine(tick.x1, tick.y1, tick.x2, tick.y2, _this2.options.gridLines.colour);\n                    tickIndex++;\n                });\n\n                this.adjustOffsetRect(offsetRect, this.isVertical ? maxWidth + labelPadding : fontHeight + labelPadding);\n\n                tb.labelsCtx.restore();\n            }\n        }, {\n            key: 'adjustOffsetRect',\n            value: function adjustOffsetRect(offsetRect, displacement) {\n                offsetRect[this.startProperty] += this.isPlacedAtStart ? -displacement : displacement;\n            }\n        }, {\n            key: 'drawTitle',\n            value: function drawTitle(offsetRect) {\n                if (this.options.title.text) {\n                    var tb = this.tayberry;\n                    tb.labelsCtx.save();\n                    tb.labelsCtx.font = this.titleFont;\n                    tb.labelsCtx.fillStyle = this.options.title.font.colour;\n                    tb.labelsCtx.textAlign = 'center';\n\n                    var labelPaddingSize = this.mapLogicalXOrYUnit(tb.options.elementSmallPadding);\n                    var labelPadding = labelPaddingSize * (this.isPlacedAtStart ? -1 : 1);\n                    var xOffset = this.isVertical ? offsetRect[this.startProperty] : 0;\n                    var yOffset = !this.isVertical ? offsetRect[this.startProperty] : 0;\n                    var fontHeight = tb.getFontHeight(this.options.title.font);\n\n                    if (this.isVertical) {\n                        tb.labelsCtx.textBaseline = 'bottom';\n                        var x = tb.plotArea[this.startProperty] + xOffset + labelPadding;\n                        var y = tb.plotArea.yMidpoint + yOffset;\n                        tb.labelsCtx.translate(x, y);\n                        tb.labelsCtx.rotate((this.isPlacedAtStart ? -1 : 1) * Math.PI / 2);\n                        tb.labelsCtx.fillText(this.options.title.text, 0, 0);\n                    } else {\n                        tb.labelsCtx.textBaseline = this.isPlacedAtStart ? 'bottom' : 'top';\n                        var x = tb.plotArea.xMidpoint + xOffset;\n                        var y = tb.plotArea[this.startProperty] + labelPadding + yOffset;\n                        //tb.mapLogicalYOrXUnit(tb.options.font.size * 2 + tb.options.elementSmallPadding + tb.options.elementLargePadding)\n                        tb.labelsCtx.fillText(this.options.title.text, x, y);\n                    }\n                    this.adjustOffsetRect(offsetRect, fontHeight + labelPaddingSize);\n                    tb.labelsCtx.restore();\n                }\n            }\n        }, {\n            key: 'getTicks',\n            value: function getTicks() {\n                var visibleOnly = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n                var ret = [];\n                this.enumerateTicks(function (tick) {\n                    ret.push(tick);\n                }, visibleOnly);\n                return ret;\n            }\n        }, {\n            key: 'getOrigin',\n            value: function getOrigin() {}\n        }, {\n            key: 'updateFormatter',\n            value: function updateFormatter() {}\n        }, {\n            key: 'isPlacedAtStart',\n            get: function get() {\n                return this.options.placement === \"left\" || this.options.placement === \"bottom\" || this.options.placement === \"start\";\n            }\n        }, {\n            key: 'isYAxis',\n            get: function get() {\n                return this.axisType === 'y';\n            }\n        }, {\n            key: 'isVertical',\n            get: function get() {\n                return !this.isHorizontal;\n            }\n        }, {\n            key: 'startProperty',\n            get: function get() {\n                if (this.isVertical) return this.isPlacedAtStart ? 'left' : 'right';else return this.isPlacedAtStart ? 'top' : 'bottom';\n            }\n        }, {\n            key: 'endProperty',\n            get: function get() {\n                if (this.isVertical) return !this.isPlacedAtStart ? 'left' : 'right';else return !this.isPlacedAtStart ? 'top' : 'bottom';\n            }\n        }, {\n            key: 'valueOrigin',\n            get: function get() {\n                return this.min <= 0 && 0 <= this.max ? 0 : this.min > 0 ? this.min : this.max;\n            }\n        }]);\n        return Axis;\n    }();\n\n    var CategorialAxis = function (_Axis) {\n        babelHelpers.inherits(CategorialAxis, _Axis);\n\n        function CategorialAxis() {\n            babelHelpers.classCallCheck(this, CategorialAxis);\n            return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(CategorialAxis).apply(this, arguments));\n        }\n\n        babelHelpers.createClass(CategorialAxis, [{\n            key: 'enumerateTicks',\n            value: function enumerateTicks(callback) {\n                var tb = this.tayberry;\n\n                var categoryCount = this.options.categories.length;\n                var plotArea = tb.plotArea.clone();\n                if (this.isVertical) plotArea.swapXY();\n                var categoryWidth = plotArea.width / tb.categoryCount;\n                var factor = 0.5;\n\n                if (!this.isVertical) {\n                    switch (this.options.labelPosition) {\n                        case 'left':\n                            factor = 0;\n                            break;\n                        case 'right':\n                            factor = 1;\n                            break;\n                    }\n                }\n\n                for (var i = 0; i < categoryCount; i++) {\n                    var value = this.options.categories[i];\n                    var y1 = this.isPlacedAtStart ? plotArea.top : plotArea.bottom;\n                    var y2 = !this.isPlacedAtStart ? plotArea.top : plotArea.bottom;\n                    var x1 = plotArea.left + Math.floor(i * categoryWidth);\n                    var x2 = x1;\n                    var x = plotArea.left + Math.floor(i * categoryWidth + categoryWidth * factor);\n                    var y = y1;\n                    if (this.isVertical) {\n                        ;\n\n                        var _ref = [y1, x1, y2, x2, y, x];\n                        x1 = _ref[0];\n                        y1 = _ref[1];\n                        x2 = _ref[2];\n                        y2 = _ref[3];\n                        x = _ref[4];\n                        y = _ref[5];\n                    }callback({\n                        value: value,\n                        x1: x1,\n                        y1: y1,\n                        x2: x2,\n                        y2: y2,\n                        x: x,\n                        y: y\n                    });\n                }\n            }\n        }, {\n            key: 'updateFormatter',\n            value: function updateFormatter() {\n                if (!this.options.labelFormatter) {\n                    this.options.labelFormatter = identity;\n                }\n            }\n        }, {\n            key: 'getCategoryLabel',\n            value: function getCategoryLabel(index) {\n                return this.options.labelFormatter(this.options.categories[index]);\n            }\n        }, {\n            key: 'getOrigin',\n            value: function getOrigin() {\n                return this.tayberry.plotArea[this.isVertical ? 'bottom' : 'left'];\n            }\n        }, {\n            key: 'getValueDisplacement',\n            value: function getValueDisplacement(value) {\n                var ret = this.getOrigin() + this.plotDisplacement * (value + 0.5) / this.options.categories.length;\n                ret = this.isVertical ? Math.floor(ret) : Math.ceil(ret);\n                return ret;\n            }\n        }, {\n            key: 'plotDisplacement',\n            get: function get() {\n                return this.isVertical ? -this.tayberry.plotArea.height : this.tayberry.plotArea.width;\n            }\n        }]);\n        return CategorialAxis;\n    }(Axis);\n\n    var LinearAxis = function (_Axis2) {\n        babelHelpers.inherits(LinearAxis, _Axis2);\n\n        function LinearAxis() {\n            babelHelpers.classCallCheck(this, LinearAxis);\n            return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(LinearAxis).apply(this, arguments));\n        }\n\n        babelHelpers.createClass(LinearAxis, [{\n            key: 'updateFormatter',\n            value: function updateFormatter() {\n                if (!this.options.labelFormatter) {\n                    if (this.options.labelFormat === 'percentage') {\n                        this.options.labelFormatter = createPercentageFormatter(this.max - this.min, this.options.labelPrefix, this.options.labelSuffix);\n                    } else if (this.options.labelFormat === 'currency') {\n                        this.options.labelFormatter = createFixedNumberFormatter(this.max - this.min, this.options.labelPrefix || this.options.currencySymbol, this.options.labelSuffix);\n                    } else {\n                        this.options.labelFormatter = createAutoNumberFormatter(this.max - this.min, this.options.labelPrefix, this.options.labelSuffix);\n                    }\n                }\n            }\n        }, {\n            key: 'enumerateTicks',\n            value: function enumerateTicks(callback) {\n                var tb = this.tayberry;\n\n                var start = this.startProperty,\n                    end = this.endProperty;\n\n                for (var yValue = this.tickStart; yValue <= this.tickEnd && this.tickStep;) {\n                    var y = this.getValueDisplacement(yValue);\n                    if (this.isVertical) {\n                        if (callback({\n                            value: yValue,\n                            x1: tb.plotArea[start],\n                            y1: y,\n                            x2: tb.plotArea[end],\n                            y2: y,\n                            x: tb.plotArea[start],\n                            y: y\n\n                        })) break;\n                    } else {\n                        if (callback({\n                            value: yValue,\n                            y1: tb.plotArea[start],\n                            x1: y,\n                            y2: tb.plotArea[end],\n                            x2: y,\n                            y: tb.plotArea[start],\n                            x: y\n                        })) break;\n                    }\n                    yValue = this.tickStart + Math.round((yValue + this.tickStep - this.tickStart) / this.tickStep) * this.tickStep;\n                }\n            }\n        }, {\n            key: 'calculateExtent',\n            value: function calculateExtent() {\n                var targetTicks = undefined,\n                    approxStep = undefined,\n                    scale = undefined;\n\n                var targetStart = this.options.min;\n                var targetEnd = this.options.max;\n                var overriddenStart = !isMissingValue(targetStart);\n                var overriddenEnd = !isMissingValue(targetEnd);\n\n                if (!overriddenStart || !overriddenEnd) {\n                    var _ref2 = this.isYAxis ? this.tayberry.getDataMinMax(this) : this.tayberry.getDataXMinMax(this);\n\n                    var _ref3 = babelHelpers.slicedToArray(_ref2, 2);\n\n                    var dataMin = _ref3[0];\n                    var dataMax = _ref3[1];\n\n                    var dataRange = dataMax - dataMin;\n                    if (!overriddenStart) {\n                        targetStart = dataMin;\n                        if (this.isYAxis) {\n                            targetStart = targetStart - dataRange * 0.1;\n                            if (dataMin >= 0 && targetStart < 0) targetStart = 0;\n                        }\n                    }\n                    if (!overriddenEnd) {\n                        targetEnd = dataMax;\n                        if (this.isYAxis) {\n                            targetEnd = dataMax + dataRange * 0.1;\n                            if (dataMax <= 0 && targetStart > 0) targetEnd = 0;\n                        }\n                    }\n                }\n\n                if (this.options.tickStepValue) {\n                    this.tickStep = this.options.tickStepValue;\n                    this.min = targetStart;\n                    this.max = targetEnd;\n                } else {\n                    var targetRange = targetEnd - targetStart;\n                    targetTicks = this.plotLength / this.mapLogicalYOrXUnit(this.options.tickStep);\n                    approxStep = targetRange / targetTicks;\n                    scale = Math.pow(10, Math.floor(Math.log(approxStep) / Math.log(10)));\n                    var scaledStep = LinearAxis.snapScaledValue(Math.ceil(approxStep / scale));\n                    this.tickStep = scaledStep * scale;\n                    this.min = targetStart;\n                    this.max = targetEnd;\n                }\n                this.tickStart = this.options.tickStepValue && overriddenStart ? this.min : Math.floor(this.min / this.tickStep) * this.tickStep;\n                this.tickEnd = this.options.tickStepValue && overriddenEnd ? this.max : Math.ceil(this.max / this.tickStep) * this.tickStep;\n                if (!overriddenStart && this.isYAxis) this.min = this.tickStart;\n                if (!overriddenEnd && this.isYAxis) this.max = this.tickEnd;\n            }\n        }, {\n            key: 'getOrigin',\n            value: function getOrigin() {\n                var ret = this.tayberry.plotArea[this.isVertical ? 'bottom' : 'left'] - (0 - this.min) * this.plotDisplacement / (this.max - this.min);\n                if (this.isVertical) ret--;\n                ret = this.isVertical ? Math.floor(ret) : Math.ceil(ret);\n                return ret;\n            }\n        }, {\n            key: 'getValueDisplacement',\n            value: function getValueDisplacement(value) {\n                var ret = this.getOrigin() - value * this.plotDisplacement / (this.max - this.min);\n                ret = this.isVertical ? Math.floor(ret) : Math.ceil(ret);\n                return ret;\n            }\n        }, {\n            key: 'getCategoryLabel',\n            value: function getCategoryLabel(index, totalCategories, isRange) {\n                if (isRange) {\n                    var start = index / totalCategories;\n                    var end = (index + 1) / totalCategories;\n                    var axisRange = this.max - this.min;\n                    return formatString('{0} ≤ x < {1}', [this.options.labelFormatter(this.min + start * axisRange), this.options.labelFormatter(this.min + end * axisRange)]);\n                } else {\n                    return this.options.labelFormatter(index);\n                }\n            }\n        }, {\n            key: 'plotDisplacement',\n            get: function get() {\n                return this.isVertical ? this.tayberry.plotArea.height - 1 : -(this.tayberry.plotArea.width - 1);\n            }\n        }, {\n            key: 'plotLength',\n            get: function get() {\n                return Math.abs(this.plotDisplacement);\n            }\n        }], [{\n            key: 'snapScaledValue',\n            value: function snapScaledValue(scaledStep) {\n                if (scaledStep < 1) scaledStep = 1;else if (scaledStep < 2) scaledStep = 2;else if (scaledStep < 2.5) scaledStep = 2.5;else if (scaledStep < 5) scaledStep = 5;else scaledStep = 10;\n                return scaledStep;\n            }\n        }]);\n        return LinearAxis;\n    }(Axis);\n\n    var Colour = function () {\n        /**\r\n         * Constructs a Colour object.\r\n         *\r\n         * @param colourCode    an HTML colour code in hex or integer (rgb) form\r\n         */\n\n        function Colour() {\n            babelHelpers.classCallCheck(this, Colour);\n\n            if (arguments.length === 1) {\n                var arg1 = arguments[0];\n                if (typeof arg1 === 'string') this.parseString(arg1);else {\n                    this.r = arg1.r;\n                    this.g = arg1.g;\n                    this.b = arg1.b;\n                    this.a = arg1.a;\n                }\n            }\n        }\n\n        /**\r\n         * Parses an HTML colour code\r\n         * @param str\r\n         * @returns {Colour}\r\n         */\n\n        babelHelpers.createClass(Colour, [{\n            key: 'parseString',\n            value: function parseString(str) {\n                var regExHex = /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})|^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i;\n                var regExInt = /^rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})(\\s*,\\s*([0-9]*\\.?[0-9]+)\\s*)?\\)$/i;\n                var groupsHex = regExHex.exec(str);\n                var groupsInt = regExInt.exec(str);\n                if (groupsHex) {\n                    var parseHex = function parseHex(value) {\n                        var ret = parseInt(value, 16);\n                        ret = ret * 0x10 + ret;\n                        return ret;\n                    };\n                    this.r = groupsHex[1] ? parseInt(groupsHex[1], 16) : parseHex(groupsHex[4]);\n                    this.g = groupsHex[2] ? parseInt(groupsHex[2], 16) : parseHex(groupsHex[5]);\n                    this.b = groupsHex[3] ? parseInt(groupsHex[3], 16) : parseHex(groupsHex[6]);\n                    this.a = 1.0;\n                } else if (groupsInt) {\n                    this.r = parseInt(groupsInt[1]);\n                    this.g = parseInt(groupsInt[2]);\n                    this.b = parseInt(groupsInt[3]);\n                    this.a = groupsInt[5] ? parseFloat(groupsInt[5]) : 1.0;\n                } else {\n                    throw new RangeError(str + \" is not a valid HTML colour\");\n                }\n                return this;\n            }\n\n            /**\r\n             * Clips a colour component to be in the range [0, 255], and round it them to\r\n             * the nearest integer\r\n             * @param component\r\n             * @returns {Colour}\r\n             */\n\n        }, {\n            key: 'clipComponent',\n            value: function clipComponent(component) {\n                this[component] = Math.round(this[component]);\n                this[component] = Math.min(this[component], 255);\n                this[component] = Math.max(this[component], 0);\n                return this;\n            }\n\n            /**\r\n             * Clips r,g,b colour components to be in the range [0, 255], and rounds them to\r\n             * the nearest integer\r\n             * @returns {Colour}\r\n             */\n\n        }, {\n            key: 'clip',\n            value: function clip() {\n                this.clipComponent('r');\n                this.clipComponent('g');\n                this.clipComponent('b');\n                return this;\n            }\n\n            /**\r\n             * Adds a number to each colour component\r\n             * @param number\r\n             * @returns {Colour}\r\n             */\n\n        }, {\n            key: 'increaseBy',\n            value: function increaseBy(number) {\n                this.r += number;\n                this.g += number;\n                this.b += number;\n                this.clip();\n                return this;\n            }\n        }, {\n            key: 'multiplyAlpha',\n            value: function multiplyAlpha(multiplier) {\n                this.a *= multiplier;\n                return this;\n            }\n        }, {\n            key: 'toString',\n\n            /**\r\n             * Formats this colour as a string\r\n             * @returns {String}\r\n             */\n            value: function toString() {\n                var ret;\n                if (!isMissingValue(this.a) && this.a !== 1.0) {\n                    ret = formatString('rgba({r},{g},{b},{a})', this);\n                } else {\n                    ret = formatString('rgb({r},{g},{b})', this);\n                }\n                return ret;\n            }\n        }, {\n            key: 'sum',\n            get: function get() {\n                return this.r + this.g + this.b;\n            }\n        }], [{\n            key: 'createFromBlend',\n            value: function createFromBlend(colour1, colour2, blendPosition) {\n                var blender = function blender(c1, c2) {\n                    return c1 + blendPosition * (c2 - c1);\n                };\n                return new Colour({\n                    r: blender(colour1.r, colour2.r),\n                    g: blender(colour1.g, colour2.g),\n                    b: blender(colour1.b, colour2.b),\n                    a: blender(coalesce(colour1.a, 1), coalesce(colour2.a, 1))\n                }).clip();\n            }\n        }]);\n        return Colour;\n    }();\n\n    var visibilityState = {\n        visible: 1 << 0,\n        hidden: 1 << 1,\n        transitioning: 1 << 2\n    };\n\n    var Renderer = function () {\n        function Renderer(ctx, tayberry, series) {\n            babelHelpers.classCallCheck(this, Renderer);\n\n            this.ctx = ctx;\n            this.tb = tayberry;\n            this.series = null;\n            this.setSeries(series);\n        }\n\n        babelHelpers.createClass(Renderer, [{\n            key: 'setSeries',\n            value: function setSeries(series) {\n                var seriesIndex;\n                this.series = series;\n\n                for (seriesIndex = 0; seriesIndex < this.series.length; seriesIndex++) {\n                    var _series = this.series[seriesIndex];\n                    _series.renderer = this;\n                }\n            }\n        }, {\n            key: 'getVisibleSeriesCount',\n            value: function getVisibleSeriesCount(excludeSeries) {\n                var ret = 0;\n                for (var index = 0; index < this.series.length; index++) {\n                    if (index !== excludeSeries) {\n                        var series = this.series[index];\n                        if (series.visible & visibilityState.visible) ret++;\n                    }\n                }\n                return ret;\n            }\n        }, {\n            key: 'onToggleSeriesAnimationFrame',\n            value: function onToggleSeriesAnimationFrame() {}\n        }, {\n            key: 'onAnimationFrame',\n            value: function onAnimationFrame() {\n                this.onToggleSeriesAnimationFrame();\n            }\n        }, {\n            key: 'drawLegendIndicator',\n            value: function drawLegendIndicator(ctx, series, rect, highlighted) {\n                ctx.fillStyle = highlighted ? series.highlightColour : series.colour;\n                if (!(series.visible & visibilityState.visible)) ctx.fillStyle = new Colour(ctx.fillStyle).multiplyAlpha(this.tb.options.legend.hiddenAlphaMultiplier).toString();\n                ctx.fillRect(rect.left, rect.top, rect.width, rect.height);\n            }\n        }, {\n            key: 'drawLabel',\n            value: function drawLabel(sign, text, rect) {\n                if (this.tb.options.swapAxes) rect = rect.clone().swapXY();\n                var x = (rect.left + rect.right) / 2;\n                var y = undefined;\n                if (this.tb.options.labels.verticalAlignment === 'top') y = rect.top;else if (this.tb.options.labels.verticalAlignment === 'bottom') y = rect.bottom;else y = (rect.top + rect.bottom) / 2;\n                var baseline = 'middle';\n                var align = 'center';\n                if (this.tb.options.swapAxes) {\n                    var _ref = [y, x];\n                    x = _ref[0];\n                    y = _ref[1];\n\n                    if (this.tb.options.labels.verticalPosition === 'outside') align = 'left';else if (this.tb.options.labels.verticalPosition === 'inside') align = 'right';\n                } else {\n                    baseline = Tayberry$1.mapVerticalPosition(sign, this.tb.options.labels.verticalPosition);\n                }\n                if (this.tb.plotArea.containsPoint(x, y)) {\n                    this.ctx.save();\n                    this.ctx.textAlign = align;\n                    this.ctx.textBaseline = baseline;\n                    this.ctx.fillText(text, x, y);\n                    this.ctx.restore();\n                }\n            }\n        }, {\n            key: 'drawPlot',\n            value: function drawPlot() {}\n        }, {\n            key: 'drawLabels',\n            value: function drawLabels() {}\n        }, {\n            key: 'hitTest',\n            value: function hitTest() {}\n        }]);\n        return Renderer;\n    }();\n\n    var Enumerator = function () {\n        function Enumerator(renderer) {\n            var startCategoryIndex = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n            babelHelpers.classCallCheck(this, Enumerator);\n\n            this.renderer = renderer;\n            this.tb = renderer.tb;\n\n            this.categoryCount = this.renderer.series[0].data.length;\n            this.categoryIndex = 0;\n            this.seriesIndex = 0;\n            this.seriesCount = this.renderer.series.length;\n            if (this.categoryCount) {\n                this.isHorizontal = this.tb.options.swapAxes;\n                this.plotArea = this.tb.plotArea.clone();\n                if (this.isHorizontal) this.plotArea.swapXY();\n                this.startCategoryIndex = Math.max(startCategoryIndex, 0);\n                this.startCategoryIndex = Math.min(this.startCategoryIndex, this.categoryCount - 1);\n                this.categoryIndex = this.startCategoryIndex;\n            }\n        }\n\n        babelHelpers.createClass(Enumerator, [{\n            key: 'nextValue',\n            value: function nextValue() {}\n        }]);\n        return Enumerator;\n    }();\n\n    var ByCategoryEnumerator = function (_Enumerator) {\n        babelHelpers.inherits(ByCategoryEnumerator, _Enumerator);\n\n        function ByCategoryEnumerator() {\n            babelHelpers.classCallCheck(this, ByCategoryEnumerator);\n            return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ByCategoryEnumerator).apply(this, arguments));\n        }\n\n        babelHelpers.createClass(ByCategoryEnumerator, [{\n            key: 'nextValue',\n            value: function nextValue() {\n\n                var value = undefined;\n                do {\n                    if (this.seriesIndex + 1 === this.seriesCount) {\n                        this.seriesIndex = 0;\n                        this.categoryIndex++;\n                        if (this.categoryIndex >= this.categoryCount) break;\n                    } else {\n                        this.seriesIndex++;\n                    }\n                    value = Tayberry$1.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]);\n                } while (isMissingValue(value));\n            }\n        }]);\n        return ByCategoryEnumerator;\n    }(Enumerator);\n\n    var BySeriesEnumerator = function (_Enumerator2) {\n        babelHelpers.inherits(BySeriesEnumerator, _Enumerator2);\n\n        function BySeriesEnumerator() {\n            babelHelpers.classCallCheck(this, BySeriesEnumerator);\n            return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BySeriesEnumerator).apply(this, arguments));\n        }\n\n        babelHelpers.createClass(BySeriesEnumerator, [{\n            key: 'nextValue',\n            value: function nextValue() {\n\n                var value = undefined;\n                do {\n                    if (this.categoryIndex + 1 === this.categoryCount) {\n                        this.categoryIndex = this.startCategoryIndex;\n                        this.seriesIndex++;\n                        if (this.seriesIndex >= this.seriesCount) break;\n                    } else {\n                        this.categoryIndex++;\n                    }\n                    value = Tayberry$1.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]);\n                } while (isMissingValue(value));\n            }\n        }]);\n        return BySeriesEnumerator;\n    }(Enumerator);\n\n    var Rect = function () {\n        function Rect() {\n            babelHelpers.classCallCheck(this, Rect);\n\n            if (arguments.length === 1) {\n                if (babelHelpers.typeof(arguments[0]) === 'object') {\n                    var rect = arguments[0];\n                    this.left = rect.left;\n                    this.top = rect.top;\n                    this.right = rect.right;\n                    this.bottom = rect.bottom;\n                } else {\n                    var val = arguments[0];\n                    this.left = val;\n                    this.top = val;\n                    this.right = val;\n                    this.bottom = val;\n                }\n            } else if (arguments.length === 4) {\n                this.left = arguments[0];\n                this.top = arguments[1];\n                this.right = arguments[2];\n                this.bottom = arguments[3];\n            }\n        }\n\n        babelHelpers.createClass(Rect, [{\n            key: 'containsPoint',\n            value: function containsPoint(x, y) {\n                return this.containsX(x) && this.containsY(y);\n            }\n        }, {\n            key: 'containsY',\n            value: function containsY(y) {\n                return y >= this.top && y < this.bottom || y >= this.bottom && y < this.top;\n            }\n        }, {\n            key: 'containsX',\n            value: function containsX(x) {\n                return x >= this.left && x < this.right || x >= this.right && x < this.left;\n            }\n        }, {\n            key: 'inflate',\n            value: function inflate(val) {\n                this.left -= val;\n                this.top -= val;\n                this.right += val;\n                this.bottom += val;\n                return this;\n            }\n        }, {\n            key: 'clip',\n            value: function clip(clipRect) {\n                //FIXME: In theory, we should be more careful about how we handle rects where right < left or bottom < top\n                if (this.left < clipRect.minX) this.left = clipRect.minX;else if (this.left > clipRect.maxX) this.left = clipRect.maxX;\n\n                if (this.right < clipRect.minX) this.right = clipRect.minX;else if (this.right > clipRect.maxX) this.right = clipRect.maxX;\n\n                if (this.top < clipRect.minY) this.top = clipRect.minY;else if (this.top > clipRect.maxY) this.top = clipRect.maxY;\n\n                if (this.bottom > clipRect.maxY) this.bottom = clipRect.maxY;else if (this.bottom < clipRect.minY) this.bottom = clipRect.minY;\n\n                return this;\n            }\n        }, {\n            key: 'clone',\n            value: function clone() {\n                return new Rect(this);\n            }\n        }, {\n            key: 'swapXY',\n            value: function swapXY() {\n                var _ref = [this.top, this.left];\n                this.left = _ref[0];\n                this.top = _ref[1];\n                var _ref2 = [this.right, this.bottom];\n                this.bottom = _ref2[0];\n                this.right = _ref2[1];\n\n                return this;\n            }\n        }, {\n            key: 'width',\n            get: function get() {\n                return this.right - this.left;\n            }\n        }, {\n            key: 'height',\n            get: function get() {\n                return this.bottom - this.top;\n            }\n        }, {\n            key: 'maxY',\n            get: function get() {\n                return Math.max(this.bottom, this.top);\n            }\n        }, {\n            key: 'minY',\n            get: function get() {\n                return Math.min(this.bottom, this.top);\n            }\n        }, {\n            key: 'minX',\n            get: function get() {\n                return Math.min(this.left, this.right);\n            }\n        }, {\n            key: 'maxX',\n            get: function get() {\n                return Math.max(this.left, this.right);\n            }\n        }, {\n            key: 'xMidpoint',\n            get: function get() {\n                return (this.left + this.right) / 2;\n            }\n        }, {\n            key: 'yMidpoint',\n            get: function get() {\n                return (this.top + this.bottom) / 2;\n            }\n        }, {\n            key: 'area',\n            get: function get() {\n                return Math.abs(this.width) * Math.abs(this.height);\n            }\n        }]);\n        return Rect;\n    }();\n\n    var BarRenderer = function (_renderer$Renderer) {\n        babelHelpers.inherits(BarRenderer, _renderer$Renderer);\n\n        function BarRenderer(ctx, tayberry, series) {\n            babelHelpers.classCallCheck(this, BarRenderer);\n\n            var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BarRenderer).call(this, ctx, tayberry, series));\n\n            _this.barPositions = null;\n\n            _this.tb.registerCallback('onResize', _this.updateBarWidths.bind(_this));\n            _this.tb.registerCallback('onInit', _this.updateBarWidths.bind(_this));\n            return _this;\n        }\n\n        babelHelpers.createClass(BarRenderer, [{\n            key: 'updateBarWidths',\n            value: function updateBarWidths() {\n                var categoryCount = this.series[0].data.length;\n                var isStacked = this.tb.options.barPlot.mode === 'stacked';\n                var isOverlaid = this.tb.options.barPlot.mode === 'overlaid';\n                var isNormal = !isStacked && !isOverlaid;\n                var seriesCount = this.series.length;\n                var plotArea = this.tb.options.swapAxes ? this.tb.plotArea.clone().swapXY() : this.tb.plotArea;\n                var categoryWidth = plotArea.width / categoryCount;\n                var animatingSeriesCount = 0;\n                var totalMultiplier = 0;\n\n                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\n                    var series = this.series[seriesIndex];\n                    var rState = series.rState;\n                    if (series.animationState) {\n                        if (!series.animationState.subtype) {\n                            var visibleSeriesCount = this.getVisibleSeriesCount(seriesIndex);\n                            if (isNormal && visibleSeriesCount > 0) {\n                                series.animationState.subtype = 'width';\n                            } else if (isStacked && visibleSeriesCount > 0) {\n                                series.animationState.subtype = 'height';\n                            } else {\n                                series.animationState.subtype = 'fade';\n                            }\n\n                            rState.colour = series.colour;\n                        }\n\n                        var isShow = series.animationState.type === 'show';\n                        if (series.animationState.subtype === 'width') {\n                            rState.multiplier = isShow ? series.animationState.stage : 1 - series.animationState.stage;\n                            rState.yMultiplier = 1;\n                        } else if (series.animationState.subtype === 'height') {\n                            rState.yMultiplier = isShow ? series.animationState.stage : 1 - series.animationState.stage;\n                            rState.multiplier = 1;\n                        } else {\n                            var transColour = new Colour(series.colour);\n                            transColour.a = 0;\n                            if (isShow) rState.colour = Colour.createFromBlend(transColour, new Colour(series.colour), series.animationState.stage).toString();else rState.colour = Colour.createFromBlend(new Colour(series.colour), transColour, series.animationState.stage).toString();\n\n                            rState.yMultiplier = 1;\n                            rState.multiplier = 1;\n                        }\n                        ++animatingSeriesCount;\n                    } else if (series.visible & visibilityState.visible) {\n                        rState.multiplier = 1;\n                        rState.yMultiplier = 1;\n                    } else {\n                        rState.multiplier = 0;\n                        rState.yMultiplier = 0;\n                    }\n                    totalMultiplier += rState.multiplier;\n                }\n\n                var totalBarsPerCategory = isStacked || isOverlaid ? 1 : totalMultiplier;\n                var yOrigin = this.series[0].yAxis.getOrigin();\n\n                this.barPositions = [];\n\n                for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {\n                    var yBottomPositive = yOrigin;\n                    var yBottomNegative = yOrigin;\n                    var yRunningTotalPositive = 0;\n                    var yRunningTotalNegative = 0;\n\n                    var categoryXStart = plotArea.left + Math.floor(categoryIndex * categoryWidth);\n                    var categoryXEnd = plotArea.left + Math.floor((categoryIndex + 1) * categoryWidth);\n                    // FIXME: Need to map this.tb.options.barPlot.categorySpacing\n                    var barXStart = categoryXStart + Math.ceil(categoryWidth * this.tb.options.barPlot.categorySpacing / 2);\n                    var barXEnd = categoryXEnd - Math.floor(categoryWidth * this.tb.options.barPlot.categorySpacing / 2);\n\n                    var categoryPositions = [];\n                    var barIndex = 0;\n\n                    var runningBarWidth = 0;\n\n                    for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\n                        var series = this.series[seriesIndex];\n                        var rState = series.rState;\n                        var value = Tayberry$1.getDataValue(series.data[categoryIndex]) * rState.yMultiplier;\n\n                        var barWidth = Math.floor(rState.multiplier * Math.floor((barXEnd - barXStart) / totalBarsPerCategory));\n\n                        var xStart = Math.floor(barXStart + runningBarWidth) + Math.ceil(series.xAxis.mapLogicalXOrYUnit(this.tb.options.barPlot.barPadding) / 2);\n                        var xEnd = Math.ceil(barXStart + runningBarWidth + barWidth) - Math.floor(series.xAxis.mapLogicalXOrYUnit(this.tb.options.barPlot.barPadding) / 2);\n                        var yTop = series.yAxis.getValueDisplacement(value + (value > 0 ? yRunningTotalPositive : yRunningTotalNegative));\n                        var yBottom = isStacked ? value > 0 ? yBottomPositive : yBottomNegative : yOrigin;\n\n                        categoryPositions.push([xStart, yTop, xEnd, yBottom]);\n\n                        if (isStacked) {\n                            if (value > 0) {\n                                yRunningTotalPositive += value;\n                                yBottomPositive = yTop;\n                            } else {\n                                yRunningTotalNegative += value;\n                                yBottomNegative = yTop;\n                            }\n                        } else if (isNormal) {\n                            barIndex++;\n                            runningBarWidth += barWidth;\n                        }\n                    }\n\n                    this.barPositions.push(categoryPositions);\n                }\n            }\n        }, {\n            key: 'onToggleSeriesAnimationFrame',\n            value: function onToggleSeriesAnimationFrame() {\n                this.updateBarWidths();\n            }\n        }, {\n            key: 'drawPlot',\n            value: function drawPlot() {\n                this.ctx.save();\n                var barEnumerator = new BarEnumerator(this);\n                var bar = undefined;\n                while (bar = barEnumerator.next()) {\n                    if (bar.series.visible & (visibilityState.visible | visibilityState.transitioning)) {\n                        this.ctx.fillStyle = bar.selected ? bar.series.rState.highlightColour : bar.series.rState.colour;\n                        this.ctx.fillRect(bar.rect.left, bar.rect.top, bar.rect.width, bar.rect.height);\n                    }\n                }\n                this.ctx.restore();\n            }\n        }, {\n            key: 'drawLabels',\n            value: function drawLabels() {\n                if (this.tb.options.labels.enabled) {\n                    this.ctx.save();\n                    var barEnumerator = new BarEnumerator(this);\n                    var bar = undefined;\n                    while (bar = barEnumerator.next()) {\n                        if ((bar.series.visible & (visibilityState.visible | visibilityState.transitioning)) === visibilityState.visible) {\n                            this.ctx.font = this.tb.labelFont;\n                            this.ctx.fillStyle = this.tb.options.labels.font.colour;\n                            this.drawLabel(bar.value, bar.series.yAxis.options.labelFormatter(bar.value), bar.rect);\n                        }\n                    }\n                    this.ctx.restore();\n                }\n            }\n        }, {\n            key: 'hitTest',\n            value: function hitTest(x, y) {\n                // TODO: Optimise\n                var ret = {\n                    found: false,\n                    plotType: 'bar',\n                    type: 'plotItem',\n                    isXRange: true\n                };\n\n                var categoryCount = this.series[0].data.length;\n                var isHorizontal = this.tb.options.swapAxes;\n                var plotArea = this.tb.plotArea.clone();\n                if (isHorizontal) plotArea.swapXY();\n                var categoryIndex = Math.floor(categoryCount * ((isHorizontal ? y : x) - plotArea.left) / plotArea.width);\n\n                var matches = [];\n\n                var barEnumerator = new BarEnumerator(this, categoryIndex);\n                var bar = undefined;\n                while (bar = barEnumerator.next()) {\n                    if (bar.categoryIndex > categoryIndex) break;\n                    if (!(bar.series.visible & (visibilityState.visible | visibilityState.transitioning))) continue;\n\n                    var sortDistance = undefined,\n                        priority = undefined,\n                        realDistance = undefined;\n                    if (bar.rect.containsPoint(x, y)) {\n                        sortDistance = 0;\n                        priority = 0;\n                    } else if (bar.rect.containsX(x)) {\n                        sortDistance = y < bar.rect.top ? bar.rect.top - y : y - bar.rect.bottom;\n                        priority = isHorizontal ? 2 : 1;\n                    } else if (bar.rect.containsY(y)) {\n                        sortDistance = x < bar.rect.left ? bar.rect.left - x : x - bar.rect.right;\n                        priority = isHorizontal ? 1 : 2;\n                    } else {\n                        var xDist = Math.min(Math.abs(x - bar.rect.left), Math.abs(x - bar.rect.right));\n                        var yDist = Math.min(Math.abs(y - bar.rect.top), Math.abs(y - bar.rect.bottom));\n                        realDistance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n                        sortDistance = isHorizontal ? yDist : xDist;\n                        priority = 3;\n                    }\n\n                    if (typeof realDistance === 'undefined') realDistance = sortDistance;\n\n                    if (!isMissingValue(realDistance)) {\n                        matches.push({\n                            sortDistance: sortDistance,\n                            distance: realDistance,\n                            priority: priority,\n                            data: {\n                                categoryIndex: bar.categoryIndex,\n                                seriesIndex: bar.seriesIndex,\n                                rect: bar.rect,\n                                series: bar.series,\n                                value: Tayberry$1.getDataValue(this.series[bar.seriesIndex].data[bar.categoryIndex])\n                            }\n                        });\n                    }\n                }\n\n                if (matches.length) {\n                    matches.sort(function (a, b) {\n                        var ret = a.priority - b.priority;\n                        if (!ret) ret = a.sortDistance - b.sortDistance;\n                        if (!ret) ret = a.data.rect.height - b.data.rect.height;\n                        return ret;\n                    });\n                    ret.found = true;\n                    ret.normalisedDistance = matches[0].distance + Math.sqrt(matches[0].data.rect.area);\n                    if (ret.normalisedDistance < 0) {\n                        ret.normalisedDistance = 0;\n                    }\n                    ret = assign(ret, matches[0].data);\n                }\n                return ret;\n            }\n        }]);\n        return BarRenderer;\n    }(Renderer);\n\n    var BarEnumerator = function (_renderer$ByCategoryE) {\n        babelHelpers.inherits(BarEnumerator, _renderer$ByCategoryE);\n\n        function BarEnumerator() {\n            babelHelpers.classCallCheck(this, BarEnumerator);\n            return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BarEnumerator).apply(this, arguments));\n        }\n\n        babelHelpers.createClass(BarEnumerator, [{\n            key: 'next',\n            value: function next() {\n                var ret = undefined;\n\n                if (this.categoryIndex < this.categoryCount) {\n                    var _renderer$barPosition = babelHelpers.slicedToArray(this.renderer.barPositions[this.categoryIndex][this.seriesIndex], 4);\n\n                    var xStart = _renderer$barPosition[0];\n                    var yTop = _renderer$barPosition[1];\n                    var xEnd = _renderer$barPosition[2];\n                    var yBottom = _renderer$barPosition[3];\n\n                    var rect = new Rect(xStart, yTop, xEnd, yBottom);\n\n                    if (rect.right < rect.left) rect.right = rect.left;\n                    if (this.isHorizontal) rect.swapXY();\n                    rect.clip(this.tb.plotArea);\n\n                    ret = {\n                        seriesIndex: this.seriesIndex,\n                        categoryIndex: this.categoryIndex,\n                        series: this.renderer.series[this.seriesIndex],\n                        value: Tayberry$1.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]),\n                        rect: rect,\n                        selected: this.tb.selectedItem.type === 'plotItem' && this.tb.selectedItem.categoryIndex === this.categoryIndex && (this.tb.options.tooltips.shared || this.tb.selectedItem.series === this.renderer.series[this.seriesIndex])\n                    };\n\n                    this.nextValue();\n                }\n                return ret;\n            }\n        }]);\n        return BarEnumerator;\n    }(ByCategoryEnumerator);\n\n    var autoMarkerIndex = 0;\n    var markers = ['square', 'diamond', 'circle', 'triangle', 'triangle-inversed'];\n\n    var LineRenderer = function (_renderer$Renderer) {\n        babelHelpers.inherits(LineRenderer, _renderer$Renderer);\n\n        function LineRenderer(ctx, tayberry, series) {\n            babelHelpers.classCallCheck(this, LineRenderer);\n\n            var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(LineRenderer).call(this, ctx, tayberry, series));\n\n            _this.pointPositions = null;\n\n            _this.tb.registerCallback('onResize', _this.updatPointPositions.bind(_this));\n            _this.tb.registerCallback('onInit', _this.updatPointPositions.bind(_this));\n            return _this;\n        }\n\n        babelHelpers.createClass(LineRenderer, [{\n            key: 'updatPointPositions',\n            value: function updatPointPositions() {\n                var seriesCount = this.series.length;\n\n                this.pointPositions = [];\n\n                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\n                    var series = this.series[seriesIndex];\n                    var rState = series.rState;\n                    if (series.animationState) {\n                        if (!series.animationState.subtype) {\n                            series.animationState.subtype = 'height';\n                        }\n\n                        var isShow = series.animationState.type === 'show';\n                        if (series.animationState.subtype === 'height') {\n                            rState.yMultiplier = isShow ? series.animationState.stage : 1 - series.animationState.stage;\n                            rState.xMultiplier = 1;\n                        }\n                    } else if (series.visible & visibilityState.visible) {\n                        rState.xMultiplier = 1;\n                        rState.yMultiplier = 1;\n                    } else {\n                        rState.xMultiplier = 1;\n                        rState.yMultiplier = 0;\n                    }\n                }\n\n                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\n                    var series = this.series[seriesIndex];\n                    var rState = series.rState;\n                    var valueCount = series.data.length;\n                    var yOrigin = series.yAxis.valueOrigin;\n                    var seriesPositions = [];\n\n                    for (var valueIndex = 0; valueIndex < valueCount; valueIndex++) {\n                        var value = Tayberry$1.getDataValue(series.data[valueIndex]);\n                        var xValue = Tayberry$1.getDataXValue(series.data, valueIndex);\n\n                        var rValue = yOrigin + rState.yMultiplier * (value - yOrigin);\n                        var x = series.xAxis.getValueDisplacement(xValue) * rState.xMultiplier;\n                        var y = series.yAxis.getValueDisplacement(rValue);\n\n                        seriesPositions.push([x, y]);\n                    }\n\n                    this.pointPositions.push(seriesPositions);\n                }\n            }\n        }, {\n            key: 'setSeries',\n            value: function setSeries(series) {\n                var totalPoints = 0;\n                for (var i = 0; i < series.length; i++) {\n                    if (!series[i].markerType) {\n                        series[i].markerType = markers[autoMarkerIndex % markers.length];\n                        autoMarkerIndex++;\n                    }\n                    totalPoints += series[i].data.length;\n                }\n                var showMarkers = this.tb.options.linePlot.showMarkers;\n                this.showMarkers = showMarkers === 'auto' ? totalPoints < this.tb.options.linePlot.noMarkersThreshold : showMarkers;\n                babelHelpers.get(Object.getPrototypeOf(LineRenderer.prototype), 'setSeries', this).call(this, series);\n            }\n        }, {\n            key: 'drawMarker',\n            value: function drawMarker(type, x, y, size) {\n                var ctx = arguments.length <= 4 || arguments[4] === undefined ? this.ctx : arguments[4];\n\n                if (type === 'square') {\n                    ctx.fillRect(x - size / 2, y - size / 2, size, size);\n                } else if (type === 'diamond') {\n                    ctx.save();\n                    ctx.translate(x, y);\n                    ctx.rotate(-Math.PI / 4);\n                    ctx.fillRect(0 - size / 2, 0 - size / 2, size, size);\n                    ctx.restore();\n                } else if (type === 'circle') {\n                    size = Math.round(size * 1.2);\n                    ctx.beginPath();\n                    ctx.arc(x, y, size / 2, 0, 2 * Math.PI);\n                    ctx.fill();\n                } else if (type === 'triangle' || type === 'triangle-inversed' && (size = -size)) {\n                    size = Math.round(size * 1.2);\n                    ctx.beginPath();\n                    ctx.moveTo(x - size / 2, y + size / 2);\n                    ctx.lineTo(x, y - size / 2);\n                    ctx.lineTo(x + size / 2, y + size / 2);\n                    ctx.closePath();\n                    ctx.fill();\n                }\n            }\n        }, {\n            key: 'onToggleSeriesAnimationFrame',\n            value: function onToggleSeriesAnimationFrame() {\n                this.updatPointPositions();\n            }\n        }, {\n            key: 'drawPlot',\n            value: function drawPlot() {\n                this.ctx.save();\n                var pointEnumerator = new PointEnumerator(this);\n                var pt = undefined;\n                while (pt = pointEnumerator.next()) {\n                    if (!(pt.series.visible & (visibilityState.visible | visibilityState.transitioning))) continue;\n\n                    if (pt.firstPoint) {\n                        this.ctx.lineWidth = pt.seriesSelected ? this.tb.options.linePlot.highlightedLineWidth : this.tb.options.linePlot.lineWidth;\n                        this.ctx.strokeStyle = pt.seriesSelected ? pt.series.rState.highlightColour : pt.series.rState.colour;\n                        this.ctx.beginPath();\n                        this.ctx.moveTo(pt.x, pt.y);\n                    } else {\n                        this.ctx.lineTo(pt.x, pt.y);\n                    }\n                    if (pt.lastPoint) {\n                        this.ctx.stroke();\n                    }\n                }\n                if (this.showMarkers) {\n                    pointEnumerator = new PointEnumerator(this);\n                    while (pt = pointEnumerator.next()) {\n                        if (!(pt.series.visible & (visibilityState.visible | visibilityState.transitioning))) continue;\n\n                        if (pt.selected) {\n                            this.ctx.fillStyle = pt.series.rState.glowColour;\n                            this.drawMarker(pt.series.markerType, pt.x, pt.y, this.tb.options.linePlot.highlightedMarkerSize);\n                        }\n                        this.ctx.fillStyle = pt.series.rState.colour;\n                        this.drawMarker(pt.series.markerType, pt.x, pt.y, this.tb.options.linePlot.markerSize);\n                    }\n                }\n                this.ctx.restore();\n            }\n        }, {\n            key: 'drawLegendIndicator',\n            value: function drawLegendIndicator(ctx, series, rect, highlighted) {\n                var colour = highlighted ? series.highlightColour : series.colour;\n                ctx.save();\n                ctx.lineWidth = 2;\n                ctx.strokeStyle = colour;\n                this.tb.drawLine(rect.left, rect.yMidpoint, rect.right, rect.yMidpoint);\n                ctx.fillStyle = colour;\n                this.drawMarker(series.markerType, rect.xMidpoint, rect.yMidpoint, this.tb.options.linePlot.markerSize, ctx);\n                ctx.restore();\n            }\n        }, {\n            key: 'drawLabels',\n            value: function drawLabels() {\n                if (this.tb.options.labels.enabled) {\n                    this.ctx.save();\n                    this.ctx.font = this.tb.labelFont;\n                    this.ctx.fillStyle = this.tb.options.labels.font.colour;\n                    var pointEnumerator = new PointEnumerator(this);\n                    var pt = undefined;\n                    while (pt = pointEnumerator.next()) {\n                        if (!(pt.series.visible & (visibilityState.visible | visibilityState.transitioning))) continue;\n\n                        var rect = new Rect(pt.x, pt.y, pt.x, pt.y).inflate(this.tb.options.linePlot.markerSize / 2);\n                        this.drawLabel(pt.value, pt.series.yAxis.options.labelFormatter(pt.value), rect);\n                    }\n                    this.ctx.restore();\n                }\n            }\n        }, {\n            key: 'hitTest',\n            value: function hitTest(x, y) {\n                // TODO: Optimise\n                var ret = {\n                    found: false,\n                    plotType: 'line',\n                    type: 'plotItem',\n                    isXRange: false\n                };\n\n                var matches = [];\n\n                var pointEnumerator = new PointEnumerator(this);\n                var pt = undefined;\n                while (pt = pointEnumerator.next()) {\n                    if (!(pt.series.visible & (visibilityState.visible | visibilityState.transitioning))) continue;\n\n                    var distance = Math.sqrt(Math.pow(pt.x - x, 2) + Math.pow(pt.y - y, 2));\n                    var horizontalDistance = Math.abs(this.tb.options.swapAxes ? pt.y - y : pt.x - x);\n                    matches.push({\n                        distance: distance,\n                        horizontalDistance: horizontalDistance,\n                        priority: 0,\n                        data: pt\n                    });\n                    //if (!pt.firstPoint) {\n                    //    if (x >= lastPt.x && x < pt.x) {\n                    //const alpha = Math.arctan((pt.y - lastPt.y) / (pt.x - lastPt.x));\n                    //const yAtX = (x - lastPt.x) * Math.tan(alpha) + lastPt.y;\n                    //if (yAtX - 2 <= y < yAtX + 2) {\n                    //    matches.push({\n                    //        categoryIndex: pt.categoryIndex,\n                    //        seriesIndex: pt.seriesIndex,\n                    //        x: bar.rect,\n                    //        series: this.series[bar.seriesIndex],\n                    //        dataPoint: this.series[bar.seriesIndex].data[bar.categoryIndex]\n                    //\n                    //    })\n                    //}\n                    //}\n                    //}\n                    //lastPt = pt;\n                }\n                if (matches.length) {\n                    matches.sort(function (e1, e2) {\n                        return e1.horizontalDistance - e2.horizontalDistance || e1.distance - e2.distance;\n                    });\n                    if (true || matches[0].distance <= 5) {\n                        pt = matches[0].data;\n                        var rect = new Rect(pt.x, pt.y, pt.x, pt.y).inflate(this.tb.options.linePlot.markerSize / 2);\n                        assign(ret, [{\n                            found: true,\n                            rect: rect,\n                            normalisedDistance: matches[0].distance + Math.sqrt(rect.area)\n                        }, pt]);\n                    }\n                }\n\n                return ret;\n            }\n        }]);\n        return LineRenderer;\n    }(Renderer);\n\n    var PointEnumerator = function (_renderer$BySeriesEnu) {\n        babelHelpers.inherits(PointEnumerator, _renderer$BySeriesEnu);\n\n        function PointEnumerator() {\n            babelHelpers.classCallCheck(this, PointEnumerator);\n            return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PointEnumerator).apply(this, arguments));\n        }\n\n        babelHelpers.createClass(PointEnumerator, [{\n            key: 'next',\n            value: function next() {\n                var ret = undefined;\n\n                if (this.seriesIndex < this.seriesCount) {\n                    var _renderer$pointPositi = babelHelpers.slicedToArray(this.renderer.pointPositions[this.seriesIndex][this.categoryIndex], 2);\n\n                    var x = _renderer$pointPositi[0];\n                    var y = _renderer$pointPositi[1];\n\n                    if (this.isHorizontal) {\n                        ;\n\n                        var _ref = [y, x];\n                        x = _ref[0];\n                        y = _ref[1];\n                    }ret = {\n                        firstPoint: this.categoryIndex === 0,\n                        lastPoint: this.categoryIndex + 1 === this.categoryCount,\n                        seriesIndex: this.seriesIndex,\n                        categoryIndex: this.categoryIndex,\n                        series: this.renderer.series[this.seriesIndex],\n                        value: Tayberry$1.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]),\n                        x: x,\n                        y: y,\n                        seriesSelected: this.tb.selectedItem.type === 'plotItem' && !this.tb.options.tooltips.shared && this.tb.selectedItem.series === this.renderer.series[this.seriesIndex],\n                        selected: this.tb.selectedItem.type === 'plotItem' && this.tb.selectedItem.categoryIndex === this.categoryIndex && (this.tb.options.tooltips.shared || this.tb.selectedItem.series === this.renderer.series[this.seriesIndex])\n                    };\n\n                    this.nextValue();\n                }\n                return ret;\n            }\n        }]);\n        return PointEnumerator;\n    }(BySeriesEnumerator);\n\n    var currentAutoColourIndex = 0;\n\n    Tayberry$1.getAutoColour = function () {\n        var ret = Tayberry$1.defaultColours[currentAutoColourIndex % Tayberry$1.defaultColours.length];\n        currentAutoColourIndex++;\n        return ret;\n    };\n\n    Tayberry$1.getDataValue = function (dataPoint) {\n        var ret = undefined;\n        if (Array.isArray(dataPoint)) {\n            ret = dataPoint[1];\n        } else {\n            ret = dataPoint;\n        }\n        return ret;\n    };\n\n    Tayberry$1.getDataXValue = function (data, index) {\n        var ret = undefined;\n        if (Array.isArray(data[index])) {\n            ret = data[index][0];\n        } else {\n            ret = index;\n        }\n        return ret;\n    };\n\n    Tayberry$1.setDataValue = function (data, index, newValue) {\n        if (Array.isArray(data[index])) {\n            data[index][1] = newValue;\n        } else {\n            data[index] = newValue;\n        }\n    };\n\n    Tayberry$1.prototype.createCanvas = function () {\n        var ret = document.createElement('canvas');\n        // IE11 hack-fix - clientWidth sometimes incorrect on first access\n        ret.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\n        ret.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\n        ret.style.height = Math.floor(this.containerElement.clientHeight) + 'px';\n        ret.style.position = 'absolute';\n        this.containerElement.appendChild(ret);\n        return ret;\n    };\n\n    Tayberry$1.prototype.create = function (containerElement) {\n        if (typeof containerElement == 'string') {\n            this.containerElement = document.getElementById(containerElement);\n        } else {\n            this.containerElement = containerElement;\n        }\n        this.labelsCanvas = this.createCanvas();\n        this.labelsCtx = this.labelsCanvas.getContext('2d');\n        this.plotCanvas = this.createCanvas();\n        this.plotCtx = this.plotCanvas.getContext('2d');\n        this.options = {};\n        this.yAxes = null;\n        this.xAxes = null;\n        this.initialise();\n    };\n\n    Tayberry$1.prototype.destroy = function () {\n        this.labelsCanvas.parentNode.removeChild(this.labelsCanvas);\n        this.tooltipElement.parentNode.removeChild(this.tooltipElement);\n        this.options = {};\n        this.plotCanvas.removeEventListener('click', this.onClickReal);\n        this.plotCanvas.removeEventListener('mousemove', this.onMouseMoveReal);\n        this.plotCanvas.removeEventListener('mouseleave', this.onMouseLeaveReal);\n        // this.plotCanvas.removeEventListener('touchstart', this.onTouchStartReal);\n        window.removeEventListener('resize', this.onWindowResizeReal);\n    };\n\n    Tayberry$1.prototype.initialise = function () {\n        this.scaleFactor = window.devicePixelRatio || 1.0;\n        this.labelsCanvas.width = Math.round(this.labelsCanvas.clientWidth * this.scaleFactor);\n        this.labelsCanvas.height = Math.round(this.labelsCanvas.clientHeight * this.scaleFactor);\n        this.plotCanvas.width = this.labelsCanvas.width;\n        this.plotCanvas.height = this.labelsCanvas.height;\n        this.scaleFactorX = this.labelsCanvas.width / this.labelsCanvas.clientWidth;\n        this.scaleFactorY = this.labelsCanvas.height / this.labelsCanvas.clientHeight;\n        this.selectedItem = {};\n        this.plotArea = null;\n    };\n\n    Tayberry$1.prototype.getFontHeight = function (font, forDom) {\n        var ret = font.size;\n        if (font.autoScale) ret *= Math.pow(this.labelsCanvas.width / 800, 0.25);\n        if (!forDom) ret = this.mapLogicalYUnit(ret);\n        return ret;\n    };\n\n    Tayberry$1.prototype.createFontString = function (font, forDom) {\n        return (font.style ? font.style + ' ' : '') + this.getFontHeight(font, forDom).toFixed(1) + 'px ' + font.face;\n    };\n\n    Tayberry$1.prototype.updateFonts = function () {\n        //this.labelsCtx.font = this.createFontString(this.options.font);\n        this.titleFont = this.createFontString(this.options.title.font);\n        this.labelFont = this.createFontString(this.options.labels.font);\n        this.legendFont = this.createFontString(this.options.legend.font);\n        this.yAxes.map(function (e) {\n            return e.updateFonts();\n        });\n        this.xAxes.map(function (e) {\n            return e.updateFonts();\n        });\n    };\n\n    Tayberry$1.prototype.setOptions = function (options) {\n        var optionOverrides = [this.defaultOptions()];\n        if (!options.presets) {\n            options.presets = ['default'];\n        }\n        if (options.presets) {\n            for (var index = 0; index < options.presets.length; index++) {\n                optionOverrides.push(Tayberry$1.presets[options.presets[index]]);\n            }\n        }\n        optionOverrides.push(options);\n        this.options = deepAssign({}, optionOverrides);\n        this.options.title.font = deepAssign({}, [this.options.font, this.options.title.font]);\n        this.options.tooltips.font = deepAssign({}, [this.options.font, this.options.tooltips.font]);\n        this.options.labels.font = deepAssign({}, [this.options.font, this.options.labels.font]);\n        this.options.legend.font = deepAssign({}, [this.options.font, this.options.legend.font]);\n        this.options.allAxes.font = deepAssign({}, [this.options.font, this.options.allAxes.font]);\n        this.options.allAxes.title.font = deepAssign({}, [this.options.font, this.options.allAxes.title.font]);\n        if (!Array.isArray(this.options.yAxis)) this.options.yAxis = [this.options.yAxis || {}];\n        if (!Array.isArray(this.options.xAxis)) this.options.xAxis = [this.options.xAxis || {}];\n        for (var i = 0; i < this.options.yAxis.length; i++) {\n            this.options.yAxis[i] = deepAssign({}, [i === 0 ? Tayberry$1.defaultPrimaryYAxis : Tayberry$1.defaultSecondaryYAxis, this.options.allAxes, this.options.yAxis[i]]);\n        }\n        for (var i = 0; i < this.options.xAxis.length; i++) {\n            this.options.xAxis[i] = deepAssign({}, [Tayberry$1.defaultXAxis, this.options.allAxes, this.options.xAxis[i]]);\n        }\n        for (var i = 0; i < this.options.series.length; i++) {\n            this.options.series[i] = deepAssign({}, [Tayberry$1.defaultSeries, this.options.series[i]]);\n        }\n\n        this.yAxes = [];\n        this.xAxes = [];\n        for (var i = 0; i < this.options.xAxis.length; i++) {\n            this.xAxes.push(Axis.create(this, this.options.xAxis[i], i, 'x', this.options.swapAxes));\n        }\n        for (var i = 0; i < this.options.yAxis.length; i++) {\n            this.yAxes.push(Axis.create(this, this.options.yAxis[i], i, 'y', this.options.swapAxes));\n        }\n        this.updateFonts();\n        this.createRenderers();\n        this.calculatePlotArea();\n        this.callbacks['onInit'].forEach(function (func) {\n            return func();\n        });\n        this.plotCanvas.addEventListener('click', this.onClickReal = this.onClick.bind(this));\n        this.plotCanvas.addEventListener('mousemove', this.onMouseMoveReal = this.onMouseMove.bind(this));\n        this.plotCanvas.addEventListener('mouseleave', this.onMouseLeaveReal = this.onMouseLeave.bind(this));\n        //this.plotCanvas.addEventListener('touchstart', this.onTouchStartReal = this.onTouchStart.bind(this));\n        window.addEventListener('resize', this.onWindowResizeReal = throttle(this.onWindowResize, 50).bind(this));\n    };\n\n    Tayberry$1.calculateHighlightColour = function (colour) {\n        var newColour = new Colour(colour);\n        return newColour.increaseBy(30 * (newColour.sum >= 180 * 3 ? -1 : 1)).toString();\n    };\n\n    Tayberry$1.calculateGlowColour = function (highlightColour) {\n        var newColour = new Colour(highlightColour);\n        newColour.a = 0.4;\n        return newColour.toString();\n    };\n\n    Tayberry$1.prototype.createRenderers = function () {\n        var series = undefined,\n            groupedSeries = { 'bar': [], 'line': [] };\n        if (!Array.isArray(this.options.series)) {\n            series = [this.options.series];\n        } else {\n            series = this.options.series;\n        }\n\n        for (var i = 0; i < series.length; i++) {\n            var curSeries = series[i];\n            curSeries.index = i;\n            curSeries.colour = curSeries.colour || Tayberry$1.getAutoColour();\n            curSeries.highlightColour = curSeries.highlightColour || Tayberry$1.calculateHighlightColour(curSeries.colour);\n            curSeries.glowColour = curSeries.glowColour || Tayberry$1.calculateGlowColour(curSeries.highlightColour);\n            curSeries.rState = {\n                colour: curSeries.colour,\n                highlightColour: curSeries.highlightColour,\n                glowColour: curSeries.glowColour\n            };\n            curSeries.xAxis = this.xAxes[curSeries.xAxisIndex || 0];\n            curSeries.yAxis = this.yAxes[curSeries.yAxisIndex || 0];\n            curSeries.plotType = curSeries.plotType || this.options.plotType;\n            if (groupedSeries.hasOwnProperty(curSeries.plotType)) {\n                groupedSeries[curSeries.plotType].push(curSeries);\n            }\n        }\n        if (groupedSeries['bar'].length) {\n            this.renderers.push(new BarRenderer(this.plotCtx, this, groupedSeries['bar']));\n        }\n        if (groupedSeries['line'].length) {\n            this.renderers.push(new LineRenderer(this.plotCtx, this, groupedSeries['line']));\n        }\n    };\n\n    Tayberry$1.prototype.getDataMinMax = function (axis) {\n        var minNormal, maxNormal, minStacked, maxStacked;\n        if (this.options.barPlot.mode === 'stacked') {\n            var seriesPositiveTotals = [];\n            var seriesNegativeTotals = [];\n            var barSeries = this.options.series.filter(function (series) {\n                return series.plotType === 'bar' && series.yAxis === axis;\n            });\n            if (barSeries.length) {\n                for (var categoryIndex = 0; categoryIndex < barSeries[0].data.length; categoryIndex++) {\n                    seriesPositiveTotals[categoryIndex] = 0;\n                    seriesNegativeTotals[categoryIndex] = 0;\n                    for (var seriesIndex = 0; seriesIndex < barSeries.length; seriesIndex++) {\n                        var value = Tayberry$1.getDataValue(barSeries[seriesIndex].data[categoryIndex]);\n                        if (!isMissingValue(value)) {\n                            if (value < 0) {\n                                seriesNegativeTotals[categoryIndex] += value;\n                            } else {\n                                seriesPositiveTotals[categoryIndex] += value;\n                            }\n                        }\n                    }\n                }\n            }\n            minStacked = Math.min(0, reduce(seriesNegativeTotals, Math.min, undefined, true));\n            maxStacked = Math.max(reduce(seriesPositiveTotals, Math.max, undefined, true), 0);\n        }\n        {\n            var seriesMinima = [];\n            var seriesMaxima = [];\n            for (var index = 0; index < this.options.series.length; index++) {\n                var series = this.options.series[index];\n                if (series.yAxis === axis && (series.plotType !== 'bar' || this.options.barPlot.mode !== 'stacked')) {\n                    seriesMinima.push(reduce(series.data, Math.min, Tayberry$1.getDataValue, true));\n                    seriesMaxima.push(reduce(series.data, Math.max, Tayberry$1.getDataValue, true));\n                }\n            }\n            minNormal = reduce(seriesMinima, Math.min, undefined, true);\n            maxNormal = reduce(seriesMaxima, Math.max, undefined, true);\n        }\n        var min = reduce([minNormal, minStacked], Math.min, undefined, true);\n        var max = reduce([maxNormal, maxStacked], Math.max, undefined, true);\n        return [min, max];\n    };\n\n    Tayberry$1.prototype.getDataXMinMax = function (axis) {\n        var min, max;\n        var seriesMinima = [];\n        var seriesMaxima = [];\n        for (var index = 0; index < this.options.series.length; index++) {\n            var series = this.options.series[index];\n            if (series.xAxis === axis) {\n                seriesMinima.push(reduce(series.data, Math.min, Tayberry$1.getDataXValue, true));\n                seriesMaxima.push(reduce(series.data, Math.max, Tayberry$1.getDataXValue, true));\n            }\n        }\n        min = reduce(seriesMinima, Math.min, undefined, true);\n        max = reduce(seriesMaxima, Math.max, undefined, true);\n        return [min, max];\n    };\n\n    Tayberry$1.prototype.createTooltip = function () {\n        if (this.tooltipElement) {\n            this.tooltipElement.parentNode.removeChild(this.tooltipElement);\n            this.tooltipElement = null;\n        }\n        this.tooltipElement = document.createElement('div');\n        this.tooltipElement.className = 'tayberry-tooltip';\n        this.tooltipElement.style.position = 'absolute';\n        this.tooltipElement.style.left = '0px';\n        this.tooltipElement.style.top = '0px';\n        this.tooltipElement.style.zIndex = '99999';\n        this.tooltipElement.style.font = this.createFontString(this.options.tooltips.font, true);\n        this.tooltipElement.style.borderRadius = '3px';\n        this.tooltipElement.style.backgroundColor = 'white';\n        this.tooltipElement.style.border = '2px solid #bbb';\n        this.tooltipElement.style.padding = '0.15em 0.4em';\n        this.tooltipElement.style.display = 'none';\n        this.tooltipElement.innerHTML = '';\n        document.body.appendChild(this.tooltipElement);\n        this.tooltipElement.addEventListener('mousemove', this.onMouseMove.bind(this));\n        this.tooltipElement.addEventListener('mouseleave', this.onMouseLeave.bind(this));\n    };\n\n    Tayberry$1.prototype.getTextWidth = function (text, fontString) {\n        var ret = undefined;\n        if (fontString) {\n            this.labelsCtx.save();\n            this.labelsCtx.font = fontString;\n        }\n        ret = this.labelsCtx.measureText(text).width;\n        if (fontString) {\n            this.labelsCtx.restore();\n        }\n        return ret;\n    };\n\n    Tayberry$1.prototype.getMultilineTextHeight = function (fontString, maxWidth, text) {\n        var ret = undefined;\n        if (fontString) {\n            this.labelsCtx.save();\n            this.labelsCtx.font = fontString;\n        }\n        ret = this.splitMultilineText(maxWidth, text).length;\n        if (fontString) {\n            this.labelsCtx.restore();\n        }\n        return ret;\n    };\n\n    Tayberry$1.prototype.splitMultilineText = function (maxWidth, text) {\n        var lines = [];\n        var lineWidth = 0;\n        var lineText = '';\n        var spaceWidth = this.labelsCtx.measureText(' ').width;\n        for (var i = 0; i < text.length;) {\n            var wordStart = i;\n            while (i < text.length && text[i] !== ' ' && text[i] !== '\\r' && text[i] !== '\\n') {\n                i++;\n            }var wordEnd = i;\n            while (i < text.length && (text[i] === ' ' || text[i] === '\\r' || text[i] === '\\n')) {\n                i++;\n            }if (wordEnd > wordStart) {\n                var word = text.substring(wordStart, wordEnd);\n                var wordWidth = this.labelsCtx.measureText(word).width;\n                if (lineWidth + wordWidth > maxWidth) {\n                    if (!lineWidth) {\n                        lineText = word;\n                    }\n                    lines.push(lineText);\n                    if (lineWidth) {\n                        lineWidth = 0;\n                        lineText = word;\n                    }\n                } else {\n                    lineText += (lineText ? ' ' : '') + word;\n                    lineWidth += wordWidth + spaceWidth;\n                }\n            }\n        }\n        if (lineText) {\n            lines.push(lineText);\n        }\n        return lines;\n    };\n\n    Tayberry$1.prototype.drawTextMultiline = function (lineHeight, x, y, maxWidth, text) {\n        var lines = this.splitMultilineText(maxWidth, text);\n\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i];\n            this.labelsCtx.fillText(line, x, y + lineHeight * i);\n        }\n    };\n\n    Tayberry$1.prototype.render = function () {\n        this.drawLabelLayer();\n        this.createTooltip();\n        if (this.options.animations.enabled) {\n            for (var index = 0; index < this.options.series.length; index++) {\n                var series = this.options.series[index];\n                this.setSeriesVisibility(series, true, 'height');\n            }\n        } else {\n            this.drawPlotLayer();\n        }\n    };\n\n    Tayberry$1.prototype.clear = function () {\n        var plot = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n        var labels = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n        if (plot) this.plotCtx.clearRect(0, 0, this.plotCanvas.width, this.plotCanvas.height);\n        if (labels) this.labelsCtx.clearRect(0, 0, this.labelsCanvas.width, this.labelsCanvas.height);\n    };\n\n    Tayberry$1.prototype.drawBackground = function () {\n        if (this.options.plotBackgroundColour) {\n            this.labelsCtx.save();\n            this.labelsCtx.fillStyle = this.options.plotBackgroundColour;\n            this.labelsCtx.fillRect(this.plotArea.left, this.plotArea.top, this.plotArea.width, this.plotArea.height);\n            this.labelsCtx.restore();\n        }\n    };\n\n    Tayberry$1.prototype.drawTitle = function () {\n        if (this.options.title.text) {\n            var x = this.labelsCanvas.width / 2,\n                y = 0;\n            this.labelsCtx.save();\n            this.labelsCtx.textAlign = 'center';\n            this.labelsCtx.textBaseline = 'top';\n            this.labelsCtx.font = this.titleFont;\n            this.labelsCtx.fillStyle = this.options.title.font.colour;\n            this.drawTextMultiline(this.getFontHeight(this.options.title.font), x, y, this.labelsCanvas.width, this.options.title.text);\n            // this.labelsCtx.fillText(this.options.title.text, x, y);\n            this.labelsCtx.restore();\n        }\n    };\n\n    Tayberry$1.prototype.drawPlotLayer = function () {\n        for (var i = 0; i < this.renderers.length; i++) {\n            this.renderers[i].drawPlot();\n        }\n        for (var i = 0; i < this.renderers.length; i++) {\n            this.renderers[i].drawLabels();\n        }\n    };\n\n    Tayberry$1.prototype.drawLine = function (x1, y1, x2, y2, colour) {\n        var ctx = arguments.length <= 5 || arguments[5] === undefined ? this.labelsCtx : arguments[5];\n\n        ctx.save();\n        if (colour) {\n            ctx.strokeStyle = colour;\n        }\n        ctx.beginPath();\n        ctx.moveTo(x1 + 0.5, y1 + 0.5);\n        ctx.lineTo(x2 + 0.5, y2 + 0.5);\n        ctx.stroke();\n        ctx.restore();\n    };\n\n    Tayberry$1.prototype.drawLabelLayer = function () {\n        this.drawBackground();\n        this.drawTitle();\n        var offsetRect = new Rect(0);\n        this.xAxes.map(function (e) {\n            return e.draw(offsetRect);\n        });\n        this.yAxes.map(function (e) {\n            return e.draw(offsetRect);\n        });\n        this.drawLegend();\n    };\n\n    Tayberry$1.prototype.redraw = function (plotOnly) {\n        this.clear(true, !plotOnly);\n        if (!plotOnly) {\n            this.drawLabelLayer();\n        }\n        this.drawPlotLayer();\n    };\n\n    Tayberry$1.prototype.registerCallback = function (eventName, func) {\n        this.callbacks[eventName].push(func);\n    };\n\n    Tayberry$1.prototype.onMouseLeave = function (event) {\n        if (event.currentTarget == this.plotCanvas && event.relatedTarget !== this.tooltipElement || event.currentTarget == this.tooltipElement && event.relatedTarget !== this.plotCanvas) {\n            this.selectedItem = {};\n            this.tooltipElement.style.display = 'none';\n            this.redraw();\n        }\n    };\n\n    Tayberry$1.prototype.handleMouseMove = function (clientX, clientY) {\n        var boundingRect = new Rect(this.plotCanvas.getBoundingClientRect());\n        var ret = false;\n        var tooltipDisplayStyle = 'none';\n        if (boundingRect.containsPoint(clientX, clientY)) {\n            var x = clientX - boundingRect.left;\n            var y = clientY - boundingRect.top;\n\n            var hitTestResult = this.hitTest(this.mapLogicalXUnit(x), this.mapLogicalYUnit(y));\n            if (hitTestResult.found) {\n                if (hitTestResult.type === 'legend') {\n                    this.selectedItem = hitTestResult;\n                    ret = true;\n                } else if (hitTestResult.type === 'plotItem') {\n                    var tooltipHtml = '';\n                    var aboveZero = hitTestResult.rect.top < hitTestResult.rect.bottom;\n                    tooltipDisplayStyle = 'block';\n                    if (this.options.tooltips.shared) {\n                        var category = this.xAxes[0].getCategoryLabel(hitTestResult.categoryIndex, this.categoryCount, hitTestResult.isXRange);\n                        tooltipHtml += formatString(this.options.tooltips.headerTemplate, { category: category }, true);\n                        for (var index = 0; index < this.seriesCount; index++) {\n                            var series = this.options.series[index];\n                            var value = Tayberry$1.getDataValue(series.data[hitTestResult.categoryIndex]);\n                            tooltipHtml += formatString(this.options.tooltips.valueTemplate, {\n                                value: series.yAxis.options.labelFormatter(value),\n                                name: series.name,\n                                colour: series.colour\n                            }, true);\n                        }\n                    } else {\n                        var series = hitTestResult.series;\n                        var value = hitTestResult.value;\n                        var category = series.xAxis.getCategoryLabel(hitTestResult.categoryIndex, this.categoryCount, hitTestResult.isXRange);\n                        tooltipHtml += formatString(this.options.tooltips.headerTemplate, { category: category }, true);\n                        tooltipHtml += formatString(this.options.tooltips.valueTemplate, {\n                            value: series.yAxis.options.labelFormatter(value),\n                            name: series.name,\n                            colour: series.colour\n                        }, true);\n                    }\n                    tooltipHtml += this.options.tooltips.footerTemplate;\n                    this.tooltipElement.innerHTML = tooltipHtml;\n                    var tooltipRect = this.tooltipElement.getBoundingClientRect();\n                    if (!this.options.tooltips.shared) {\n                        this.tooltipElement.style.borderColor = hitTestResult.series.colour;\n                    }\n                    this.tooltipElement.style.left = window.pageXOffset + boundingRect.left + this.mapScreenUnit(hitTestResult.rect.width) / 2 + hitTestResult.rect.left / this.scaleFactor - tooltipRect.width / 2 + 'px';\n                    this.tooltipElement.style.top = window.pageYOffset + boundingRect.top + this.mapScreenUnit(hitTestResult.rect.top) - tooltipRect.height * (aboveZero ? 1 : 0) - this.options.elementSmallPadding * (aboveZero ? 1 : -1) + 'px';\n                    this.selectedItem = hitTestResult;\n                    ret = true;\n                }\n            }\n        }\n        this.tooltipElement.style.display = tooltipDisplayStyle;\n        return ret;\n    };\n\n    //Tayberry.prototype.onTouchStart = function (event) {\n    //    for (let index = 0; index < event.targetTouches.length; index++) {\n    //        let touch = event.targetTouches[index];\n    //        if (this.handleMouseMove(touch.clientX, touch.clientY)) {\n    //            // event.preventDefault();\n    //            this.redraw();\n    //            break;\n    //        }\n    //    }\n    //};\n\n    Tayberry$1.prototype.onClick = function (event) {\n        var boundingRect = new Rect(this.plotCanvas.getBoundingClientRect());\n        // Why is event.buttons always 0?\n        if (event.button === 0 && boundingRect.containsPoint(event.clientX, event.clientY)) {\n            var x = event.clientX - boundingRect.left;\n            var y = event.clientY - boundingRect.top;\n            var hitTestResult = this.hitTest(this.mapLogicalXUnit(x), this.mapLogicalYUnit(y));\n            if (hitTestResult.found) {\n                if (hitTestResult.type === 'legend') {\n                    var series = hitTestResult.data.series;\n\n                    this.toggleSeriesVisibility(series);\n                    this.clear(false, true);\n                    this.drawLabelLayer();\n                }\n            }\n        }\n    };\n\n    Tayberry$1.prototype.onMouseMove = function (event) {\n        var oldSelectedItem = assign({}, this.selectedItem);\n        if (!this.handleMouseMove(event.clientX, event.clientY)) {\n            this.selectedItem = {};\n        }\n\n        if (oldSelectedItem.type !== this.selectedItem.type || oldSelectedItem.categoryIndex !== this.selectedItem.categoryIndex || oldSelectedItem.series !== this.selectedItem.series) {\n            this.redraw();\n        }\n    };\n\n    Tayberry$1.prototype.onWindowResize = function () {\n        this.tooltipElement.style.display = 'none';\n        this.labelsCanvas.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\n        this.labelsCanvas.style.height = Math.floor(this.containerElement.clientHeight) + 'px';\n        this.plotCanvas.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\n        this.plotCanvas.style.height = Math.floor(this.containerElement.clientHeight) + 'px';\n        this.initialise();\n        this.updateFonts();\n        this.calculatePlotArea();\n        this.createTooltip();\n        this.callbacks['onResize'].forEach(function (func) {\n            return func();\n        });\n        this.redraw();\n    };\n\n    Tayberry$1.prototype.defaultOptions = function () {\n        return {\n            title: {\n                text: '',\n                font: {\n                    size: 20\n                }\n            },\n            font: {\n                colour: '#444',\n                size: 12,\n                face: 'sans-serif',\n                style: '',\n                autoScale: true\n            },\n            allAxes: {\n                font: {},\n                title: {\n                    font: {}\n                }\n            },\n            xAxis: [],\n            yAxis: [],\n            animations: {\n                enabled: true\n            },\n            series: [],\n            backgroundColour: undefined,\n            swapAxes: false,\n            plotType: 'bar',\n            barPlot: {\n                mode: 'normal', //[normal|stacked|overlaid]\n                barPadding: 2,\n                categorySpacing: 0.3\n            },\n            linePlot: {\n                lineWidth: 2,\n                highlightedLineWidth: 4,\n                showMarkers: 'auto',\n                noMarkersThreshold: 100,\n                markerSize: 10,\n                highlightedMarkerSize: 18\n            },\n            elementSmallPadding: 5,\n            elementLargePadding: 10,\n            presets: [],\n            tooltips: {\n                shared: false,\n                headerTemplate: '<strong>{category}</strong><table>',\n                valueTemplate: '<tr><td style=\"padding-right: 0.5em\"><span style=\"color: {colour}\">●</span> {name}</td><td style=\"text-align: right\">{value}</td></tr>',\n                footerTemplate: '</table>',\n                font: {}\n            },\n            legend: {\n                enabled: true,\n                indicatorSize: 15,\n                font: {},\n                hiddenAlphaMultiplier: 0.5\n            },\n            labels: {\n                enabled: false,\n                verticalAlignment: 'top',\n                verticalPosition: 'outside',\n                font: {}\n            }\n        };\n    };\n\n    Tayberry$1.defaultSeries = {\n        visible: visibilityState.visible\n    };\n\n    Tayberry$1.defaultXAxis = {\n        title: {\n            text: '',\n            font: {}\n        },\n        type: 'categorial',\n        min: null,\n        max: null,\n        tickStep: 40,\n        tickStepValue: null,\n        font: {},\n        categories: [],\n        labelPosition: 'middle', //left|middle|right\n        placement: 'auto',\n        gridLines: {}\n    };\n\n    Tayberry$1.defaultYAxis = {\n        title: {\n            text: '',\n            font: {}\n        },\n        min: undefined,\n        max: undefined,\n        tickStep: 40,\n        tickStepValue: null,\n        font: {},\n        labelFormat: 'number', //[number|percentage|currency],\n        labelFormatter: undefined,\n        labelPrefix: undefined,\n        labelSuffix: undefined,\n        currencySymbol: '£',\n        placement: 'auto',\n        type: 'linear',\n        gridLines: {}\n\n    };\n\n    Tayberry$1.defaultPrimaryYAxis = deepAssign({}, [Tayberry$1.defaultYAxis, {\n        gridLines: {\n            colour: '#ccc'\n        }\n    }]);\n\n    Tayberry$1.defaultSecondaryYAxis = Tayberry$1.defaultYAxis;\n\n    Tayberry$1.presets = {\n        histogram: {\n            barPlot: {\n                mode: 'overlaid',\n                categorySpacing: 0,\n                barPadding: 1\n            }\n        },\n        darkGrid: {\n            allAxes: {\n                gridLines: {\n                    colour: 'rgba(255, 255, 255, 0.6)'\n                }\n            },\n            plotBackgroundColour: '#E5E5E5'\n        }\n    };\n\n    Tayberry$1.defaultColours = ['#6FE87B', //green\n    '#FFAB51', //orange\n    '#51A8FF', //blue\n    '#B651FF', //purple\n    '#FF6051', //red\n    '#636363', //dark grey\n    '#FFE314', //yellow\n    '#A88572', //brown\n    '#B7B7B7' //light grey\n    ];\n\n    Tayberry$1.mapVerticalPosition = function (sign, position) {\n        switch (position) {\n            case \"outside\":\n                return sign > 0 ? \"bottom\" : \"top\";\n            case \"inside\":\n                return sign > 0 ? \"top\" : \"bottom\";\n            default:\n                return \"middle\";\n        }\n    };\n\n    Tayberry$1.prototype.mapLogicalXUnit = function (x) {\n        return this.scaleFactorX * x;\n    };\n\n    Tayberry$1.prototype.mapLogicalYUnit = function (x) {\n        return this.scaleFactorY * x;\n    };\n\n    Tayberry$1.prototype.mapScreenUnit = function (x) {\n        return x / this.scaleFactor;\n    };\n\n    Tayberry$1.prototype.calculatePlotArea = function () {\n        var _this = this;\n\n        var MAX_AXIS_CALC_SIZE_ATTEMPTS = 5;\n\n        this.plotArea = new Rect(0, 0, this.labelsCanvas.width, this.labelsCanvas.height);\n        if (this.options.title.text) {\n            this.plotArea.top += this.mapLogicalYUnit(this.options.elementSmallPadding);\n            this.plotArea.top += this.getFontHeight(this.options.title.font) * this.getMultilineTextHeight(this.titleFont, this.labelsCanvas.width, this.options.title.text);\n        }\n        if (this.options.legend.enabled) this.plotArea.bottom -= this.mapLogicalYUnit(this.options.elementSmallPadding + this.options.elementLargePadding + this.options.legend.indicatorSize);\n\n        this.yAxes.map(function (e) {\n            return e.adjustSize(_this.plotArea, true, true);\n        });\n        this.xAxes.map(function (e) {\n            return e.adjustSize(_this.plotArea, true, true);\n        });\n\n        for (var i = 0; i < MAX_AXIS_CALC_SIZE_ATTEMPTS; i++) {\n            this.yAxes.map(function (e) {\n                return e.calculateExtent();\n            });\n            this.xAxes.map(function (e) {\n                return e.calculateExtent();\n            });\n            this.yAxes.map(function (e) {\n                return e.updateFormatter();\n            });\n            this.xAxes.map(function (e) {\n                return e.updateFormatter();\n            });\n            if (none(this.yAxes.map(function (e) {\n                return e.adjustSize(_this.plotArea);\n            })) && none(this.xAxes.map(function (e) {\n                return e.adjustSize(_this.plotArea);\n            }))) break;\n        }\n        this.plotArea.left = Math.ceil(this.plotArea.left);\n        this.plotArea.top = Math.ceil(this.plotArea.top);\n        this.plotArea.right = Math.floor(this.plotArea.right);\n        this.plotArea.bottom = Math.floor(this.plotArea.bottom);\n    };\n\n    Tayberry$1.prototype.hitTest = function (x, y) {\n        var ret = {\n            found: false\n        };\n        var matches = [];\n        for (var i = 0; i < this.renderers.length; i++) {\n            var hitTestResult = this.renderers[i].hitTest(x, y);\n            if (hitTestResult.found) {\n                matches.push(hitTestResult);\n            }\n        }\n        matches.push(this.hitTestLegend(x, y));\n        if (matches.length) {\n            matches.sort(function (a, b) {\n                return !a.found - !b.found || a.normalisedDistance - b.normalisedDistance;\n            });\n            ret = matches[0];\n        }\n        return ret;\n    };\n\n    Tayberry$1.prototype.drawLegend = function () {\n        if (this.options.legend.enabled) {\n            var legendMetrics = this.getLegendMeasurements();\n            this.labelsCtx.save();\n            this.labelsCtx.font = this.legendFont;\n\n            for (var index = 0; index < legendMetrics.items.length; index++) {\n                var item = legendMetrics.items[index];\n                var series = item.series;\n                var highlighted = this.selectedItem.type === 'legend' && this.selectedItem.data.series === series;\n                series.renderer.drawLegendIndicator(this.labelsCtx, series, item.indicatorRect, highlighted);\n                this.labelsCtx.textBaseline = 'middle';\n                this.labelsCtx.fillStyle = this.options.legend.font.colour;\n                if (!(series.visible & visibilityState.visible)) this.labelsCtx.fillStyle = new Colour(this.labelsCtx.fillStyle).multiplyAlpha(this.options.legend.hiddenAlphaMultiplier).toString();\n                this.labelsCtx.fillText(series.name, item.textX, item.textY);\n            }\n            this.labelsCtx.restore();\n        }\n    };\n\n    Tayberry$1.prototype.hitTestLegend = function (x, y) {\n        var ret = {\n            found: false,\n            type: 'legend'\n        };\n        var legendMetrics = this.getLegendMeasurements();\n        if (legendMetrics.rect.containsPoint(x, y)) {\n            for (var index = 0; index < legendMetrics.items.length; index++) {\n                var item = legendMetrics.items[index];\n                if (item.rect.containsPoint(x, y)) {\n                    assign(ret, [{ found: true, normalisedDistance: -5, data: item }]);\n                    break;\n                }\n            }\n        }\n        return ret;\n    };\n\n    Tayberry$1.prototype.getLegendMeasurements = function () {\n        var ret = {\n            rect: new Rect(0),\n            items: []\n        };\n        if (this.options.legend.enabled) {\n            var smallPadding = this.mapLogicalXUnit(this.options.elementSmallPadding);\n            var largePadding = this.mapLogicalXUnit(this.options.elementLargePadding);\n            var totalWidth = 0;\n            var indicatorSize = this.mapLogicalXUnit(this.options.legend.indicatorSize);\n            for (var index = 0; index < this.options.series.length; index++) {\n                var series = this.options.series[index];\n                var textWidth = 0;\n                if (series.name) {\n                    textWidth = this.getTextWidth(series.name, this.legendFont);\n                    totalWidth += textWidth + indicatorSize + smallPadding + largePadding;\n                    ret.items.push({ textWidth: textWidth, series: series });\n                }\n            }\n            var x = this.plotArea.left + this.plotArea.width / 2 - totalWidth / 2,\n                y = this.labelsCanvas.height - indicatorSize;\n\n            ret.rect.left = x;\n            ret.rect.right = x + totalWidth;\n            ret.rect.top = y;\n            ret.rect.bottom = y + indicatorSize;\n\n            for (var index = 0; index < ret.items.length; index++) {\n                var item = ret.items[index];\n                item.rect = new Rect(x, ret.rect.top, x + indicatorSize + smallPadding + item.textWidth, ret.rect.bottom);\n                item.indicatorRect = new Rect(x, ret.rect.top, x + indicatorSize, ret.rect.bottom);\n                x += indicatorSize + smallPadding;\n                item.textX = x;\n                item.textY = y + indicatorSize / 2;\n\n                x += ret.items[index].textWidth + largePadding;\n            }\n        }\n        return ret;\n    };\n\n    Tayberry$1.prototype.revokeAnimation = function (series) {\n        for (var index = this.pendingAnimations.length; index; index--) {\n            if (this.pendingAnimations[index - 1].series === series) {\n                this.pendingAnimations.splice(index - 1, 1);\n            }\n        }\n    };\n\n    Tayberry$1.prototype.startAnimation = function (animation) {\n        animation.initialStage = animation.initialStage || 0;\n        var newAnimation = assign({}, [{\n            length: 500 * (1 - animation.initialStage),\n            startTime: typeof performance !== 'undefined' && typeof performance.now !== 'undefined' ? performance.now() : null\n        }, animation]);\n        this.pendingAnimations.push(newAnimation);\n        if (!this.animator) this.animator = requestAnimationFrame(this.onAnimate.bind(this));\n        return newAnimation;\n    };\n\n    Tayberry$1.prototype.onAnimate = function (timestamp) {\n        var elapsed;\n        for (var index = this.pendingAnimations.length - 1; index >= 0; index--) {\n            var animation = this.pendingAnimations[index];\n            if (animation.startTime === null) {\n                animation.startTime = timestamp;\n            }\n            elapsed = timestamp - animation.startTime;\n            if (animation.onFrame) {\n                animation.onFrame(animation.initialStage + Math.min(elapsed / animation.length, 1) * (1 - animation.initialStage));\n            }\n            if (elapsed >= animation.length) {\n                this.pendingAnimations.splice(index, 1);\n                if (animation.onCompletion) {\n                    animation.onCompletion();\n                }\n            }\n        }\n        for (var i = 0; i < this.renderers.length; i++) {\n            this.renderers[i].onAnimationFrame();\n        }\n        this.redraw(true);\n        if (this.pendingAnimations.length) {\n            this.animator = requestAnimationFrame(this.onAnimate.bind(this));\n        } else {\n            this.animator = null;\n        }\n    };\n\n    Tayberry$1.prototype.setSeriesVisibility = function (series, visible, subtype) {\n        series.visible = visible ? visibilityState.visible : visibilityState.hidden;\n        series.visible |= visibilityState.transitioning;\n\n        if (series.animationState) {\n            var newType = visible ? 'show' : 'hide';\n            if (series.animationState.type !== newType) {\n                series.animationState.type = newType;\n                series.animationState.stage = 1 - series.animationState.stage;\n\n                delete series.animationState.animator;\n                this.revokeAnimation(series);\n            }\n        } else {\n            series.animationState = {\n                type: series.visible & visibilityState.visible ? 'show' : 'hide',\n                subtype: subtype,\n                stage: 0\n            };\n        }\n        if (!series.animationState.animator) {\n            series.animationState.animator = this.startAnimation({\n                type: visible ? 'showSeries' : 'hideSeries',\n                series: series,\n                initialStage: series.animationState.stage,\n                onFrame: function onFrame(stage) {\n                    return series.animationState.stage = stage;\n                },\n                onCompletion: function onCompletion() {\n                    series.visible = series.visible & ~visibilityState.transitioning;\n                    delete series.animationState;\n                }\n            });\n        }\n    };\n\n    Tayberry$1.prototype.toggleSeriesVisibility = function (series) {\n        this.setSeriesVisibility(series, !(series.visible & visibilityState.visible));\n    };\n\n    var Tayberry = {\n        /**\r\n         * Creates a Tayberry chart\r\n         *\r\n         * @param element   ID of container div, or HTMLElement\r\n         * @param options   Options object\r\n         */\n        create: function create(element, options) {\n            var chart = new Tayberry$1();\n            chart.create(element);\n            chart.setOptions(options);\n            chart.render();\n        }\n    };\n\n    return Tayberry;\n\n}));\n//# sourceMappingURL=tayberry.js.map\n","'use strict';\r\n\r\nexport function identity(obj) {\r\n    return obj;\r\n}\r\n\r\nexport function isMissingValue(n) {\r\n    return n === null || typeof n === 'undefined' || (isNaN(n) && typeof n === 'number');\r\n}\r\n\r\nexport function coalesce(...vals) {\r\n    for (let i = 0; i < vals.length; i++) {\r\n        if (!isMissingValue(vals[i])) {\r\n            return vals[i];\r\n        }\r\n    }\r\n}\r\n\r\nexport function reduce(array, func, getter, ignoreMissing = false) {\r\n    var ret, i;\r\n    if (array.reduce && !getter && !ignoreMissing) {\r\n        ret = array.reduce(function (a, b) {\r\n            return func(a, b);\r\n        });\r\n    } else {\r\n        let retInitialised = false;\r\n        getter = getter || identity;\r\n        for (i = 0; i < array.length; i++) {\r\n            const value = getter(array[i], i);\r\n            if (!ignoreMissing || !isMissingValue(value)) {\r\n                ret = retInitialised ? func(ret, value) : value;\r\n                retInitialised = true;\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\nexport function sign(n) {\r\n    return n > 0 ? 1 : (n < 0 ? -1 : 0);\r\n}\r\n\r\nvar innerAssign = function (deepAssign, targetObject, sourceObjects) {\r\n    if (!Array.isArray(sourceObjects))\r\n        sourceObjects = [sourceObjects];\r\n    if (!deepAssign && Object.assign) {\r\n        return Object.assign.apply(Object, [targetObject].concat(sourceObjects));\r\n    } else {\r\n        if (targetObject === undefined || targetObject === null) {\r\n            throw new TypeError('Cannot convert first argument to object');\r\n        }\r\n\r\n        var to = Object(targetObject);\r\n        for (let i = 0; i < sourceObjects.length; i++) {\r\n            let currentSourceObject = sourceObjects[i];\r\n            if (currentSourceObject === undefined || currentSourceObject === null) {\r\n                continue;\r\n            }\r\n            currentSourceObject = Object(currentSourceObject);\r\n\r\n            const keysArray = Object.keys(currentSourceObject);\r\n            for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\r\n                const nextKey = keysArray[nextIndex];\r\n                const nextValue = currentSourceObject[nextKey];\r\n                const desc = Object.getOwnPropertyDescriptor(currentSourceObject, nextKey);\r\n                if (desc !== undefined && desc.enumerable) {\r\n                    if (deepAssign && !Array.isArray(nextValue) && typeof nextValue === 'object' && nextValue !== null)\r\n                        to[nextKey] = innerAssign(true, {}, [to[nextKey], nextValue]);\r\n                    else\r\n                        to[nextKey] = nextValue;\r\n                }\r\n            }\r\n        }\r\n        return to;\r\n    }\r\n}\r\n\r\nexport function none(array) {\r\n    return array.every(elem => !elem);\r\n}\r\n\r\nexport function assign(targetObject, sourceObjects) {\r\n    return innerAssign(false, targetObject, sourceObjects);\r\n}\r\n\r\nexport function deepAssign(targetObject, sourceObjects) {\r\n    return innerAssign(true, targetObject, sourceObjects);\r\n}\r\n\r\nexport function formatString(formatString, formatValues, escapeAsHtml) {\r\n    return formatString.replace(/{(\\w+)}/g, function (match, placeholder) {\r\n        const value = formatValues[placeholder];\r\n        return typeof value !== 'undefined' ? (escapeAsHtml ? stringToHtml(value) : value) : match;\r\n    });\r\n}\r\n\r\nexport function locateDecimalPoint(number) {\r\n    return Math.floor(Math.log(number) / Math.log(10));\r\n}\r\n\r\nexport function formatNumberThousands(number, decimalPlaces = 0) {\r\n    var parts = number.toFixed(decimalPlaces).split(\".\");\r\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\r\n    return parts.join(\".\");\r\n}\r\n\r\nexport function createAutoNumberFormatter(scale, prefix = '', suffix = '', precision = 2) {\r\n    let decimalPlaces = locateDecimalPoint(scale);\r\n    decimalPlaces = decimalPlaces < 0 ? -decimalPlaces + precision - 1 : 0;\r\n    return x => prefix + formatNumberThousands(x, decimalPlaces) + suffix;\r\n}\r\n\r\nexport function createFixedNumberFormatter(scale, prefix = '', suffix = '', decimalPlaces = 2) {\r\n    return x => prefix + formatNumberThousands(x, decimalPlaces) + suffix;\r\n}\r\n\r\nexport function createPercentageFormatter(scale, prefix = '', suffix = '%', precision = 2) {\r\n    let decimalPlaces = locateDecimalPoint(scale * 100);\r\n    decimalPlaces = decimalPlaces < precision ? -decimalPlaces + precision - 1 : 0;\r\n    return x => prefix + formatNumberThousands(x * 100, decimalPlaces) + suffix;\r\n}\r\n\r\nexport function stringToHtml(str) {\r\n    var div = document.createElement('div');\r\n    div.appendChild(document.createTextNode(str));\r\n    return div.innerHTML;\r\n}\r\n\r\nexport function throttle(fn, threshold) {\r\n    var last,\r\n        deferTimer;\r\n    return function () {\r\n        var context = this;\r\n\r\n        var now = Date.now(),\r\n            args = arguments;\r\n        if (last && now < last + threshold) {\r\n            clearTimeout(deferTimer);\r\n            deferTimer = setTimeout(function () {\r\n                last = now;\r\n                fn.apply(context, args);\r\n            }, threshold);\r\n        } else {\r\n            last = now;\r\n            fn.apply(context, args);\r\n        }\r\n    }\r\n}\r\n\r\n","export class Tayberry {\r\n    constructor() {\r\n        this.selectedItem = {};\r\n        this.containerElement = null;\r\n        this.labelsCanvas = null;\r\n        this.labelsCtx = null;\r\n        this.options = null;\r\n        this.scaleFactor = null;\r\n        this.titleFont = null;\r\n        this.plotArea = null;\r\n        this.categories = [];\r\n        this.titleFont = null;\r\n        this.labelFont = null;\r\n        this.legendFont = null;\r\n        this.renderers = [];\r\n        this.onClickReal = null;\r\n        this.onMouseLeaveReal = null;\r\n        this.onMouseMoveReal = null;\r\n        this.onWindowResizeReal = null;\r\n        this.pendingAnimations = [];\r\n        this.callbacks = {\r\n            onResize: [],\r\n            onInit: []\r\n        }\r\n    }\r\n\r\n    get seriesCount() {\r\n        return this.options.series.length;\r\n    }\r\n\r\n    get categoryCount() {\r\n        return this.options.series.length ? this.options.series[0].data.length : 0;\r\n    }\r\n}\r\n\r\n\r\n","'use strict';\r\nimport * as Utils from './helpers/utils.js';\r\n\r\nexport class Axis {\r\n    static create(tayberry, options, index, axisType, xYSwapped) {\r\n        const isHorizontal = (axisType === 'x' && !xYSwapped) || (axisType === 'y' && xYSwapped);\r\n        if (options.type === 'linear')\r\n            return new LinearAxis(tayberry, index, options, axisType, isHorizontal);\r\n        else\r\n            return new CategorialAxis(tayberry, index, options, axisType, isHorizontal);\r\n    }\r\n\r\n    constructor(tayberry, index, options, axisType, isHorizontal) {\r\n        this.tayberry = tayberry;\r\n        this.options = options;\r\n        this.axisType = axisType;\r\n        this.isHorizontal = isHorizontal;\r\n        this.index = index;\r\n        this.tickStep = null;\r\n        this.min = null;\r\n        this.max = null;\r\n        this.tickStart = null;\r\n        this.tickEnd = null;\r\n        this.calculatedSize = 0;\r\n        this.topAdjustment = 0;\r\n        this.rightAdjustment = 0;\r\n        this.titleFont = null;\r\n        this.labelFont = null;\r\n        this.numLabelLines = 1;\r\n\r\n        this.setPlacement();\r\n    }\r\n\r\n    updateFonts() {\r\n        this.labelFont = this.tayberry.createFontString(this.options.font);\r\n        this.titleFont = this.tayberry.createFontString(this.options.title.font);\r\n    }\r\n\r\n    setPlacement() {\r\n        const validAndSpecificPlacements = ['left', 'right', 'top', 'bottom', 'start', 'end'];\r\n        if (validAndSpecificPlacements.indexOf(this.options.placement) === -1) {\r\n            this.options.placement = this.isVertical ^ (this.index > 0) ? 'start' : 'end';\r\n        }\r\n    }\r\n\r\n    get isPlacedAtStart() {\r\n        return this.options.placement === \"left\" || this.options.placement === \"bottom\" || this.options.placement === \"start\";\r\n    }\r\n\r\n    get isYAxis() {\r\n        return this.axisType === 'y';\r\n    }\r\n\r\n    get isVertical() {\r\n        return !this.isHorizontal;\r\n    }\r\n\r\n    maxLabelSize() {\r\n        let tb = this.tayberry;\r\n        let ticks = this.getTicks();\r\n        return Utils.reduce(ticks, Math.max, x => tb.getTextWidth(this.options.labelFormatter(x.value), this.labelFont));\r\n    }\r\n\r\n    mapLogicalXOrYUnit(x) {\r\n        return this.isVertical ? this.tayberry.mapLogicalXUnit(x) : this.tayberry.mapLogicalYUnit(x);\r\n    }\r\n\r\n    mapLogicalYOrXUnit(x) {\r\n        return !this.isVertical ? this.tayberry.mapLogicalXUnit(x) : this.tayberry.mapLogicalYUnit(x);\r\n    }\r\n\r\n    adjustSize(plotArea, fixedOnly, reset) {\r\n        let size = 0,\r\n            tb = this.tayberry,\r\n            ret;\r\n\r\n        const titleFontHeight = tb.getFontHeight(this.options.title.font);\r\n        const fontHeight = tb.getFontHeight(this.options.font);\r\n\r\n        if (reset) {\r\n            this.calculatedSize = 0;\r\n            this.topAdjustment = 0;\r\n            this.rightAdjustment = 0;\r\n            this.numLabelLines = 1;\r\n        }\r\n\r\n        size += this.mapLogicalXOrYUnit(tb.options.elementSmallPadding);\r\n        if (this.options.title.text) {\r\n            size += this.mapLogicalXOrYUnit(tb.options.elementSmallPadding) + titleFontHeight;\r\n        }\r\n\r\n        if (!fixedOnly) {\r\n            let ticks = this.getTicks(false);\r\n            if (this.isVertical) {\r\n                if (ticks.length) {\r\n                    const lastTick = ticks[ticks.length - 1];\r\n                    const lastTickYStart = lastTick.y - fontHeight / 2;\r\n                    if (lastTickYStart < plotArea.top - this.topAdjustment) {\r\n                        const adjustment = plotArea.top - lastTickYStart - this.topAdjustment + 1;\r\n                        plotArea.top += adjustment;\r\n                        this.topAdjustment += adjustment;\r\n                    }\r\n                }\r\n                size += this.maxLabelSize()\r\n            } else {\r\n                {\r\n                    let lastXEnd;\r\n                    for (let i = 0; i < ticks.length; i++) {\r\n                        let tick = ticks[i];\r\n                        const textWidth = tb.getTextWidth(this.options.labelFormatter(tick.value), this.labelFont);\r\n                        const xStart = tick.x - textWidth / 2;\r\n                        const xEnd = tick.x + textWidth / 2;\r\n                        if (typeof lastXEnd !== 'undefined' && xStart <= lastXEnd + 1) {\r\n                            this.numLabelLines = 2;\r\n                            break;\r\n                        }\r\n                        lastXEnd = xEnd;\r\n                    }\r\n                }\r\n                if (ticks.length) {\r\n                    const lastTick = ticks[ticks.length - 1];\r\n                    const textWidth = tb.getTextWidth(this.options.labelFormatter(lastTick.value), this.labelFont);\r\n                    const lastTickXEnd = lastTick.x + textWidth / 2;\r\n                    if (lastTickXEnd >= plotArea.right + this.rightAdjustment) {\r\n                        const adjustment = lastTickXEnd - plotArea.right - this.rightAdjustment + 1;\r\n                        plotArea.right -= adjustment;\r\n                        this.rightAdjustment += adjustment;\r\n                    }\r\n                }\r\n                size += fontHeight * this.numLabelLines;\r\n            }\r\n        }\r\n\r\n        if (this.isPlacedAtStart) {\r\n            if (this.isVertical) {\r\n                plotArea.left += size - this.calculatedSize;\r\n            } else {\r\n                plotArea.top += size - this.calculatedSize;\r\n            }\r\n        } else {\r\n            size *= -1;\r\n            if (this.isVertical) {\r\n                plotArea.right += size - this.calculatedSize;\r\n            } else {\r\n                plotArea.bottom += size - this.calculatedSize;\r\n            }\r\n        }\r\n\r\n        ret = this.calculatedSize !== size;\r\n        this.calculatedSize = size;\r\n\r\n        return ret;\r\n    }\r\n\r\n    calculateExtent() {\r\n    }\r\n\r\n    getCategoryLabel() {\r\n    }\r\n\r\n    draw(offsetRect) {\r\n        this.drawTicksAndLabels(offsetRect);\r\n        this.drawTitle(offsetRect);\r\n    }\r\n\r\n    drawTicksAndLabels(offsetRect) {\r\n        let tb = this.tayberry;\r\n        const labelPadding = this.mapLogicalXOrYUnit(tb.options.elementSmallPadding);\r\n        const labelPaddingX = this.isVertical ? labelPadding * (this.isPlacedAtStart ? -1 : 1) : 0;\r\n        const labelPaddingY = !this.isVertical ? labelPadding * (this.isPlacedAtStart ? -1 : 1) : 0;\r\n        const fontHeight = tb.getFontHeight(this.options.font);\r\n        const xOffset = this.isVertical ? offsetRect[this.startProperty] : 0;\r\n        const yOffset = !this.isVertical ? offsetRect[this.startProperty] : 0;\r\n\r\n        tb.labelsCtx.save();\r\n        tb.labelsCtx.font = this.labelFont;\r\n        tb.labelsCtx.fillStyle = this.options.font.colour;\r\n        tb.labelsCtx.textAlign = this.isVertical ? (this.isPlacedAtStart ? 'right' : 'left') : 'center';\r\n        tb.labelsCtx.textBaseline = this.isVertical ? 'middle' : this.isPlacedAtStart ? 'bottom' : 'top';\r\n\r\n        let lastXEnds = [],\r\n            tickIndex = 0,\r\n            maxWidth = 0;\r\n\r\n        this.enumerateTicks((tick) => {\r\n            let xStart, xEnd;\r\n            const formattedValue = this.options.labelFormatter(tick.value);\r\n            const row = tickIndex % this.numLabelLines;\r\n            const rowOffset = this.isVertical ? 0 : fontHeight * row;\r\n            const textWidth = tb.getTextWidth(formattedValue, this.labelFont);\r\n            if (!this.isVertical) {\r\n                xStart = tick.x - textWidth / 2;\r\n                xEnd = tick.x + textWidth / 2;\r\n            }\r\n\r\n            if (this.isVertical || (typeof lastXEnds[row] === 'undefined' || xStart > lastXEnds[row] + 1) && xStart >= 0 && xEnd < tb.labelsCanvas.width) {\r\n                maxWidth = Math.max(maxWidth, textWidth);\r\n                tb.labelsCtx.fillText(formattedValue, tick.x + labelPaddingX + xOffset, tick.y + labelPaddingY + rowOffset + yOffset);\r\n                lastXEnds[row] = xEnd;\r\n            }\r\n            if (this.options.gridLines.colour)\r\n                tb.drawLine(tick.x1, tick.y1, tick.x2, tick.y2, this.options.gridLines.colour);\r\n            tickIndex++;\r\n        });\r\n\r\n        this.adjustOffsetRect(offsetRect, this.isVertical ? maxWidth + labelPadding : fontHeight + labelPadding);\r\n\r\n        tb.labelsCtx.restore();\r\n    }\r\n\r\n    adjustOffsetRect(offsetRect, displacement) {\r\n        offsetRect[this.startProperty] += this.isPlacedAtStart ? -displacement : displacement;\r\n    }\r\n\r\n    get startProperty() {\r\n        if (this.isVertical)\r\n            return this.isPlacedAtStart ? 'left' : 'right';\r\n        else\r\n            return this.isPlacedAtStart ? 'top' : 'bottom';\r\n    }\r\n\r\n    get endProperty() {\r\n        if (this.isVertical)\r\n            return !this.isPlacedAtStart ? 'left' : 'right';\r\n        else\r\n            return !this.isPlacedAtStart ? 'top' : 'bottom';\r\n    }\r\n\r\n    drawTitle(offsetRect) {\r\n        if (this.options.title.text) {\r\n            let tb = this.tayberry;\r\n            tb.labelsCtx.save();\r\n            tb.labelsCtx.font = this.titleFont;\r\n            tb.labelsCtx.fillStyle = this.options.title.font.colour;\r\n            tb.labelsCtx.textAlign = 'center';\r\n\r\n            const labelPaddingSize = this.mapLogicalXOrYUnit(tb.options.elementSmallPadding);\r\n            const labelPadding = labelPaddingSize * (this.isPlacedAtStart ? -1 : 1);\r\n            const xOffset = this.isVertical ? offsetRect[this.startProperty] : 0;\r\n            const yOffset = !this.isVertical ? offsetRect[this.startProperty] : 0;\r\n            const fontHeight = tb.getFontHeight(this.options.title.font);\r\n\r\n            if (this.isVertical) {\r\n                tb.labelsCtx.textBaseline = 'bottom';\r\n                const x = tb.plotArea[this.startProperty] + xOffset + labelPadding;\r\n                const y = tb.plotArea.yMidpoint + yOffset;\r\n                tb.labelsCtx.translate(x, y);\r\n                tb.labelsCtx.rotate((this.isPlacedAtStart ? -1 : 1)*Math.PI / 2);\r\n                tb.labelsCtx.fillText(this.options.title.text, 0, 0);\r\n            } else {\r\n                tb.labelsCtx.textBaseline = this.isPlacedAtStart ? 'bottom' : 'top';\r\n                const x = tb.plotArea.xMidpoint + xOffset;\r\n                const y = tb.plotArea[this.startProperty] + labelPadding + yOffset;\r\n                //tb.mapLogicalYOrXUnit(tb.options.font.size * 2 + tb.options.elementSmallPadding + tb.options.elementLargePadding)\r\n                tb.labelsCtx.fillText(this.options.title.text, x, y);\r\n            }\r\n            this.adjustOffsetRect(offsetRect, fontHeight + labelPaddingSize);\r\n            tb.labelsCtx.restore();\r\n        }\r\n    }\r\n\r\n    getTicks(visibleOnly = true) {\r\n        let ret = [];\r\n        this.enumerateTicks(function (tick) {\r\n            ret.push(tick)\r\n        }, visibleOnly);\r\n        return ret;\r\n    }\r\n\r\n    getOrigin() {\r\n    }\r\n\r\n    updateFormatter() {\r\n    }\r\n\r\n    get valueOrigin() {\r\n        return this.min <= 0 && 0 <= this.max ? 0 : (this.min > 0 ? this.min : this.max)\r\n    }\r\n}\r\n\r\nclass CategorialAxis extends Axis {\r\n    enumerateTicks(callback) {\r\n        let tb = this.tayberry;\r\n\r\n        const categoryCount = this.options.categories.length;\r\n        let plotArea = tb.plotArea.clone();\r\n        if (this.isVertical)\r\n            plotArea.swapXY();\r\n        const categoryWidth = (plotArea.width / tb.categoryCount);\r\n        let factor = 0.5;\r\n\r\n        if (!this.isVertical) {\r\n            switch (this.options.labelPosition) {\r\n                case 'left':\r\n                    factor = 0;\r\n                    break;\r\n                case 'right':\r\n                    factor = 1;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < categoryCount; i++) {\r\n            const value = this.options.categories[i];\r\n            let y1 = (this.isPlacedAtStart ? plotArea.top : plotArea.bottom);\r\n            let y2 = (!this.isPlacedAtStart ? plotArea.top : plotArea.bottom);\r\n            let x1 = plotArea.left + Math.floor(i * categoryWidth);\r\n            let x2 = x1;\r\n            let x = plotArea.left + Math.floor(i * categoryWidth + categoryWidth * factor);\r\n            let y = y1;\r\n            if (this.isVertical)\r\n                [x1, y1, x2, y2, x, y] = [y1, x1, y2, x2, y, x];\r\n\r\n            callback({\r\n                value: value,\r\n                x1: x1,\r\n                y1: y1,\r\n                x2: x2,\r\n                y2: y2,\r\n                x: x,\r\n                y: y\r\n            });\r\n\r\n        }\r\n    }\r\n\r\n    updateFormatter() {\r\n        if (!this.options.labelFormatter) {\r\n            this.options.labelFormatter = Utils.identity;\r\n        }\r\n    }\r\n\r\n    getCategoryLabel(index) {\r\n        return this.options.labelFormatter(this.options.categories[index]);\r\n    }\r\n\r\n    get plotDisplacement() {\r\n        return this.isVertical ? (-this.tayberry.plotArea.height) : (this.tayberry.plotArea.width);\r\n    }\r\n\r\n    getOrigin() {\r\n        return this.tayberry.plotArea[this.isVertical ? 'bottom' : 'left'];\r\n    }\r\n\r\n    getValueDisplacement(value) {\r\n        let ret = this.getOrigin() + this.plotDisplacement * (value + 0.5) / this.options.categories.length;\r\n        ret = this.isVertical ? Math.floor(ret) : Math.ceil(ret);\r\n        return ret;\r\n    }\r\n\r\n}\r\n\r\nclass LinearAxis extends Axis {\r\n    updateFormatter() {\r\n        if (!this.options.labelFormatter) {\r\n            if (this.options.labelFormat === 'percentage') {\r\n                this.options.labelFormatter = Utils.createPercentageFormatter(this.max - this.min, this.options.labelPrefix, this.options.labelSuffix);\r\n            }\r\n            else if (this.options.labelFormat === 'currency') {\r\n                this.options.labelFormatter = Utils.createFixedNumberFormatter(this.max - this.min, this.options.labelPrefix || this.options.currencySymbol, this.options.labelSuffix);\r\n            }\r\n            else {\r\n                this.options.labelFormatter = Utils.createAutoNumberFormatter(this.max - this.min, this.options.labelPrefix, this.options.labelSuffix);\r\n            }\r\n        }\r\n    }\r\n\r\n    enumerateTicks(callback) {\r\n        let tb = this.tayberry;\r\n\r\n        const start = this.startProperty,\r\n            end = this.endProperty;\r\n\r\n        for (let yValue = this.tickStart; yValue <= this.tickEnd && this.tickStep;) {\r\n            let y = this.getValueDisplacement(yValue);\r\n            if (this.isVertical) {\r\n                if (callback({\r\n                        value: yValue,\r\n                        x1: tb.plotArea[start],\r\n                        y1: y,\r\n                        x2: tb.plotArea[end],\r\n                        y2: y,\r\n                        x: tb.plotArea[start],\r\n                        y: y\r\n\r\n                    }))\r\n                    break;\r\n            } else {\r\n                if (callback({\r\n                        value: yValue,\r\n                        y1: tb.plotArea[start],\r\n                        x1: y,\r\n                        y2: tb.plotArea[end],\r\n                        x2: y,\r\n                        y: tb.plotArea[start],\r\n                        x: y\r\n                    }))\r\n                    break;\r\n            }\r\n            yValue = this.tickStart + Math.round((yValue + this.tickStep - this.tickStart) / this.tickStep) * this.tickStep;\r\n        }\r\n    }\r\n\r\n    static snapScaledValue(scaledStep) {\r\n        if (scaledStep < 1)\r\n            scaledStep = 1;\r\n        else if (scaledStep < 2)\r\n            scaledStep = 2;\r\n        else if (scaledStep < 2.5)\r\n            scaledStep = 2.5;\r\n        else if (scaledStep < 5)\r\n            scaledStep = 5;\r\n        else\r\n            scaledStep = 10;\r\n        return scaledStep;\r\n    }\r\n\r\n    calculateExtent() {\r\n        let targetTicks, approxStep, scale;\r\n\r\n        let targetStart = this.options.min;\r\n        let targetEnd = this.options.max;\r\n        const overriddenStart = !Utils.isMissingValue(targetStart);\r\n        const overriddenEnd = !Utils.isMissingValue(targetEnd);\r\n\r\n        if (!overriddenStart || !overriddenEnd) {\r\n            const [dataMin, dataMax] = this.isYAxis ? this.tayberry.getDataMinMax(this) : this.tayberry.getDataXMinMax(this);\r\n            const dataRange = dataMax - dataMin;\r\n            if (!overriddenStart) {\r\n                targetStart = dataMin;\r\n                if (this.isYAxis) {\r\n                    targetStart = targetStart - dataRange * 0.1;\r\n                    if (dataMin >= 0 && targetStart < 0)\r\n                        targetStart = 0;\r\n                }\r\n            }\r\n            if (!overriddenEnd) {\r\n                targetEnd = dataMax;\r\n                if (this.isYAxis) {\r\n                    targetEnd = dataMax + dataRange * 0.1;\r\n                    if (dataMax <= 0 && targetStart > 0)\r\n                        targetEnd = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.options.tickStepValue) {\r\n            this.tickStep = this.options.tickStepValue;\r\n            this.min = targetStart;\r\n            this.max = targetEnd;\r\n        } else {\r\n            const targetRange = targetEnd - targetStart;\r\n            targetTicks = this.plotLength / this.mapLogicalYOrXUnit(this.options.tickStep);\r\n            approxStep = targetRange / targetTicks;\r\n            scale = Math.pow(10, Math.floor(Math.log(approxStep) / Math.log(10)));\r\n            let scaledStep = LinearAxis.snapScaledValue(Math.ceil(approxStep / scale));\r\n            this.tickStep = scaledStep * scale;\r\n            this.min = targetStart;\r\n            this.max = targetEnd;\r\n        }\r\n        this.tickStart = this.options.tickStepValue && overriddenStart ? this.min : Math.floor(this.min / this.tickStep) * this.tickStep;\r\n        this.tickEnd = this.options.tickStepValue && overriddenEnd ? this.max : Math.ceil(this.max / this.tickStep) * this.tickStep;\r\n        if (!overriddenStart && this.isYAxis)\r\n            this.min = this.tickStart;\r\n        if (!overriddenEnd && this.isYAxis)\r\n            this.max = this.tickEnd;\r\n    }\r\n\r\n    get plotDisplacement() {\r\n        return this.isVertical ? (this.tayberry.plotArea.height - 1) : -(this.tayberry.plotArea.width - 1);\r\n    }\r\n\r\n    get plotLength() {\r\n        return Math.abs(this.plotDisplacement);\r\n    }\r\n\r\n    getOrigin() {\r\n        let ret = this.tayberry.plotArea[this.isVertical ? 'bottom' : 'left'] - (0 - this.min) * this.plotDisplacement / (this.max - this.min);\r\n        if (this.isVertical) ret--;\r\n        ret = this.isVertical ? Math.floor(ret) : Math.ceil(ret);\r\n        return ret;\r\n    }\r\n\r\n    getValueDisplacement(value) {\r\n        let ret = this.getOrigin() - value * this.plotDisplacement / (this.max - this.min);\r\n        ret = this.isVertical ? Math.floor(ret) : Math.ceil(ret);\r\n        return ret;\r\n    }\r\n\r\n    getCategoryLabel(index, totalCategories, isRange) {\r\n        if (isRange) {\r\n            const start = index / totalCategories;\r\n            const end = (index + 1) / totalCategories;\r\n            const axisRange = this.max - this.min;\r\n            return Utils.formatString('{0} \\u2264 x < {1}', [this.options.labelFormatter(this.min + start * axisRange), this.options.labelFormatter(this.min + end * axisRange)]);\r\n        } else {\r\n            return this.options.labelFormatter(index);\r\n        }\r\n    }\r\n}\r\n","'use strict';\r\n\r\nimport * as Utils from './utils';\r\n\r\nexport class Colour {\r\n    /**\r\n     * Constructs a Colour object.\r\n     *\r\n     * @param colourCode    an HTML colour code in hex or integer (rgb) form\r\n     */\r\n    constructor() {\r\n        if (arguments.length === 1) {\r\n            let arg1 = arguments[0];\r\n            if (typeof arg1 === 'string')\r\n                this.parseString(arg1);\r\n            else {\r\n                this.r = arg1.r;\r\n                this.g = arg1.g;\r\n                this.b = arg1.b;\r\n                this.a = arg1.a;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses an HTML colour code\r\n     * @param str\r\n     * @returns {Colour}\r\n     */\r\n    parseString(str) {\r\n        let regExHex = /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})|^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i;\r\n        let regExInt = /^rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})(\\s*,\\s*([0-9]*\\.?[0-9]+)\\s*)?\\)$/i;\r\n        const groupsHex = regExHex.exec(str);\r\n        const groupsInt = regExInt.exec(str);\r\n        if (groupsHex) {\r\n            let parseHex = function (value) {\r\n                let ret = parseInt(value, 16);\r\n                ret = ret * 0x10 + ret;\r\n                return ret;\r\n            };\r\n            this.r = groupsHex[1] ? parseInt(groupsHex[1], 16) : parseHex(groupsHex[4]);\r\n            this.g = groupsHex[2] ? parseInt(groupsHex[2], 16) : parseHex(groupsHex[5]);\r\n            this.b = groupsHex[3] ? parseInt(groupsHex[3], 16) : parseHex(groupsHex[6]);\r\n            this.a = 1.0;\r\n        }\r\n        else if (groupsInt) {\r\n            this.r = parseInt(groupsInt[1]);\r\n            this.g = parseInt(groupsInt[2]);\r\n            this.b = parseInt(groupsInt[3]);\r\n            this.a = groupsInt[5] ? parseFloat(groupsInt[5]) : 1.0;\r\n        } else {\r\n            throw new RangeError(str + \" is not a valid HTML colour\");\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clips a colour component to be in the range [0, 255], and round it them to\r\n     * the nearest integer\r\n     * @param component\r\n     * @returns {Colour}\r\n     */\r\n    clipComponent(component) {\r\n        this[component] = Math.round(this[component]);\r\n        this[component] = Math.min(this[component], 255);\r\n        this[component] = Math.max(this[component], 0);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clips r,g,b colour components to be in the range [0, 255], and rounds them to\r\n     * the nearest integer\r\n     * @returns {Colour}\r\n     */\r\n    clip() {\r\n        this.clipComponent('r');\r\n        this.clipComponent('g');\r\n        this.clipComponent('b');\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a number to each colour component\r\n     * @param number\r\n     * @returns {Colour}\r\n     */\r\n    increaseBy(number) {\r\n        this.r += number;\r\n        this.g += number;\r\n        this.b += number;\r\n        this.clip();\r\n        return this;\r\n    }\r\n\r\n    multiplyAlpha(multiplier) {\r\n        this.a *= multiplier;\r\n        return this;\r\n    }\r\n\r\n    get sum() {\r\n        return this.r + this.g + this.b;\r\n    }\r\n\r\n    /**\r\n     * Formats this colour as a string\r\n     * @returns {String}\r\n     */\r\n    toString() {\r\n        var ret;\r\n        if (!Utils.isMissingValue(this.a) && this.a !== 1.0) {\r\n            ret = Utils.formatString('rgba({r},{g},{b},{a})', this);\r\n        } else {\r\n            ret = Utils.formatString('rgb({r},{g},{b})', this);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static createFromBlend(colour1, colour2, blendPosition) {\r\n        const blender = (c1, c2) => (c1 + blendPosition * (c2 - c1));\r\n        return new Colour({\r\n            r: blender(colour1.r, colour2.r),\r\n            g: blender(colour1.g, colour2.g),\r\n            b: blender(colour1.b, colour2.b),\r\n            a: blender(Utils.coalesce(colour1.a, 1), Utils.coalesce(colour2.a, 1))\r\n        }).clip();\r\n    }\r\n\r\n}\r\n","'use strict';\r\n\r\nexport const visibilityState = {\r\n    visible: 1 << 0,\r\n    hidden: 1 << 1,\r\n    transitioning: 1 << 2\r\n};\r\n","'use strict';\r\nimport * as Utils from './helpers/utils.js';\r\nimport * as constants from './constants';\r\nimport {Colour} from './helpers/colour';\r\nimport {Tayberry} from './base';\r\n\r\nexport class Renderer {\r\n    constructor(ctx, tayberry, series) {\r\n        this.ctx = ctx;\r\n        this.tb = tayberry;\r\n        this.series = null;\r\n        this.setSeries(series);\r\n    }\r\n\r\n    setSeries(series) {\r\n        var seriesIndex;\r\n        this.series = series;\r\n\r\n        for (seriesIndex = 0; seriesIndex < this.series.length; seriesIndex++) {\r\n            const series = this.series[seriesIndex];\r\n            series.renderer = this;\r\n        }\r\n    }\r\n\r\n    getVisibleSeriesCount(excludeSeries) {\r\n        let ret = 0;\r\n        for (let index=0; index<this.series.length; index++) {\r\n            if (index !== excludeSeries) {\r\n                const series = this.series[index];\r\n                if (series.visible & (constants.visibilityState.visible))\r\n                    ret++;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    onToggleSeriesAnimationFrame() {\r\n    }\r\n\r\n    onAnimationFrame() {\r\n        this.onToggleSeriesAnimationFrame();\r\n    }\r\n\r\n    drawLegendIndicator(ctx, series, rect, highlighted) {\r\n        ctx.fillStyle = highlighted ? series.highlightColour : series.colour;\r\n        if (!(series.visible & constants.visibilityState.visible))\r\n            ctx.fillStyle = (new Colour(ctx.fillStyle)).multiplyAlpha(this.tb.options.legend.hiddenAlphaMultiplier).toString();\r\n        ctx.fillRect(rect.left, rect.top, rect.width, rect.height);\r\n    }\r\n\r\n    drawLabel(sign, text, rect) {\r\n        if (this.tb.options.swapAxes)\r\n            rect = rect.clone().swapXY();\r\n        let x = (rect.left + rect.right) / 2;\r\n        let y;\r\n        if (this.tb.options.labels.verticalAlignment === 'top')\r\n            y = rect.top;\r\n        else if (this.tb.options.labels.verticalAlignment === 'bottom')\r\n            y = rect.bottom;\r\n        else\r\n            y = (rect.top + rect.bottom) / 2;\r\n        let baseline = 'middle';\r\n        let align = 'center';\r\n        if (this.tb.options.swapAxes) {\r\n            [x, y] = [y, x];\r\n            if (this.tb.options.labels.verticalPosition === 'outside')\r\n                align = 'left';\r\n            else if (this.tb.options.labels.verticalPosition === 'inside')\r\n                align = 'right';\r\n        } else {\r\n            baseline = Tayberry.mapVerticalPosition(sign, this.tb.options.labels.verticalPosition);\r\n        }\r\n        if (this.tb.plotArea.containsPoint(x, y)) {\r\n            this.ctx.save();\r\n            this.ctx.textAlign = align;\r\n            this.ctx.textBaseline = baseline;\r\n            this.ctx.fillText(text, x, y);\r\n            this.ctx.restore();\r\n        }\r\n    }\r\n\r\n    drawPlot() {\r\n    }\r\n\r\n    drawLabels() {\r\n    }\r\n\r\n    hitTest() {\r\n    }\r\n\r\n}\r\n\r\nexport class Enumerator {\r\n    constructor(renderer, startCategoryIndex = 0) {\r\n        this.renderer = renderer;\r\n        this.tb = renderer.tb;\r\n\r\n        this.categoryCount = this.renderer.series[0].data.length;\r\n        this.categoryIndex = 0;\r\n        this.seriesIndex = 0;\r\n        this.seriesCount = this.renderer.series.length;\r\n        if (this.categoryCount) {\r\n            this.isHorizontal = this.tb.options.swapAxes;\r\n            this.plotArea = this.tb.plotArea.clone();\r\n            if (this.isHorizontal)\r\n                this.plotArea.swapXY();\r\n            this.startCategoryIndex = Math.max(startCategoryIndex, 0);\r\n            this.startCategoryIndex = Math.min(this.startCategoryIndex, this.categoryCount - 1);\r\n            this.categoryIndex = this.startCategoryIndex;\r\n        }\r\n    }\r\n\r\n    nextValue() {\r\n    }\r\n}\r\n\r\nexport class ByCategoryEnumerator extends Enumerator {\r\n    nextValue() {\r\n\r\n        let value;\r\n        do {\r\n            if (this.seriesIndex + 1 === this.seriesCount) {\r\n                this.seriesIndex = 0;\r\n                this.categoryIndex++;\r\n                if (this.categoryIndex >= this.categoryCount)\r\n                    break;\r\n            } else {\r\n                this.seriesIndex++;\r\n            }\r\n            value = Tayberry.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]);\r\n        } while (Utils.isMissingValue(value));\r\n\r\n    }\r\n}\r\n\r\nexport class BySeriesEnumerator extends Enumerator {\r\n    nextValue() {\r\n\r\n        let value;\r\n        do {\r\n            if (this.categoryIndex + 1 === this.categoryCount) {\r\n                this.categoryIndex = this.startCategoryIndex;\r\n                this.seriesIndex++;\r\n                if (this.seriesIndex >= this.seriesCount)\r\n                    break;\r\n            } else {\r\n                this.categoryIndex++;\r\n            }\r\n            value = Tayberry.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]);\r\n        } while (Utils.isMissingValue(value));\r\n\r\n    }\r\n}\r\n","'use strict';\r\n\r\nexport class Rect {\r\n    constructor() {\r\n        if (arguments.length === 1) {\r\n            if (typeof arguments[0] === 'object') {\r\n                const rect = arguments[0];\r\n                this.left = rect.left;\r\n                this.top = rect.top;\r\n                this.right = rect.right;\r\n                this.bottom = rect.bottom;\r\n            } else {\r\n                const val = arguments[0];\r\n                this.left = val;\r\n                this.top = val;\r\n                this.right = val;\r\n                this.bottom = val;\r\n            }\r\n        } else if (arguments.length === 4) {\r\n            this.left = arguments[0];\r\n            this.top = arguments[1];\r\n            this.right = arguments[2];\r\n            this.bottom = arguments[3];\r\n        }\r\n    }\r\n\r\n    get width() {\r\n        return this.right - this.left;\r\n    }\r\n\r\n    get height() {\r\n        return this.bottom - this.top;\r\n    }\r\n\r\n    get maxY() {\r\n        return Math.max(this.bottom, this.top);\r\n    }\r\n\r\n    get minY() {\r\n        return Math.min(this.bottom, this.top);\r\n    }\r\n\r\n    get minX() {\r\n        return Math.min(this.left, this.right);\r\n    }\r\n\r\n    get maxX() {\r\n        return Math.max(this.left, this.right);\r\n    }\r\n\r\n    get xMidpoint() {\r\n        return (this.left + this.right) / 2;\r\n    }\r\n\r\n    get yMidpoint() {\r\n        return (this.top + this.bottom) / 2;\r\n    }\r\n\r\n    get area() {\r\n        return Math.abs(this.width) * Math.abs(this.height);\r\n    }\r\n\r\n    containsPoint(x, y) {\r\n        return this.containsX(x) && this.containsY(y);\r\n    }\r\n\r\n    containsY(y) {\r\n        return (y >= this.top && y < this.bottom) || (y >= this.bottom && y < this.top);\r\n    }\r\n\r\n    containsX(x) {\r\n        return (x >= this.left && x < this.right) || (x >= this.right && x < this.left);\r\n    }\r\n\r\n    inflate(val) {\r\n        this.left -= val;\r\n        this.top -= val;\r\n        this.right += val;\r\n        this.bottom += val;\r\n        return this;\r\n    }\r\n\r\n    clip(clipRect) {\r\n        //FIXME: In theory, we should be more careful about how we handle rects where right < left or bottom < top\r\n        if (this.left < clipRect.minX) this.left = clipRect.minX;\r\n        else if (this.left > clipRect.maxX) this.left = clipRect.maxX;\r\n\r\n        if (this.right < clipRect.minX) this.right = clipRect.minX;\r\n        else if (this.right > clipRect.maxX) this.right = clipRect.maxX;\r\n\r\n        if (this.top < clipRect.minY)\r\n            this.top = clipRect.minY;\r\n        else if (this.top > clipRect.maxY)\r\n            this.top = clipRect.maxY;\r\n\r\n        if (this.bottom > clipRect.maxY)\r\n            this.bottom = clipRect.maxY;\r\n        else if (this.bottom < clipRect.minY)\r\n            this.bottom = clipRect.minY;\r\n\r\n        return this;\r\n    }\r\n\r\n    clone() {\r\n        return new Rect(this);\r\n    }\r\n\r\n    swapXY() {\r\n        [this.left, this.top] = [this.top, this.left];\r\n        [this.bottom, this.right] = [this.right, this.bottom];\r\n        return this;\r\n    }\r\n}\r\n","'use strict';\r\nimport {Rect} from './helpers/rect';\r\nimport * as Utils from './helpers/utils.js';\r\nimport {Colour} from './helpers/colour';\r\nimport * as renderer from './renderer.base';\r\nimport * as constants from './constants';\r\nimport {Tayberry} from './base';\r\n\r\nexport class BarRenderer extends renderer.Renderer {\r\n    constructor(ctx, tayberry, series) {\r\n        super(ctx, tayberry, series);\r\n\r\n        this.barPositions = null;\r\n\r\n        this.tb.registerCallback('onResize', this.updateBarWidths.bind(this));\r\n        this.tb.registerCallback('onInit', this.updateBarWidths.bind(this));\r\n    }\r\n\r\n    updateBarWidths() {\r\n        const categoryCount = this.series[0].data.length;\r\n        const isStacked = this.tb.options.barPlot.mode === 'stacked';\r\n        const isOverlaid = this.tb.options.barPlot.mode === 'overlaid';\r\n        const isNormal = !isStacked && !isOverlaid;\r\n        const seriesCount = this.series.length;\r\n        const plotArea = this.tb.options.swapAxes ? this.tb.plotArea.clone().swapXY() : this.tb.plotArea;\r\n        const categoryWidth = (plotArea.width / categoryCount);\r\n        let animatingSeriesCount = 0;\r\n        let totalMultiplier = 0;\r\n\r\n        for (let seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\r\n            const series = this.series[seriesIndex];\r\n            const rState = series.rState;\r\n            if (series.animationState) {\r\n                if (!series.animationState.subtype) {\r\n                    const visibleSeriesCount = this.getVisibleSeriesCount(seriesIndex);\r\n                    if (isNormal && visibleSeriesCount > 0) {\r\n                        series.animationState.subtype = 'width';\r\n                    } else if (isStacked  && visibleSeriesCount > 0) {\r\n                        series.animationState.subtype = 'height';\r\n                    } else {\r\n                        series.animationState.subtype = 'fade';\r\n                    }\r\n\r\n                    rState.colour = series.colour;\r\n                }\r\n\r\n                const isShow = series.animationState.type === 'show';\r\n                if (series.animationState.subtype === 'width') {\r\n                    rState.multiplier = isShow ? series.animationState.stage : 1 - series.animationState.stage;\r\n                    rState.yMultiplier = 1;\r\n                } else if (series.animationState.subtype === 'height') {\r\n                    rState.yMultiplier = isShow ? series.animationState.stage : 1 - series.animationState.stage;\r\n                    rState.multiplier = 1;\r\n                } else {\r\n                    let transColour = new Colour(series.colour);\r\n                    transColour.a = 0;\r\n                    if (isShow)\r\n                        rState.colour = Colour.createFromBlend(transColour, new Colour(series.colour), series.animationState.stage).toString();\r\n                    else\r\n                        rState.colour = Colour.createFromBlend(new Colour(series.colour), transColour, series.animationState.stage).toString();\r\n\r\n                    rState.yMultiplier = 1;\r\n                    rState.multiplier = 1;\r\n                }\r\n                ++animatingSeriesCount;\r\n            } else if (series.visible & constants.visibilityState.visible) {\r\n                rState.multiplier = 1;\r\n                rState.yMultiplier = 1;\r\n            } else {\r\n                rState.multiplier = 0;\r\n                rState.yMultiplier = 0;\r\n            }\r\n            totalMultiplier += rState.multiplier;\r\n        }\r\n\r\n        const totalBarsPerCategory = (isStacked || isOverlaid) ? 1 : totalMultiplier;\r\n        const yOrigin = this.series[0].yAxis.getOrigin();\r\n\r\n        this.barPositions = [];\r\n\r\n        for (let categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {\r\n            let yBottomPositive = yOrigin;\r\n            let yBottomNegative = yOrigin;\r\n            let yRunningTotalPositive = 0;\r\n            let yRunningTotalNegative = 0;\r\n\r\n            const categoryXStart = plotArea.left + Math.floor(categoryIndex * categoryWidth);\r\n            const categoryXEnd = plotArea.left + Math.floor((categoryIndex + 1) * categoryWidth);\r\n            // FIXME: Need to map this.tb.options.barPlot.categorySpacing\r\n            const barXStart = categoryXStart + Math.ceil(categoryWidth * this.tb.options.barPlot.categorySpacing / 2);\r\n            const barXEnd = categoryXEnd - Math.floor(categoryWidth * this.tb.options.barPlot.categorySpacing / 2);\r\n\r\n            let categoryPositions = [];\r\n            let barIndex = 0;\r\n\r\n            let runningBarWidth = 0;\r\n\r\n            for (let seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\r\n                const series = this.series[seriesIndex];\r\n                const rState = series.rState;\r\n                const value = Tayberry.getDataValue(series.data[categoryIndex])*rState.yMultiplier;\r\n\r\n                let barWidth = Math.floor(rState.multiplier * Math.floor((barXEnd - barXStart) / totalBarsPerCategory));\r\n\r\n                const xStart = Math.floor(barXStart + runningBarWidth) + Math.ceil(series.xAxis.mapLogicalXOrYUnit(this.tb.options.barPlot.barPadding) / 2);\r\n                const xEnd = Math.ceil(barXStart + runningBarWidth + barWidth) - Math.floor(series.xAxis.mapLogicalXOrYUnit(this.tb.options.barPlot.barPadding) / 2);\r\n                const yTop = series.yAxis.getValueDisplacement(value + (value > 0 ? yRunningTotalPositive : yRunningTotalNegative));\r\n                const yBottom = isStacked ? (value > 0 ? yBottomPositive : yBottomNegative) : yOrigin;\r\n\r\n                categoryPositions.push([xStart, yTop, xEnd, yBottom]);\r\n\r\n                if (isStacked) {\r\n                    if (value > 0) {\r\n                        yRunningTotalPositive += value;\r\n                        yBottomPositive = yTop;\r\n                    } else {\r\n                        yRunningTotalNegative += value;\r\n                        yBottomNegative = yTop;\r\n                    }\r\n                } else if (isNormal) {\r\n                    barIndex++;\r\n                    runningBarWidth += barWidth;\r\n                }\r\n\r\n            }\r\n\r\n            this.barPositions.push(categoryPositions);\r\n        }\r\n    }\r\n\r\n    onToggleSeriesAnimationFrame() {\r\n        this.updateBarWidths();\r\n    }\r\n\r\n    drawPlot() {\r\n        this.ctx.save();\r\n        let barEnumerator = new BarEnumerator(this);\r\n        let bar;\r\n        while ((bar = barEnumerator.next())) {\r\n            if (bar.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)) {\r\n                this.ctx.fillStyle = bar.selected ? bar.series.rState.highlightColour : bar.series.rState.colour;\r\n                this.ctx.fillRect(bar.rect.left, bar.rect.top, bar.rect.width, bar.rect.height);\r\n            }\r\n        }\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawLabels() {\r\n        if (this.tb.options.labels.enabled) {\r\n            this.ctx.save();\r\n            let barEnumerator = new BarEnumerator(this);\r\n            let bar;\r\n            while ((bar = barEnumerator.next())) {\r\n                if ((bar.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)) === constants.visibilityState.visible) {\r\n                    this.ctx.font = this.tb.labelFont;\r\n                    this.ctx.fillStyle = this.tb.options.labels.font.colour;\r\n                    this.drawLabel(bar.value, bar.series.yAxis.options.labelFormatter(bar.value), bar.rect);\r\n                }\r\n            }\r\n            this.ctx.restore();\r\n        }\r\n    }\r\n\r\n    hitTest(x, y) {\r\n        // TODO: Optimise\r\n        let ret = {\r\n            found: false,\r\n            plotType: 'bar',\r\n            type: 'plotItem',\r\n            isXRange: true\r\n        };\r\n\r\n        const categoryCount = this.series[0].data.length;\r\n        const isHorizontal = this.tb.options.swapAxes;\r\n        let plotArea = this.tb.plotArea.clone();\r\n        if (isHorizontal)\r\n            plotArea.swapXY();\r\n        const categoryIndex = Math.floor(categoryCount * ((isHorizontal ? y : x) - plotArea.left) / plotArea.width);\r\n\r\n        let matches = [];\r\n\r\n        let barEnumerator = new BarEnumerator(this, categoryIndex);\r\n        let bar;\r\n        while ((bar = barEnumerator.next())) {\r\n            if (bar.categoryIndex > categoryIndex)\r\n                break;\r\n            if (!(bar.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)))\r\n                continue;\r\n\r\n            let sortDistance, priority, realDistance;\r\n            if (bar.rect.containsPoint(x, y)) {\r\n                sortDistance = 0;\r\n                priority = 0;\r\n            }\r\n            else if (bar.rect.containsX(x)) {\r\n                sortDistance = y < bar.rect.top ? bar.rect.top - y : y - bar.rect.bottom;\r\n                priority = isHorizontal ? 2 : 1;\r\n            }\r\n            else if (bar.rect.containsY(y)) {\r\n                sortDistance = x < bar.rect.left ? bar.rect.left - x : x - bar.rect.right;\r\n                priority = isHorizontal ? 1 : 2;\r\n            }\r\n            else {\r\n                const xDist = Math.min(Math.abs(x - bar.rect.left), Math.abs(x - bar.rect.right));\r\n                const yDist = Math.min(Math.abs(y - bar.rect.top), Math.abs(y - bar.rect.bottom));\r\n                realDistance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\r\n                sortDistance = isHorizontal ? yDist : xDist;\r\n                priority = 3;\r\n            }\r\n\r\n            if (typeof realDistance === 'undefined')\r\n                realDistance = sortDistance;\r\n\r\n            if (!Utils.isMissingValue(realDistance)) {\r\n                matches.push({\r\n                    sortDistance: sortDistance,\r\n                    distance: realDistance,\r\n                    priority: priority,\r\n                    data: {\r\n                        categoryIndex: bar.categoryIndex,\r\n                        seriesIndex: bar.seriesIndex,\r\n                        rect: bar.rect,\r\n                        series: bar.series,\r\n                        value: Tayberry.getDataValue(this.series[bar.seriesIndex].data[bar.categoryIndex])\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (matches.length) {\r\n            matches.sort((a, b) => {\r\n                let ret = a.priority - b.priority;\r\n                if (!ret) ret = a.sortDistance - b.sortDistance;\r\n                if (!ret) ret = a.data.rect.height - b.data.rect.height;\r\n                return ret;\r\n            });\r\n            ret.found = true;\r\n            ret.normalisedDistance = matches[0].distance + Math.sqrt(matches[0].data.rect.area);\r\n            if (ret.normalisedDistance < 0) {\r\n                ret.normalisedDistance = 0;\r\n            }\r\n            ret = Utils.assign(ret, matches[0].data);\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\nexport class BarEnumerator extends renderer.ByCategoryEnumerator {\r\n    next() {\r\n        let ret;\r\n\r\n        if (this.categoryIndex < this.categoryCount) {\r\n            const [xStart, yTop, xEnd, yBottom] = this.renderer.barPositions[this.categoryIndex][this.seriesIndex];\r\n\r\n            let rect = new Rect(xStart, yTop, xEnd, yBottom);\r\n\r\n            if (rect.right < rect.left)\r\n                rect.right = rect.left;\r\n            if (this.isHorizontal)\r\n                rect.swapXY();\r\n            rect.clip(this.tb.plotArea);\r\n\r\n            ret = {\r\n                seriesIndex: this.seriesIndex,\r\n                categoryIndex: this.categoryIndex,\r\n                series: this.renderer.series[this.seriesIndex],\r\n                value: Tayberry.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]),\r\n                rect: rect,\r\n                selected: this.tb.selectedItem.type === 'plotItem' && this.tb.selectedItem.categoryIndex === this.categoryIndex && (this.tb.options.tooltips.shared || this.tb.selectedItem.series === this.renderer.series[this.seriesIndex])\r\n            };\r\n\r\n            this.nextValue();\r\n\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\n","'use strict';\r\nimport * as Utils from './helpers/utils.js';\r\nimport {Rect} from './helpers/rect';\r\nimport * as renderer from './renderer.base';\r\nimport * as constants from './constants';\r\nimport {Tayberry} from './base';\r\n\r\nvar autoMarkerIndex = 0;\r\nconst markers = ['square', 'diamond', 'circle', 'triangle', 'triangle-inversed'];\r\n\r\nexport class LineRenderer extends renderer.Renderer {\r\n    constructor(ctx, tayberry, series) {\r\n        super(ctx, tayberry, series);\r\n\r\n        this.pointPositions = null;\r\n\r\n        this.tb.registerCallback('onResize', this.updatPointPositions.bind(this));\r\n        this.tb.registerCallback('onInit', this.updatPointPositions.bind(this));\r\n    }\r\n\r\n    updatPointPositions() {\r\n        const seriesCount = this.series.length;\r\n\r\n        this.pointPositions = [];\r\n\r\n        for (let seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\r\n            const series = this.series[seriesIndex];\r\n            const rState = series.rState;\r\n            if (series.animationState) {\r\n                if (!series.animationState.subtype) {\r\n                    series.animationState.subtype = 'height';\r\n                }\r\n\r\n                const isShow = series.animationState.type === 'show';\r\n                if (series.animationState.subtype === 'height') {\r\n                    rState.yMultiplier = isShow ? series.animationState.stage : 1 - series.animationState.stage;\r\n                    rState.xMultiplier = 1;\r\n                }\r\n\r\n            } else if (series.visible & constants.visibilityState.visible) {\r\n                rState.xMultiplier = 1;\r\n                rState.yMultiplier = 1;\r\n            } else {\r\n                rState.xMultiplier = 1;\r\n                rState.yMultiplier = 0;\r\n            }\r\n        }\r\n\r\n        for (let seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\r\n            const series = this.series[seriesIndex];\r\n            const rState = series.rState;\r\n            const valueCount = series.data.length;\r\n            const yOrigin = series.yAxis.valueOrigin;\r\n            let seriesPositions = [];\r\n\r\n            for (let valueIndex = 0; valueIndex < valueCount; valueIndex++) {\r\n                const value = Tayberry.getDataValue(series.data[valueIndex]);\r\n                const xValue = Tayberry.getDataXValue(series.data, valueIndex);\r\n\r\n                const rValue = yOrigin + (rState.yMultiplier)*(value-yOrigin);\r\n                let x = series.xAxis.getValueDisplacement(xValue)*rState.xMultiplier;\r\n                let y = series.yAxis.getValueDisplacement(rValue);\r\n\r\n                seriesPositions.push([x, y]);\r\n            }\r\n\r\n            this.pointPositions.push(seriesPositions);\r\n        }\r\n    }\r\n\r\n    setSeries(series) {\r\n        let totalPoints = 0;\r\n        for (var i = 0; i < series.length; i++) {\r\n            if (!series[i].markerType) {\r\n                series[i].markerType = markers[autoMarkerIndex % markers.length];\r\n                autoMarkerIndex++;\r\n            }\r\n            totalPoints += series[i].data.length;\r\n        }\r\n        const showMarkers = this.tb.options.linePlot.showMarkers;\r\n        this.showMarkers = showMarkers === 'auto' ? totalPoints < this.tb.options.linePlot.noMarkersThreshold : showMarkers;\r\n        super.setSeries(series);\r\n    }\r\n\r\n    drawMarker(type, x, y, size, ctx = this.ctx) {\r\n        if (type === 'square') {\r\n            ctx.fillRect(x - size / 2, y - size / 2, size, size);\r\n        } else if (type === 'diamond') {\r\n            ctx.save();\r\n            ctx.translate(x, y);\r\n            ctx.rotate(-Math.PI / 4);\r\n            ctx.fillRect(0 - size / 2, 0 - size / 2, size, size);\r\n            ctx.restore();\r\n        } else if (type === 'circle') {\r\n            size = Math.round(size * 1.2);\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, size / 2, 0, 2 * Math.PI);\r\n            ctx.fill();\r\n        } else if (type === 'triangle' || (type === 'triangle-inversed' && (size = -size))) {\r\n            size = Math.round(size * 1.2);\r\n            ctx.beginPath();\r\n            ctx.moveTo(x - size / 2, y + size / 2);\r\n            ctx.lineTo(x, y - size / 2);\r\n            ctx.lineTo(x + size / 2, y + size / 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        }\r\n    }\r\n\r\n    onToggleSeriesAnimationFrame() {\r\n        this.updatPointPositions();\r\n    }\r\n\r\n    drawPlot() {\r\n        this.ctx.save();\r\n        let pointEnumerator = new PointEnumerator(this);\r\n        let pt;\r\n        while ((pt = pointEnumerator.next())) {\r\n            if (!(pt.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)))\r\n                continue;\r\n\r\n            if (pt.firstPoint) {\r\n                this.ctx.lineWidth = pt.seriesSelected ? this.tb.options.linePlot.highlightedLineWidth : this.tb.options.linePlot.lineWidth;\r\n                this.ctx.strokeStyle = pt.seriesSelected ? pt.series.rState.highlightColour : pt.series.rState.colour;\r\n                this.ctx.beginPath();\r\n                this.ctx.moveTo(pt.x, pt.y);\r\n            } else {\r\n                this.ctx.lineTo(pt.x, pt.y);\r\n            }\r\n            if (pt.lastPoint) {\r\n                this.ctx.stroke();\r\n            }\r\n        }\r\n        if (this.showMarkers) {\r\n            pointEnumerator = new PointEnumerator(this);\r\n            while ((pt = pointEnumerator.next())) {\r\n                if (!(pt.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)))\r\n                    continue;\r\n\r\n                if (pt.selected) {\r\n                    this.ctx.fillStyle = pt.series.rState.glowColour;\r\n                    this.drawMarker(pt.series.markerType, pt.x, pt.y, this.tb.options.linePlot.highlightedMarkerSize);\r\n                }\r\n                this.ctx.fillStyle = pt.series.rState.colour;\r\n                this.drawMarker(pt.series.markerType, pt.x, pt.y, this.tb.options.linePlot.markerSize);\r\n            }\r\n        }\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawLegendIndicator(ctx, series, rect, highlighted) {\r\n        const colour = highlighted ? series.highlightColour : series.colour;\r\n        ctx.save();\r\n        ctx.lineWidth = 2;\r\n        ctx.strokeStyle = colour;\r\n        this.tb.drawLine(rect.left, rect.yMidpoint, rect.right, rect.yMidpoint);\r\n        ctx.fillStyle = colour;\r\n        this.drawMarker(series.markerType, rect.xMidpoint, rect.yMidpoint, this.tb.options.linePlot.markerSize, ctx);\r\n        ctx.restore();\r\n    }\r\n\r\n    drawLabels() {\r\n        if (this.tb.options.labels.enabled) {\r\n            this.ctx.save();\r\n            this.ctx.font = this.tb.labelFont;\r\n            this.ctx.fillStyle = this.tb.options.labels.font.colour;\r\n            let pointEnumerator = new PointEnumerator(this);\r\n            let pt;\r\n            while ((pt = pointEnumerator.next())) {\r\n                if (!(pt.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)))\r\n                    continue;\r\n\r\n                const rect = new Rect(pt.x, pt.y, pt.x, pt.y).inflate(this.tb.options.linePlot.markerSize / 2);\r\n                this.drawLabel(pt.value, pt.series.yAxis.options.labelFormatter(pt.value), rect);\r\n            }\r\n            this.ctx.restore();\r\n        }\r\n    }\r\n\r\n\r\n    hitTest(x, y) {\r\n        // TODO: Optimise\r\n        let ret = {\r\n            found: false,\r\n            plotType: 'line',\r\n            type: 'plotItem',\r\n            isXRange: false\r\n        };\r\n\r\n        let matches = [];\r\n\r\n        let pointEnumerator = new PointEnumerator(this);\r\n        let pt;\r\n        while ((pt = pointEnumerator.next())) {\r\n            if (!(pt.series.visible & (constants.visibilityState.visible | constants.visibilityState.transitioning)))\r\n                continue;\r\n\r\n            const distance = Math.sqrt(Math.pow(pt.x - x, 2) + Math.pow(pt.y - y, 2));\r\n            const horizontalDistance = Math.abs(this.tb.options.swapAxes ? pt.y - y : pt.x - x);\r\n            matches.push({\r\n                distance: distance,\r\n                horizontalDistance: horizontalDistance,\r\n                priority: 0,\r\n                data: pt\r\n            });\r\n            //if (!pt.firstPoint) {\r\n            //    if (x >= lastPt.x && x < pt.x) {\r\n            //const alpha = Math.arctan((pt.y - lastPt.y) / (pt.x - lastPt.x));\r\n            //const yAtX = (x - lastPt.x) * Math.tan(alpha) + lastPt.y;\r\n            //if (yAtX - 2 <= y < yAtX + 2) {\r\n            //    matches.push({\r\n            //        categoryIndex: pt.categoryIndex,\r\n            //        seriesIndex: pt.seriesIndex,\r\n            //        x: bar.rect,\r\n            //        series: this.series[bar.seriesIndex],\r\n            //        dataPoint: this.series[bar.seriesIndex].data[bar.categoryIndex]\r\n            //\r\n            //    })\r\n            //}\r\n            //}\r\n            //}\r\n            //lastPt = pt;\r\n\r\n        }\r\n        if (matches.length) {\r\n            matches.sort((e1, e2) => {\r\n                return (e1.horizontalDistance - e2.horizontalDistance) || (e1.distance - e2.distance);\r\n            });\r\n            if (true || matches[0].distance <= 5) {\r\n                pt = matches[0].data;\r\n                const rect = new Rect(pt.x, pt.y, pt.x, pt.y).inflate(this.tb.options.linePlot.markerSize / 2);\r\n                Utils.assign(ret, [{\r\n                    found: true,\r\n                    rect: rect,\r\n                    normalisedDistance: matches[0].distance + Math.sqrt(rect.area)\r\n                }, pt]);\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n}\r\n\r\nexport class PointEnumerator extends renderer.BySeriesEnumerator {\r\n    next() {\r\n        let ret;\r\n\r\n        if (this.seriesIndex < this.seriesCount) {\r\n            let [x, y] = this.renderer.pointPositions[this.seriesIndex][this.categoryIndex];\r\n\r\n            if (this.isHorizontal)\r\n                [x, y] = [y, x];\r\n\r\n            ret = {\r\n                firstPoint: this.categoryIndex === 0,\r\n                lastPoint: this.categoryIndex + 1 === this.categoryCount,\r\n                seriesIndex: this.seriesIndex,\r\n                categoryIndex: this.categoryIndex,\r\n                series: this.renderer.series[this.seriesIndex],\r\n                value: Tayberry.getDataValue(this.renderer.series[this.seriesIndex].data[this.categoryIndex]),\r\n                x: x,\r\n                y: y,\r\n                seriesSelected: this.tb.selectedItem.type === 'plotItem' && !this.tb.options.tooltips.shared && this.tb.selectedItem.series === this.renderer.series[this.seriesIndex],\r\n                selected: this.tb.selectedItem.type === 'plotItem' && this.tb.selectedItem.categoryIndex === this.categoryIndex && (this.tb.options.tooltips.shared || this.tb.selectedItem.series === this.renderer.series[this.seriesIndex])\r\n            };\r\n\r\n            this.nextValue();\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n","'use strict';\r\nimport {Colour} from './helpers/colour';\r\nimport * as Utils from './helpers/utils.js';\r\n\r\nimport {Tayberry} from './base';\r\nimport {Axis} from './axis';\r\nimport {BarRenderer} from './renderer.bar';\r\nimport {LineRenderer} from './renderer.line';\r\n\r\nvar currentAutoColourIndex = 0;\r\n\r\nTayberry.getAutoColour = function () {\r\n    let ret = Tayberry.defaultColours[currentAutoColourIndex % Tayberry.defaultColours.length];\r\n    currentAutoColourIndex++;\r\n    return ret;\r\n};\r\n\r\nTayberry.getDataValue = function (dataPoint) {\r\n    let ret;\r\n    if (Array.isArray(dataPoint)) {\r\n        ret = dataPoint[1];\r\n    } else {\r\n        ret = dataPoint;\r\n    }\r\n    return ret;\r\n};\r\n\r\nTayberry.getDataXValue = function (data, index) {\r\n    let ret;\r\n    if (Array.isArray(data[index])) {\r\n        ret = data[index][0];\r\n    } else {\r\n        ret = index;\r\n    }\r\n    return ret;\r\n};\r\n\r\nTayberry.setDataValue = function (data, index, newValue) {\r\n    if (Array.isArray(data[index])) {\r\n        data[index][1] = newValue;\r\n    } else {\r\n        data[index] = newValue;\r\n    }\r\n};\r\n\r\nTayberry.prototype.createCanvas = function () {\r\n    let ret = document.createElement('canvas');\r\n    // IE11 hack-fix - clientWidth sometimes incorrect on first access\r\n    ret.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\r\n    ret.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\r\n    ret.style.height = Math.floor(this.containerElement.clientHeight) + 'px';\r\n    ret.style.position = 'absolute';\r\n    this.containerElement.appendChild(ret);\r\n    return ret;\r\n};\r\n\r\nTayberry.prototype.create = function (containerElement) {\r\n    if (typeof containerElement == 'string') {\r\n        this.containerElement = document.getElementById(containerElement);\r\n    } else {\r\n        this.containerElement = containerElement;\r\n    }\r\n    this.labelsCanvas = this.createCanvas();\r\n    this.labelsCtx = this.labelsCanvas.getContext('2d');\r\n    this.plotCanvas = this.createCanvas();\r\n    this.plotCtx = this.plotCanvas.getContext('2d');\r\n    this.options = {};\r\n    this.yAxes = null;\r\n    this.xAxes = null;\r\n    this.initialise();\r\n};\r\n\r\nTayberry.prototype.destroy = function () {\r\n    this.labelsCanvas.parentNode.removeChild(this.labelsCanvas);\r\n    this.tooltipElement.parentNode.removeChild(this.tooltipElement);\r\n    this.options = {};\r\n    this.plotCanvas.removeEventListener('click', this.onClickReal);\r\n    this.plotCanvas.removeEventListener('mousemove', this.onMouseMoveReal);\r\n    this.plotCanvas.removeEventListener('mouseleave', this.onMouseLeaveReal);\r\n    // this.plotCanvas.removeEventListener('touchstart', this.onTouchStartReal);\r\n    window.removeEventListener('resize', this.onWindowResizeReal);\r\n};\r\n\r\nTayberry.prototype.initialise = function () {\r\n    this.scaleFactor = window.devicePixelRatio || 1.0;\r\n    this.labelsCanvas.width = Math.round(this.labelsCanvas.clientWidth * this.scaleFactor);\r\n    this.labelsCanvas.height = Math.round(this.labelsCanvas.clientHeight * this.scaleFactor);\r\n    this.plotCanvas.width = this.labelsCanvas.width;\r\n    this.plotCanvas.height = this.labelsCanvas.height;\r\n    this.scaleFactorX = this.labelsCanvas.width / this.labelsCanvas.clientWidth;\r\n    this.scaleFactorY = this.labelsCanvas.height / this.labelsCanvas.clientHeight;\r\n    this.selectedItem = {};\r\n    this.plotArea = null;\r\n};\r\n\r\nTayberry.prototype.getFontHeight = function (font, forDom) {\r\n    let ret = font.size;\r\n    if (font.autoScale)\r\n        ret *= Math.pow(this.labelsCanvas.width / 800, 0.25);\r\n    if (!forDom) ret = this.mapLogicalYUnit(ret);\r\n    return ret;\r\n};\r\n\r\nTayberry.prototype.createFontString = function (font, forDom) {\r\n    return (font.style ? font.style + ' ' : '') + this.getFontHeight(font, forDom).toFixed(1) + 'px ' + font.face;\r\n};\r\n\r\nTayberry.prototype.updateFonts = function () {\r\n    //this.labelsCtx.font = this.createFontString(this.options.font);\r\n    this.titleFont = this.createFontString(this.options.title.font);\r\n    this.labelFont = this.createFontString(this.options.labels.font);\r\n    this.legendFont = this.createFontString(this.options.legend.font);\r\n    this.yAxes.map(e => e.updateFonts());\r\n    this.xAxes.map(e => e.updateFonts());\r\n};\r\n\r\nTayberry.prototype.setOptions = function (options) {\r\n    let optionOverrides = [this.defaultOptions()];\r\n    if (!options.presets) {\r\n        options.presets = ['default'];\r\n    }\r\n    if (options.presets) {\r\n        for (let index = 0; index < options.presets.length; index++) {\r\n            optionOverrides.push(Tayberry.presets[options.presets[index]]);\r\n        }\r\n    }\r\n    optionOverrides.push(options);\r\n    this.options = Utils.deepAssign({}, optionOverrides);\r\n    this.options.title.font = Utils.deepAssign({}, [this.options.font, this.options.title.font]);\r\n    this.options.tooltips.font = Utils.deepAssign({}, [this.options.font, this.options.tooltips.font]);\r\n    this.options.labels.font = Utils.deepAssign({}, [this.options.font, this.options.labels.font]);\r\n    this.options.legend.font = Utils.deepAssign({}, [this.options.font, this.options.legend.font]);\r\n    this.options.allAxes.font = Utils.deepAssign({}, [this.options.font, this.options.allAxes.font]);\r\n    this.options.allAxes.title.font = Utils.deepAssign({}, [this.options.font, this.options.allAxes.title.font]);\r\n    if (!Array.isArray(this.options.yAxis))\r\n        this.options.yAxis = [this.options.yAxis || {}];\r\n    if (!Array.isArray(this.options.xAxis))\r\n        this.options.xAxis = [this.options.xAxis || {}];\r\n    for (let i = 0; i < this.options.yAxis.length; i++) {\r\n        this.options.yAxis[i] = Utils.deepAssign({}, [i === 0 ? Tayberry.defaultPrimaryYAxis : Tayberry.defaultSecondaryYAxis, this.options.allAxes, this.options.yAxis[i]]);\r\n    }\r\n    for (let i = 0; i < this.options.xAxis.length; i++) {\r\n        this.options.xAxis[i] = Utils.deepAssign({}, [Tayberry.defaultXAxis, this.options.allAxes, this.options.xAxis[i]]);\r\n    }\r\n    for (let i = 0; i < this.options.series.length; i++) {\r\n        this.options.series[i] = Utils.deepAssign({}, [Tayberry.defaultSeries, this.options.series[i]]);\r\n    }\r\n\r\n    this.yAxes = [];\r\n    this.xAxes = [];\r\n    for (let i = 0; i < this.options.xAxis.length; i++) {\r\n        this.xAxes.push(Axis.create(this, this.options.xAxis[i], i, 'x', this.options.swapAxes));\r\n    }\r\n    for (let i = 0; i < this.options.yAxis.length; i++) {\r\n        this.yAxes.push(Axis.create(this, this.options.yAxis[i], i, 'y', this.options.swapAxes));\r\n    }\r\n    this.updateFonts();\r\n    this.createRenderers();\r\n    this.calculatePlotArea();\r\n    this.callbacks['onInit'].forEach(func => func());\r\n    this.plotCanvas.addEventListener('click', this.onClickReal = this.onClick.bind(this));\r\n    this.plotCanvas.addEventListener('mousemove', this.onMouseMoveReal = this.onMouseMove.bind(this));\r\n    this.plotCanvas.addEventListener('mouseleave', this.onMouseLeaveReal = this.onMouseLeave.bind(this));\r\n    //this.plotCanvas.addEventListener('touchstart', this.onTouchStartReal = this.onTouchStart.bind(this));\r\n    window.addEventListener('resize', this.onWindowResizeReal = Utils.throttle(this.onWindowResize, 50).bind(this));\r\n};\r\n\r\nTayberry.calculateHighlightColour = function (colour) {\r\n    let newColour = new Colour(colour);\r\n    return newColour.increaseBy(30 * (newColour.sum >= 180 * 3 ? -1 : 1)).toString();\r\n};\r\n\r\nTayberry.calculateGlowColour = function (highlightColour) {\r\n    let newColour = new Colour(highlightColour);\r\n    newColour.a = 0.4;\r\n    return newColour.toString();\r\n};\r\n\r\nTayberry.prototype.createRenderers = function () {\r\n    let series, groupedSeries = {'bar': [], 'line': []};\r\n    if (!Array.isArray(this.options.series)) {\r\n        series = [this.options.series];\r\n    } else {\r\n        series = this.options.series;\r\n    }\r\n\r\n    for (let i = 0; i < series.length; i++) {\r\n        const curSeries = series[i];\r\n        curSeries.index = i;\r\n        curSeries.colour = curSeries.colour || Tayberry.getAutoColour();\r\n        curSeries.highlightColour = curSeries.highlightColour || Tayberry.calculateHighlightColour(curSeries.colour);\r\n        curSeries.glowColour = curSeries.glowColour || Tayberry.calculateGlowColour(curSeries.highlightColour);\r\n        curSeries.rState = {\r\n            colour: curSeries.colour,\r\n            highlightColour: curSeries.highlightColour,\r\n            glowColour: curSeries.glowColour\r\n        };\r\n        curSeries.xAxis = this.xAxes[curSeries.xAxisIndex || 0];\r\n        curSeries.yAxis = this.yAxes[curSeries.yAxisIndex || 0];\r\n        curSeries.plotType = curSeries.plotType || this.options.plotType;\r\n        if (groupedSeries.hasOwnProperty(curSeries.plotType)) {\r\n            groupedSeries[curSeries.plotType].push(curSeries);\r\n        }\r\n    }\r\n    if (groupedSeries['bar'].length) {\r\n        this.renderers.push(new BarRenderer(this.plotCtx, this, groupedSeries['bar']));\r\n    }\r\n    if (groupedSeries['line'].length) {\r\n        this.renderers.push(new LineRenderer(this.plotCtx, this, groupedSeries['line']));\r\n    }\r\n};\r\n\r\nTayberry.prototype.getDataMinMax = function (axis) {\r\n    var minNormal, maxNormal, minStacked, maxStacked;\r\n    if (this.options.barPlot.mode === 'stacked') {\r\n        let seriesPositiveTotals = [];\r\n        let seriesNegativeTotals = [];\r\n        const barSeries = this.options.series.filter(series => series.plotType === 'bar' && series.yAxis === axis);\r\n        if (barSeries.length) {\r\n            for (let categoryIndex = 0; categoryIndex < barSeries[0].data.length; categoryIndex++) {\r\n                seriesPositiveTotals[categoryIndex] = 0;\r\n                seriesNegativeTotals[categoryIndex] = 0;\r\n                for (let seriesIndex = 0; seriesIndex < barSeries.length; seriesIndex++) {\r\n                    const value = Tayberry.getDataValue(barSeries[seriesIndex].data[categoryIndex]);\r\n                    if (!Utils.isMissingValue(value)) {\r\n                        if (value < 0) {\r\n                            seriesNegativeTotals[categoryIndex] += value;\r\n                        } else {\r\n                            seriesPositiveTotals[categoryIndex] += value;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        minStacked = Math.min(0, Utils.reduce(seriesNegativeTotals, Math.min, undefined, true));\r\n        maxStacked = Math.max(Utils.reduce(seriesPositiveTotals, Math.max, undefined, true), 0);\r\n    }\r\n    {\r\n        let seriesMinima = [];\r\n        let seriesMaxima = [];\r\n        for (let index = 0; index < this.options.series.length; index++) {\r\n            const series = this.options.series[index];\r\n            if (series.yAxis === axis && (series.plotType !== 'bar' || this.options.barPlot.mode !== 'stacked')) {\r\n                seriesMinima.push(Utils.reduce(series.data, Math.min, Tayberry.getDataValue, true));\r\n                seriesMaxima.push(Utils.reduce(series.data, Math.max, Tayberry.getDataValue, true));\r\n            }\r\n        }\r\n        minNormal = Utils.reduce(seriesMinima, Math.min, undefined, true);\r\n        maxNormal = Utils.reduce(seriesMaxima, Math.max, undefined, true);\r\n    }\r\n    const min = Utils.reduce([minNormal, minStacked], Math.min, undefined, true);\r\n    const max = Utils.reduce([maxNormal, maxStacked], Math.max, undefined, true);\r\n    return [min, max];\r\n};\r\n\r\nTayberry.prototype.getDataXMinMax = function (axis) {\r\n    var min, max;\r\n    const seriesMinima = [];\r\n    const seriesMaxima = [];\r\n    for (let index = 0; index < this.options.series.length; index++) {\r\n        const series = this.options.series[index];\r\n        if (series.xAxis === axis) {\r\n            seriesMinima.push(Utils.reduce(series.data, Math.min, Tayberry.getDataXValue, true));\r\n            seriesMaxima.push(Utils.reduce(series.data, Math.max, Tayberry.getDataXValue, true));\r\n        }\r\n    }\r\n    min = Utils.reduce(seriesMinima, Math.min, undefined, true);\r\n    max = Utils.reduce(seriesMaxima, Math.max, undefined, true);\r\n    return [min, max];\r\n};\r\n\r\n\r\nTayberry.prototype.createTooltip = function () {\r\n    if (this.tooltipElement) {\r\n        this.tooltipElement.parentNode.removeChild(this.tooltipElement);\r\n        this.tooltipElement = null;\r\n    }\r\n    this.tooltipElement = document.createElement('div');\r\n    this.tooltipElement.className = 'tayberry-tooltip';\r\n    this.tooltipElement.style.position = 'absolute';\r\n    this.tooltipElement.style.left = '0px';\r\n    this.tooltipElement.style.top = '0px';\r\n    this.tooltipElement.style.zIndex = '99999';\r\n    this.tooltipElement.style.font = this.createFontString(this.options.tooltips.font, true);\r\n    this.tooltipElement.style.borderRadius = '3px';\r\n    this.tooltipElement.style.backgroundColor = 'white';\r\n    this.tooltipElement.style.border = '2px solid #bbb';\r\n    this.tooltipElement.style.padding = '0.15em 0.4em';\r\n    this.tooltipElement.style.display = 'none';\r\n    this.tooltipElement.innerHTML = '';\r\n    document.body.appendChild(this.tooltipElement);\r\n    this.tooltipElement.addEventListener('mousemove', this.onMouseMove.bind(this));\r\n    this.tooltipElement.addEventListener('mouseleave', this.onMouseLeave.bind(this));\r\n};\r\n","'use strict';\r\nimport {Tayberry} from './base';\r\nimport {Rect} from './helpers/rect';\r\n\r\nTayberry.prototype.getTextWidth = function (text, fontString) {\r\n    let ret;\r\n    if (fontString) {\r\n        this.labelsCtx.save();\r\n        this.labelsCtx.font = fontString;\r\n    }\r\n    ret = this.labelsCtx.measureText(text).width;\r\n    if (fontString) {\r\n        this.labelsCtx.restore();\r\n    }\r\n    return ret;\r\n};\r\n\r\nTayberry.prototype.getMultilineTextHeight = function (fontString, maxWidth, text) {\r\n    let ret;\r\n    if (fontString) {\r\n        this.labelsCtx.save();\r\n        this.labelsCtx.font = fontString;\r\n    }\r\n    ret = this.splitMultilineText(maxWidth, text).length;\r\n    if (fontString) {\r\n        this.labelsCtx.restore();\r\n    }\r\n    return ret;\r\n};\r\n\r\n\r\nTayberry.prototype.splitMultilineText = function (maxWidth, text) {\r\n    let lines = [];\r\n    let lineWidth = 0;\r\n    let lineText = '';\r\n    const spaceWidth = this.labelsCtx.measureText(' ').width;\r\n    for (let i = 0; i < text.length;) {\r\n        const wordStart = i;\r\n        while (i < text.length && text[i] !== ' ' && text[i] !== '\\r' && text[i] !== '\\n') i++;\r\n        const wordEnd = i;\r\n        while (i < text.length && (text[i] === ' ' || text[i] === '\\r' || text[i] === '\\n')) i++;\r\n        if (wordEnd > wordStart) {\r\n            const word = text.substring(wordStart, wordEnd);\r\n            const wordWidth = this.labelsCtx.measureText(word).width;\r\n            if (lineWidth + wordWidth > maxWidth) {\r\n                if (!lineWidth) {\r\n                    lineText = word;\r\n                }\r\n                lines.push(lineText);\r\n                if (lineWidth) {\r\n                    lineWidth = 0;\r\n                    lineText = word;\r\n                }\r\n            } else {\r\n                lineText += (lineText ? ' ' : '') + word;\r\n                lineWidth += wordWidth + spaceWidth;\r\n            }\r\n        }\r\n    }\r\n    if (lineText) {\r\n        lines.push(lineText);\r\n    }\r\n    return lines;\r\n};\r\n\r\nTayberry.prototype.drawTextMultiline = function (lineHeight, x, y, maxWidth, text) {\r\n    let lines = this.splitMultilineText(maxWidth, text);\r\n\r\n    for (let i = 0; i < lines.length; i++) {\r\n        let line = lines[i];\r\n        this.labelsCtx.fillText(line, x, y + lineHeight * i);\r\n    }\r\n};\r\n\r\nTayberry.prototype.render = function () {\r\n    this.drawLabelLayer();\r\n    this.createTooltip();\r\n    if (this.options.animations.enabled) {\r\n        for (let index = 0; index < this.options.series.length; index++) {\r\n            const series = this.options.series[index];\r\n            this.setSeriesVisibility(series, true, 'height');\r\n        }\r\n    } else {\r\n        this.drawPlotLayer();\r\n    }\r\n};\r\n\r\nTayberry.prototype.clear = function (plot = true, labels = true) {\r\n    if (plot) this.plotCtx.clearRect(0, 0, this.plotCanvas.width, this.plotCanvas.height);\r\n    if (labels) this.labelsCtx.clearRect(0, 0, this.labelsCanvas.width, this.labelsCanvas.height);\r\n};\r\n\r\nTayberry.prototype.drawBackground = function () {\r\n    if (this.options.plotBackgroundColour) {\r\n        this.labelsCtx.save();\r\n        this.labelsCtx.fillStyle = this.options.plotBackgroundColour;\r\n        this.labelsCtx.fillRect(this.plotArea.left, this.plotArea.top, this.plotArea.width, this.plotArea.height);\r\n        this.labelsCtx.restore();\r\n    }\r\n};\r\n\r\nTayberry.prototype.drawTitle = function () {\r\n    if (this.options.title.text) {\r\n        const x = (this.labelsCanvas.width) / 2, y = 0;\r\n        this.labelsCtx.save();\r\n        this.labelsCtx.textAlign = 'center';\r\n        this.labelsCtx.textBaseline = 'top';\r\n        this.labelsCtx.font = this.titleFont;\r\n        this.labelsCtx.fillStyle = this.options.title.font.colour;\r\n        this.drawTextMultiline(this.getFontHeight(this.options.title.font), x, y, this.labelsCanvas.width, this.options.title.text);\r\n        // this.labelsCtx.fillText(this.options.title.text, x, y);\r\n        this.labelsCtx.restore();\r\n    }\r\n};\r\n\r\nTayberry.prototype.drawPlotLayer = function () {\r\n    for (let i = 0; i < this.renderers.length; i++) {\r\n        this.renderers[i].drawPlot();\r\n    }\r\n    for (let i = 0; i < this.renderers.length; i++) {\r\n        this.renderers[i].drawLabels();\r\n    }\r\n};\r\n\r\n\r\nTayberry.prototype.drawLine = function (x1, y1, x2, y2, colour, ctx = this.labelsCtx) {\r\n    ctx.save();\r\n    if (colour) {\r\n        ctx.strokeStyle = colour;\r\n    }\r\n    ctx.beginPath();\r\n    ctx.moveTo(x1 + 0.5, y1 + 0.5);\r\n    ctx.lineTo(x2 + 0.5, y2 + 0.5);\r\n    ctx.stroke();\r\n    ctx.restore();\r\n};\r\n\r\nTayberry.prototype.drawLabelLayer = function () {\r\n    this.drawBackground();\r\n    this.drawTitle();\r\n    let offsetRect = new Rect(0);\r\n    this.xAxes.map(e => e.draw(offsetRect));\r\n    this.yAxes.map(e => e.draw(offsetRect));\r\n    this.drawLegend();\r\n};\r\n\r\nTayberry.prototype.redraw = function (plotOnly) {\r\n    this.clear(true, !plotOnly);\r\n    if (!plotOnly) {\r\n        this.drawLabelLayer();\r\n    }\r\n    this.drawPlotLayer();\r\n};\r\n\r\n","'use strict';\r\nimport {Rect} from './helpers/rect';\r\nimport * as Utils from './helpers/utils.js';\r\n\r\nimport {Tayberry} from './base';\r\n\r\nTayberry.prototype.registerCallback = function (eventName, func) {\r\n    this.callbacks[eventName].push(func);\r\n};\r\n\r\nTayberry.prototype.onMouseLeave = function (event) {\r\n    if ((event.currentTarget == this.plotCanvas && event.relatedTarget !== this.tooltipElement) || (event.currentTarget == this.tooltipElement && event.relatedTarget !== this.plotCanvas)) {\r\n        this.selectedItem = {};\r\n        this.tooltipElement.style.display = 'none';\r\n        this.redraw();\r\n    }\r\n};\r\n\r\nTayberry.prototype.handleMouseMove = function (clientX, clientY) {\r\n    let boundingRect = new Rect(this.plotCanvas.getBoundingClientRect());\r\n    let ret = false;\r\n    let tooltipDisplayStyle = 'none';\r\n    if (boundingRect.containsPoint(clientX, clientY)) {\r\n        let x = clientX - boundingRect.left;\r\n        let y = clientY - boundingRect.top;\r\n\r\n        let hitTestResult = this.hitTest(this.mapLogicalXUnit(x), this.mapLogicalYUnit(y));\r\n        if (hitTestResult.found) {\r\n            if (hitTestResult.type === 'legend') {\r\n                this.selectedItem = hitTestResult;\r\n                ret = true;\r\n            } else if (hitTestResult.type === 'plotItem') {\r\n                let tooltipHtml = '';\r\n                const aboveZero = hitTestResult.rect.top < hitTestResult.rect.bottom;\r\n                tooltipDisplayStyle = 'block';\r\n                if (this.options.tooltips.shared) {\r\n                    const category = this.xAxes[0].getCategoryLabel(hitTestResult.categoryIndex, this.categoryCount, hitTestResult.isXRange);\r\n                    tooltipHtml += Utils.formatString(this.options.tooltips.headerTemplate, {category: category}, true);\r\n                    for (let index = 0; index < this.seriesCount; index++) {\r\n                        const series = this.options.series[index];\r\n                        const value = Tayberry.getDataValue(series.data[hitTestResult.categoryIndex]);\r\n                        tooltipHtml += Utils.formatString(this.options.tooltips.valueTemplate, {\r\n                            value: series.yAxis.options.labelFormatter(value),\r\n                            name: series.name,\r\n                            colour: series.colour\r\n                        }, true);\r\n                    }\r\n                } else {\r\n                    const series = hitTestResult.series;\r\n                    const value = hitTestResult.value;\r\n                    const category = series.xAxis.getCategoryLabel(hitTestResult.categoryIndex, this.categoryCount, hitTestResult.isXRange);\r\n                    tooltipHtml += Utils.formatString(this.options.tooltips.headerTemplate, {category: category}, true);\r\n                    tooltipHtml += Utils.formatString(this.options.tooltips.valueTemplate, {\r\n                        value: series.yAxis.options.labelFormatter(value),\r\n                        name: series.name,\r\n                        colour: series.colour\r\n                    }, true);\r\n                }\r\n                tooltipHtml += this.options.tooltips.footerTemplate;\r\n                this.tooltipElement.innerHTML = tooltipHtml;\r\n                let tooltipRect = this.tooltipElement.getBoundingClientRect();\r\n                if (!this.options.tooltips.shared) {\r\n                    this.tooltipElement.style.borderColor = hitTestResult.series.colour;\r\n                }\r\n                this.tooltipElement.style.left = window.pageXOffset + boundingRect.left + this.mapScreenUnit(hitTestResult.rect.width) / 2 + hitTestResult.rect.left / this.scaleFactor - tooltipRect.width / 2 + 'px';\r\n                this.tooltipElement.style.top = window.pageYOffset + boundingRect.top + this.mapScreenUnit(hitTestResult.rect.top) - tooltipRect.height * (aboveZero ? 1 : 0) - this.options.elementSmallPadding * (aboveZero ? 1 : -1) + 'px';\r\n                this.selectedItem = hitTestResult;\r\n                ret = true;\r\n            }\r\n        }\r\n    }\r\n    this.tooltipElement.style.display = tooltipDisplayStyle;\r\n    return ret;\r\n};\r\n\r\n\r\n//Tayberry.prototype.onTouchStart = function (event) {\r\n//    for (let index = 0; index < event.targetTouches.length; index++) {\r\n//        let touch = event.targetTouches[index];\r\n//        if (this.handleMouseMove(touch.clientX, touch.clientY)) {\r\n//            // event.preventDefault();\r\n//            this.redraw();\r\n//            break;\r\n//        }\r\n//    }\r\n//};\r\n\r\nTayberry.prototype.onClick = function (event) {\r\n    let boundingRect = new Rect(this.plotCanvas.getBoundingClientRect());\r\n    // Why is event.buttons always 0?\r\n    if ((event.button === 0) && boundingRect.containsPoint(event.clientX, event.clientY)) {\r\n        let x = event.clientX - boundingRect.left;\r\n        let y = event.clientY - boundingRect.top;\r\n        let hitTestResult = this.hitTest(this.mapLogicalXUnit(x), this.mapLogicalYUnit(y));\r\n        if (hitTestResult.found) {\r\n            if (hitTestResult.type === 'legend') {\r\n                const series = hitTestResult.data.series;\r\n\r\n                this.toggleSeriesVisibility(series);\r\n                this.clear(false, true);\r\n                this.drawLabelLayer();\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nTayberry.prototype.onMouseMove = function (event) {\r\n    let oldSelectedItem = Utils.assign({}, this.selectedItem);\r\n    if (!this.handleMouseMove(event.clientX, event.clientY)) {\r\n        this.selectedItem = {};\r\n    }\r\n\r\n    if (oldSelectedItem.type !== this.selectedItem.type ||\r\n        oldSelectedItem.categoryIndex !== this.selectedItem.categoryIndex ||\r\n        oldSelectedItem.series !== this.selectedItem.series) {\r\n        this.redraw();\r\n    }\r\n};\r\n\r\nTayberry.prototype.onWindowResize = function () {\r\n    this.tooltipElement.style.display = 'none';\r\n    this.labelsCanvas.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\r\n    this.labelsCanvas.style.height = Math.floor(this.containerElement.clientHeight) + 'px';\r\n    this.plotCanvas.style.width = Math.floor(this.containerElement.clientWidth) + 'px';\r\n    this.plotCanvas.style.height = Math.floor(this.containerElement.clientHeight) + 'px';\r\n    this.initialise();\r\n    this.updateFonts();\r\n    this.calculatePlotArea();\r\n    this.createTooltip();\r\n    this.callbacks['onResize'].forEach(func => func());\r\n    this.redraw();\r\n};\r\n","'use strict';\r\nimport {Tayberry} from './base';\r\nimport * as Utils from './helpers/utils.js';\r\nimport * as constants from './constants';\r\n\r\nTayberry.prototype.defaultOptions = function () {\r\n    return {\r\n        title: {\r\n            text: '',\r\n            font: {\r\n                size: 20\r\n            }\r\n        },\r\n        font: {\r\n            colour: '#444',\r\n            size: 12,\r\n            face: 'sans-serif',\r\n            style: '',\r\n            autoScale: true\r\n        },\r\n        allAxes: {\r\n            font: {},\r\n            title: {\r\n                font: {}\r\n            }\r\n        },\r\n        xAxis: [],\r\n        yAxis: [],\r\n        animations: {\r\n            enabled: true\r\n        },\r\n        series: [],\r\n        backgroundColour: undefined,\r\n        swapAxes: false,\r\n        plotType: 'bar',\r\n        barPlot: {\r\n            mode: 'normal', //[normal|stacked|overlaid]\r\n            barPadding: 2,\r\n            categorySpacing: 0.3\r\n        },\r\n        linePlot: {\r\n            lineWidth: 2,\r\n            highlightedLineWidth: 4,\r\n            showMarkers: 'auto',\r\n            noMarkersThreshold: 100,\r\n            markerSize: 10,\r\n            highlightedMarkerSize: 18\r\n        },\r\n        elementSmallPadding: 5,\r\n        elementLargePadding: 10,\r\n        presets: [],\r\n        tooltips: {\r\n            shared: false,\r\n            headerTemplate: '<strong>{category}</strong><table>',\r\n            valueTemplate: '<tr><td style=\"padding-right: 0.5em\"><span style=\"color: {colour}\">\\u25CF</span> {name}</td><td style=\"text-align: right\">{value}</td></tr>',\r\n            footerTemplate: '</table>',\r\n            font: {}\r\n        },\r\n        legend: {\r\n            enabled: true,\r\n            indicatorSize: 15,\r\n            font: {},\r\n            hiddenAlphaMultiplier: 0.5\r\n        },\r\n        labels: {\r\n            enabled: false,\r\n            verticalAlignment: 'top',\r\n            verticalPosition: 'outside',\r\n            font: {}\r\n        }\r\n    }\r\n};\r\n\r\nTayberry.defaultSeries = {\r\n    visible: constants.visibilityState.visible\r\n};\r\n\r\nTayberry.defaultXAxis = {\r\n    title: {\r\n        text: '',\r\n        font: {}\r\n    },\r\n    type: 'categorial',\r\n    min: null,\r\n    max: null,\r\n    tickStep: 40,\r\n    tickStepValue: null,\r\n    font: {},\r\n    categories: [],\r\n    labelPosition: 'middle', //left|middle|right\r\n    placement: 'auto',\r\n    gridLines: {}\r\n};\r\n\r\nTayberry.defaultYAxis = {\r\n    title: {\r\n        text: '',\r\n        font: {}\r\n    },\r\n    min: undefined,\r\n    max: undefined,\r\n    tickStep: 40,\r\n    tickStepValue: null,\r\n    font: {},\r\n    labelFormat: 'number', //[number|percentage|currency],\r\n    labelFormatter: undefined,\r\n    labelPrefix: undefined,\r\n    labelSuffix: undefined,\r\n    currencySymbol: '£',\r\n    placement: 'auto',\r\n    type: 'linear',\r\n    gridLines: {}\r\n\r\n};\r\n\r\nTayberry.defaultPrimaryYAxis = Utils.deepAssign({}, [Tayberry.defaultYAxis, {\r\n    gridLines: {\r\n        colour: '#ccc'\r\n    }\r\n}]);\r\n\r\nTayberry.defaultSecondaryYAxis = Tayberry.defaultYAxis;\r\n\r\nTayberry.presets = {\r\n    histogram: {\r\n        barPlot: {\r\n            mode: 'overlaid',\r\n            categorySpacing: 0,\r\n            barPadding: 1\r\n        }\r\n    },\r\n    darkGrid: {\r\n        allAxes: {\r\n            gridLines: {\r\n                colour: 'rgba(255, 255, 255, 0.6)'\r\n            }\r\n        },\r\n        plotBackgroundColour: '#E5E5E5'\r\n    }\r\n};\r\n\r\nTayberry.defaultColours = [\r\n    '#6FE87B', //green\r\n    '#FFAB51', //orange\r\n    '#51A8FF', //blue\r\n    '#B651FF', //purple\r\n    '#FF6051', //red\r\n    '#636363', //dark grey\r\n    '#FFE314', //yellow\r\n    '#A88572', //brown\r\n    '#B7B7B7' //light grey\r\n];\r\n","'use strict';\r\nimport {Rect} from './helpers/rect';\r\nimport {Tayberry} from './base';\r\nimport * as Utils from './helpers/utils.js';\r\n\r\nTayberry.mapVerticalPosition = function (sign, position) {\r\n    switch (position) {\r\n        case \"outside\":\r\n            return sign > 0 ? \"bottom\" : \"top\";\r\n        case \"inside\":\r\n            return sign > 0 ? \"top\" : \"bottom\";\r\n        default:\r\n            return \"middle\";\r\n    }\r\n};\r\n\r\nTayberry.prototype.mapLogicalXUnit = function (x) {\r\n    return this.scaleFactorX * x;\r\n};\r\n\r\nTayberry.prototype.mapLogicalYUnit = function (x) {\r\n    return this.scaleFactorY * x;\r\n};\r\n\r\nTayberry.prototype.mapScreenUnit = function (x) {\r\n    return x / this.scaleFactor;\r\n};\r\n\r\nTayberry.prototype.calculatePlotArea = function () {\r\n    const MAX_AXIS_CALC_SIZE_ATTEMPTS = 5;\r\n\r\n    this.plotArea = new Rect(0, 0, this.labelsCanvas.width, this.labelsCanvas.height);\r\n    if (this.options.title.text) {\r\n        this.plotArea.top += this.mapLogicalYUnit(this.options.elementSmallPadding);\r\n        this.plotArea.top += this.getFontHeight(this.options.title.font) * this.getMultilineTextHeight(this.titleFont, this.labelsCanvas.width, this.options.title.text);\r\n    }\r\n    if (this.options.legend.enabled)\r\n        this.plotArea.bottom -= this.mapLogicalYUnit(this.options.elementSmallPadding + this.options.elementLargePadding + this.options.legend.indicatorSize);\r\n\r\n    this.yAxes.map(e => e.adjustSize(this.plotArea, true, true));\r\n    this.xAxes.map(e => e.adjustSize(this.plotArea, true, true));\r\n\r\n    for (let i = 0; i < MAX_AXIS_CALC_SIZE_ATTEMPTS; i++) {\r\n        this.yAxes.map(e => e.calculateExtent());\r\n        this.xAxes.map(e => e.calculateExtent());\r\n        this.yAxes.map(e => e.updateFormatter());\r\n        this.xAxes.map(e => e.updateFormatter());\r\n        if (Utils.none(this.yAxes.map(e => e.adjustSize(this.plotArea))) && Utils.none(this.xAxes.map(e => e.adjustSize(this.plotArea))))\r\n            break;\r\n    }\r\n    this.plotArea.left = Math.ceil(this.plotArea.left);\r\n    this.plotArea.top = Math.ceil(this.plotArea.top);\r\n    this.plotArea.right = Math.floor(this.plotArea.right);\r\n    this.plotArea.bottom = Math.floor(this.plotArea.bottom);\r\n};\r\n\r\nTayberry.prototype.hitTest = function (x, y) {\r\n    let ret = {\r\n        found: false\r\n    };\r\n    let matches = [];\r\n    for (let i = 0; i < this.renderers.length; i++) {\r\n        const hitTestResult = this.renderers[i].hitTest(x, y);\r\n        if (hitTestResult.found) {\r\n            matches.push(hitTestResult);\r\n        }\r\n    }\r\n    matches.push(this.hitTestLegend(x, y));\r\n    if (matches.length) {\r\n        matches.sort((a, b) => !a.found - !b.found || a.normalisedDistance - b.normalisedDistance);\r\n        ret = matches[0];\r\n    }\r\n    return ret;\r\n};\r\n\r\n","'use strict';\r\nimport {Tayberry} from './base';\r\nimport {Rect} from './helpers/rect';\r\nimport * as Utils from './helpers/utils.js';\r\nimport * as constants from './constants';\r\nimport {Colour} from './helpers/colour';\r\n\r\nTayberry.prototype.drawLegend = function () {\r\n    if (this.options.legend.enabled) {\r\n        let legendMetrics = this.getLegendMeasurements();\r\n        this.labelsCtx.save();\r\n        this.labelsCtx.font = this.legendFont;\r\n\r\n        for (let index = 0; index < legendMetrics.items.length; index++) {\r\n            const item = legendMetrics.items[index];\r\n            const series = item.series;\r\n            const highlighted = this.selectedItem.type === 'legend' && this.selectedItem.data.series === series;\r\n            series.renderer.drawLegendIndicator(this.labelsCtx, series, item.indicatorRect, highlighted);\r\n            this.labelsCtx.textBaseline = 'middle';\r\n            this.labelsCtx.fillStyle = this.options.legend.font.colour;\r\n            if (!(series.visible & constants.visibilityState.visible))\r\n                this.labelsCtx.fillStyle = (new Colour(this.labelsCtx.fillStyle)).multiplyAlpha(this.options.legend.hiddenAlphaMultiplier).toString();\r\n            this.labelsCtx.fillText(series.name, item.textX, item.textY);\r\n        }\r\n        this.labelsCtx.restore();\r\n    }\r\n};\r\n\r\nTayberry.prototype.hitTestLegend = function (x, y) {\r\n    let ret = {\r\n        found: false,\r\n        type: 'legend'\r\n    };\r\n    const legendMetrics = this.getLegendMeasurements();\r\n    if (legendMetrics.rect.containsPoint(x, y)) {\r\n        for (let index = 0; index < legendMetrics.items.length; index++) {\r\n            const item = legendMetrics.items[index];\r\n            if (item.rect.containsPoint(x, y)) {\r\n                Utils.assign(ret, [{found: true, normalisedDistance: -5, data: item}]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n};\r\n\r\nTayberry.prototype.getLegendMeasurements = function () {\r\n    let ret = {\r\n        rect: new Rect(0),\r\n        items: []\r\n    };\r\n    if (this.options.legend.enabled) {\r\n        const smallPadding = this.mapLogicalXUnit(this.options.elementSmallPadding);\r\n        const largePadding = this.mapLogicalXUnit(this.options.elementLargePadding);\r\n        let totalWidth = 0;\r\n        const indicatorSize = this.mapLogicalXUnit(this.options.legend.indicatorSize);\r\n        for (let index = 0; index < this.options.series.length; index++) {\r\n            const series = this.options.series[index];\r\n            let textWidth = 0;\r\n            if (series.name) {\r\n                textWidth = this.getTextWidth(series.name, this.legendFont);\r\n                totalWidth += textWidth + indicatorSize + smallPadding + largePadding;\r\n                ret.items.push({textWidth: textWidth, series: series});\r\n            }\r\n        }\r\n        let x = this.plotArea.left + this.plotArea.width / 2 - totalWidth / 2,\r\n            y = this.labelsCanvas.height - indicatorSize;\r\n\r\n        ret.rect.left = x;\r\n        ret.rect.right = x + totalWidth;\r\n        ret.rect.top = y;\r\n        ret.rect.bottom = y + indicatorSize;\r\n\r\n        for (let index = 0; index < ret.items.length; index++) {\r\n            let item = ret.items[index];\r\n            item.rect = new Rect(x, ret.rect.top, x + indicatorSize + smallPadding + item.textWidth, ret.rect.bottom);\r\n            item.indicatorRect = new Rect(x, ret.rect.top, x + indicatorSize, ret.rect.bottom);\r\n            x += indicatorSize + smallPadding;\r\n            item.textX = x;\r\n            item.textY = y + indicatorSize / 2;\r\n\r\n            x += ret.items[index].textWidth + largePadding;\r\n        }\r\n    }\r\n    return ret;\r\n};\r\n","'use strict';\r\nimport {Tayberry} from './base';\r\nimport * as Utils from './helpers/utils.js';\r\nimport * as constants from './constants';\r\n\r\nTayberry.prototype.revokeAnimation = function (series) {\r\n    for (let index = this.pendingAnimations.length; index; index--) {\r\n        if (this.pendingAnimations[index-1].series === series) {\r\n            this.pendingAnimations.splice(index-1, 1);\r\n        }\r\n    }\r\n};\r\n\r\nTayberry.prototype.startAnimation = function (animation) {\r\n    animation.initialStage = animation.initialStage || 0;\r\n    var newAnimation = Utils.assign({}, [{\r\n        length: 500*(1-animation.initialStage),\r\n        startTime: (typeof performance !== 'undefined' && typeof performance.now !== 'undefined') ? performance.now() : null\r\n    },\r\n        animation\r\n    ]);\r\n    this.pendingAnimations.push(newAnimation);\r\n    if (!this.animator)\r\n        this.animator = requestAnimationFrame(this.onAnimate.bind(this));\r\n    return newAnimation;\r\n};\r\n\r\nTayberry.prototype.onAnimate = function (timestamp) {\r\n    var elapsed;\r\n    for (let index = this.pendingAnimations.length - 1; index >= 0; index--) {\r\n        let animation = this.pendingAnimations[index];\r\n        if (animation.startTime === null) {\r\n            animation.startTime = timestamp;\r\n        }\r\n        elapsed = timestamp - animation.startTime;\r\n        if (animation.onFrame) {\r\n            animation.onFrame(animation.initialStage + Math.min(elapsed / animation.length, 1) * (1 - animation.initialStage));\r\n        }\r\n        if (elapsed >= animation.length) {\r\n            this.pendingAnimations.splice(index, 1);\r\n            if (animation.onCompletion) {\r\n                animation.onCompletion();\r\n            }\r\n        }\r\n    }\r\n    for (let i = 0; i < this.renderers.length; i++) {\r\n        this.renderers[i].onAnimationFrame();\r\n    }\r\n    this.redraw(true);\r\n    if (this.pendingAnimations.length) {\r\n        this.animator = requestAnimationFrame(this.onAnimate.bind(this));\r\n    } else {\r\n        this.animator = null;\r\n    }\r\n};\r\n\r\nTayberry.prototype.setSeriesVisibility = function(series, visible, subtype) {\r\n    series.visible = visible ? constants.visibilityState.visible : constants.visibilityState.hidden;\r\n    series.visible |= constants.visibilityState.transitioning;\r\n\r\n    if (series.animationState) {\r\n        const newType = visible ? 'show' : 'hide';\r\n        if (series.animationState.type !== newType) {\r\n            series.animationState.type = newType;\r\n            series.animationState.stage = 1 - series.animationState.stage;\r\n\r\n            delete series.animationState.animator;\r\n            this.revokeAnimation(series);\r\n        }\r\n    } else {\r\n        series.animationState = {\r\n            type: (series.visible & constants.visibilityState.visible) ? 'show' : 'hide',\r\n            subtype: subtype,\r\n            stage: 0\r\n        };\r\n    }\r\n    if (!series.animationState.animator) {\r\n        series.animationState.animator = this.startAnimation({\r\n            type: visible ? 'showSeries' : 'hideSeries',\r\n            series: series,\r\n            initialStage: series.animationState.stage,\r\n            onFrame: (stage) => series.animationState.stage = stage,\r\n            onCompletion: () => {\r\n                series.visible = (series.visible & ~constants.visibilityState.transitioning);\r\n                delete series.animationState;\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\nTayberry.prototype.toggleSeriesVisibility = function(series) {\r\n    this.setSeriesVisibility(series, !(series.visible & constants.visibilityState.visible))\r\n};\r\n","import {Tayberry as TayberryBase} from './base';\r\nimport './axis';\r\nimport './core';\r\nimport './drawing';\r\nimport './events';\r\nimport './defaults';\r\nimport './sizing';\r\nimport './legend';\r\nimport './animation';\r\nimport './renderer.base';\r\nimport './renderer.bar';\r\nimport './renderer.line';\r\n\r\n\r\nlet Tayberry = {\r\n    /**\r\n     * Creates a Tayberry chart\r\n     *\r\n     * @param element   ID of container div, or HTMLElement\r\n     * @param options   Options object\r\n     */\r\n    create: function (element, options) {\r\n        let chart = new TayberryBase();\r\n        chart.create(element);\r\n        chart.setOptions(options);\r\n        chart.render();\r\n    }\r\n};\r\n\r\nexport default Tayberry;"],"sourceRoot":"/source/"}